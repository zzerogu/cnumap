// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: trip.proto
// Protobuf C++ Version: 5.29.1

#include "trip.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/io/zero_copy_stream_impl_lite.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace valhalla {

inline constexpr TripLeg_TrafficSegment::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : segment_id_{::uint64_t{0u}},
        begin_percent_{0},
        end_percent_{0},
        starts_segment_{false},
        ends_segment_{false},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR TripLeg_TrafficSegment::TripLeg_TrafficSegment(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TripLeg_TrafficSegmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_TrafficSegmentDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_TrafficSegmentDefaultTypeInternal() {}
  union {
    TripLeg_TrafficSegment _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_TrafficSegmentDefaultTypeInternal _TripLeg_TrafficSegment_default_instance_;

inline constexpr TripLeg_TimeDomain::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : day_dow_type_{static_cast< ::valhalla::TripLeg_TimeDomain_DayDowType >(0)},
        dow_mask_{0u},
        begin_hrs_{0u},
        begin_mins_{0u},
        begin_month_{0u},
        begin_day_dow_{0u},
        begin_week_{0u},
        end_hrs_{0u},
        end_mins_{0u},
        end_month_{0u},
        end_day_dow_{0u},
        end_week_{0u},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR TripLeg_TimeDomain::TripLeg_TimeDomain(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TripLeg_TimeDomainDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_TimeDomainDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_TimeDomainDefaultTypeInternal() {}
  union {
    TripLeg_TimeDomain _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_TimeDomainDefaultTypeInternal _TripLeg_TimeDomain_default_instance_;

inline constexpr TripLeg_ShapeAttributes::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : time_{},
        _time_cached_byte_size_{0},
        length_{},
        _length_cached_byte_size_{0},
        speed_{},
        _speed_cached_byte_size_{0},
        speed_limit_{},
        _speed_limit_cached_byte_size_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR TripLeg_ShapeAttributes::TripLeg_ShapeAttributes(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TripLeg_ShapeAttributesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_ShapeAttributesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_ShapeAttributesDefaultTypeInternal() {}
  union {
    TripLeg_ShapeAttributes _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_ShapeAttributesDefaultTypeInternal _TripLeg_ShapeAttributes_default_instance_;

inline constexpr TripLeg_Restriction::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : type_{0u},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR TripLeg_Restriction::TripLeg_Restriction(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TripLeg_RestrictionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_RestrictionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_RestrictionDefaultTypeInternal() {}
  union {
    TripLeg_Restriction _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_RestrictionDefaultTypeInternal _TripLeg_Restriction_default_instance_;

inline constexpr TripLeg_LaneConnectivity::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : from_lanes_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        to_lanes_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        from_way_id_{::uint64_t{0u}},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR TripLeg_LaneConnectivity::TripLeg_LaneConnectivity(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TripLeg_LaneConnectivityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_LaneConnectivityDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_LaneConnectivityDefaultTypeInternal() {}
  union {
    TripLeg_LaneConnectivity _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_LaneConnectivityDefaultTypeInternal _TripLeg_LaneConnectivity_default_instance_;

inline constexpr TripLeg_Edge_Level::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : start_{0},
        end_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR TripLeg_Edge_Level::TripLeg_Edge_Level(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TripLeg_Edge_LevelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_Edge_LevelDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_Edge_LevelDefaultTypeInternal() {}
  union {
    TripLeg_Edge_Level _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_Edge_LevelDefaultTypeInternal _TripLeg_Edge_Level_default_instance_;

inline constexpr TripLeg_Cost::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : seconds_{0},
        cost_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR TripLeg_Cost::TripLeg_Cost(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TripLeg_CostDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_CostDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_CostDefaultTypeInternal() {}
  union {
    TripLeg_Cost _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_CostDefaultTypeInternal _TripLeg_Cost_default_instance_;

inline constexpr TripLeg_Closure::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : has_begin_shape_index_{},
        has_end_shape_index_{},
        _cached_size_{0},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR TripLeg_Closure::TripLeg_Closure(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TripLeg_ClosureDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_ClosureDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_ClosureDefaultTypeInternal() {}
  union {
    TripLeg_Closure _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_ClosureDefaultTypeInternal _TripLeg_Closure_default_instance_;

inline constexpr TripLeg_Admin::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : country_code_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        country_text_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        state_code_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        state_text_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR TripLeg_Admin::TripLeg_Admin(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TripLeg_AdminDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_AdminDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_AdminDefaultTypeInternal() {}
  union {
    TripLeg_Admin _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_AdminDefaultTypeInternal _TripLeg_Admin_default_instance_;

inline constexpr TripLeg_PathCost::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        elapsed_cost_{nullptr},
        transition_cost_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR TripLeg_PathCost::TripLeg_PathCost(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TripLeg_PathCostDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_PathCostDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_PathCostDefaultTypeInternal() {}
  union {
    TripLeg_PathCost _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_PathCostDefaultTypeInternal _TripLeg_PathCost_default_instance_;

inline constexpr TripLeg_ConditionalSpeedLimit::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        condition_{nullptr},
        speed_limit_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR TripLeg_ConditionalSpeedLimit::TripLeg_ConditionalSpeedLimit(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TripLeg_ConditionalSpeedLimitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_ConditionalSpeedLimitDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_ConditionalSpeedLimitDefaultTypeInternal() {}
  union {
    TripLeg_ConditionalSpeedLimit _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_ConditionalSpeedLimitDefaultTypeInternal _TripLeg_ConditionalSpeedLimit_default_instance_;

inline constexpr TripLeg_Incident::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        metadata_{nullptr},
        begin_shape_index_{0u},
        end_shape_index_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR TripLeg_Incident::TripLeg_Incident(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TripLeg_IncidentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_IncidentDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_IncidentDefaultTypeInternal() {}
  union {
    TripLeg_Incident _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_IncidentDefaultTypeInternal _TripLeg_Incident_default_instance_;

inline constexpr TripLeg_IntersectingEdge::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        name_{},
        sign_{nullptr},
        begin_heading_{0u},
        prev_name_consistency_{false},
        curr_name_consistency_{false},
        driveability_{static_cast< ::valhalla::TripLeg_Traversability >(0)},
        cyclability_{static_cast< ::valhalla::TripLeg_Traversability >(0)},
        walkability_{static_cast< ::valhalla::TripLeg_Traversability >(0)},
        use_{static_cast< ::valhalla::TripLeg_Use >(0)},
        road_class_{static_cast< ::valhalla::RoadClass >(0)},
        lane_count_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR TripLeg_IntersectingEdge::TripLeg_IntersectingEdge(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TripLeg_IntersectingEdgeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_IntersectingEdgeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_IntersectingEdgeDefaultTypeInternal() {}
  union {
    TripLeg_IntersectingEdge _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_IntersectingEdgeDefaultTypeInternal _TripLeg_IntersectingEdge_default_instance_;

inline constexpr TripLeg_Edge::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        name_{},
        lane_connectivity_{},
        traffic_segment_{},
        turn_lanes_{},
        tagged_value_{},
        landmarks_{},
        tunnel_name_{},
        elevation_{},
        conditional_speed_limits_{},
        levels_{},
        sign_{nullptr},
        transit_route_info_{nullptr},
        restriction_{nullptr},
        length_km_{0},
        speed_{0},
        road_class_{static_cast< ::valhalla::RoadClass >(0)},
        begin_heading_{0u},
        end_heading_{0u},
        begin_shape_index_{0u},
        end_shape_index_{0u},
        traversability_{static_cast< ::valhalla::TripLeg_Traversability >(0)},
        use_{static_cast< ::valhalla::TripLeg_Use >(0)},
        toll_{false},
        unpaved_{false},
        tunnel_{false},
        bridge_{false},
        surface_{static_cast< ::valhalla::TripLeg_Surface >(0)},
        travel_mode_{static_cast< ::valhalla::TravelMode >(0)},
        roundabout_{false},
        internal_intersection_{false},
        drive_on_left_{false},
        bicycle_network_{false},
        vehicle_type_{static_cast< ::valhalla::VehicleType >(0)},
        pedestrian_type_{static_cast< ::valhalla::PedestrianType >(0)},
        bicycle_type_{static_cast< ::valhalla::BicycleType >(0)},
        id_{::uint64_t{0u}},
        transit_type_{static_cast< ::valhalla::TransitType >(0)},
        weighted_grade_{0},
        way_id_{::uint64_t{0u}},
        max_upward_grade_{0},
        max_downward_grade_{0},
        lane_count_{0u},
        cycle_lane_{static_cast< ::valhalla::TripLeg_CycleLane >(0)},
        sidewalk_{static_cast< ::valhalla::TripLeg_Sidewalk >(0)},
        density_{0u},
        speed_limit_{0u},
        truck_speed_{0},
        mean_elevation_{0},
        truck_route_{false},
        has_time_restrictions_{false},
        destination_only_{false},
        is_urban_{false},
        default_speed_{0},
        source_along_edge_{0},
        target_along_edge_{0},
        sac_scale_{static_cast< ::valhalla::TripLeg_SacScale >(0)},
        shoulder_{false},
        indoor_{false},
        country_crossing_{false},
        forward_{false},
        elevation_sampling_interval_{0},
        level_precision_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR TripLeg_Edge::TripLeg_Edge(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TripLeg_EdgeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_EdgeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_EdgeDefaultTypeInternal() {}
  union {
    TripLeg_Edge _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_EdgeDefaultTypeInternal _TripLeg_Edge_default_instance_;

inline constexpr TripLeg_Node::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        intersecting_edge_{},
        recosts_{},
        time_zone_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        edge_{nullptr},
        transit_platform_info_{nullptr},
        transit_station_info_{nullptr},
        transit_egress_info_{nullptr},
        cost_{nullptr},
        bss_info_{nullptr},
        admin_index_{0u},
        type_{static_cast< ::valhalla::TripLeg_Node_Type >(0)},
        fork_{false},
        traffic_signal_{false} {}

template <typename>
PROTOBUF_CONSTEXPR TripLeg_Node::TripLeg_Node(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TripLeg_NodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLeg_NodeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLeg_NodeDefaultTypeInternal() {}
  union {
    TripLeg_Node _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLeg_NodeDefaultTypeInternal _TripLeg_Node_default_instance_;

inline constexpr TripLeg::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        location_{},
        node_{},
        admin_{},
        incidents_{},
        algorithms_{},
        closures_{},
        level_changes_{},
        shape_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        bbox_{nullptr},
        shape_attributes_{nullptr},
        summary_{nullptr},
        osm_changeset_{::uint64_t{0u}},
        trip_id_{::uint64_t{0u}},
        leg_id_{0u},
        leg_count_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR TripLeg::TripLeg(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TripLegDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripLegDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripLegDefaultTypeInternal() {}
  union {
    TripLeg _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripLegDefaultTypeInternal _TripLeg_default_instance_;

inline constexpr TripRoute::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : legs_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR TripRoute::TripRoute(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TripRouteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripRouteDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripRouteDefaultTypeInternal() {}
  union {
    TripRoute _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripRouteDefaultTypeInternal _TripRoute_default_instance_;

inline constexpr Trip::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : routes_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Trip::Trip(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TripDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripDefaultTypeInternal() {}
  union {
    Trip _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripDefaultTypeInternal _Trip_default_instance_;
}  // namespace valhalla
namespace valhalla {
PROTOBUF_CONSTINIT const uint32_t TripLeg_TimeDomain_DayDowType_internal_data_[] = {
    131072u, 0u, };
bool TripLeg_TimeDomain_DayDowType_IsValid(int value) {
  return 0 <= value && value <= 1;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    TripLeg_TimeDomain_DayDowType_strings[2] = {};

static const char TripLeg_TimeDomain_DayDowType_names[] = {
    "kDayOfMonth"
    "kNthDayOfWeek"
};

static const ::google::protobuf::internal::EnumEntry TripLeg_TimeDomain_DayDowType_entries[] =
    {
        {{&TripLeg_TimeDomain_DayDowType_names[0], 11}, 0},
        {{&TripLeg_TimeDomain_DayDowType_names[11], 13}, 1},
};

static const int TripLeg_TimeDomain_DayDowType_entries_by_number[] = {
    0,  // 0 -> kDayOfMonth
    1,  // 1 -> kNthDayOfWeek
};

const std::string& TripLeg_TimeDomain_DayDowType_Name(TripLeg_TimeDomain_DayDowType value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          TripLeg_TimeDomain_DayDowType_entries, TripLeg_TimeDomain_DayDowType_entries_by_number,
          2, TripLeg_TimeDomain_DayDowType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      TripLeg_TimeDomain_DayDowType_entries, TripLeg_TimeDomain_DayDowType_entries_by_number, 2,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : TripLeg_TimeDomain_DayDowType_strings[idx].get();
}

bool TripLeg_TimeDomain_DayDowType_Parse(absl::string_view name, TripLeg_TimeDomain_DayDowType* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      TripLeg_TimeDomain_DayDowType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_TimeDomain_DayDowType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr TripLeg_TimeDomain_DayDowType TripLeg_TimeDomain::kDayOfMonth;
constexpr TripLeg_TimeDomain_DayDowType TripLeg_TimeDomain::kNthDayOfWeek;
constexpr TripLeg_TimeDomain_DayDowType TripLeg_TimeDomain::DayDowType_MIN;
constexpr TripLeg_TimeDomain_DayDowType TripLeg_TimeDomain::DayDowType_MAX;
constexpr int TripLeg_TimeDomain::DayDowType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t TripLeg_Node_Type_internal_data_[] = {
    983040u, 0u, };
bool TripLeg_Node_Type_IsValid(int value) {
  return 0 <= value && value <= 14;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    TripLeg_Node_Type_strings[15] = {};

static const char TripLeg_Node_Type_names[] = {
    "kBikeShare"
    "kBollard"
    "kBorderControl"
    "kBuildingEntrance"
    "kElevator"
    "kGate"
    "kMotorwayJunction"
    "kParking"
    "kStreetIntersection"
    "kSumpBuster"
    "kTollBooth"
    "kTollGantry"
    "kTransitEgress"
    "kTransitPlatform"
    "kTransitStation"
};

static const ::google::protobuf::internal::EnumEntry TripLeg_Node_Type_entries[] =
    {
        {{&TripLeg_Node_Type_names[0], 10}, 7},
        {{&TripLeg_Node_Type_names[10], 8}, 2},
        {{&TripLeg_Node_Type_names[18], 14}, 10},
        {{&TripLeg_Node_Type_names[32], 17}, 13},
        {{&TripLeg_Node_Type_names[49], 9}, 14},
        {{&TripLeg_Node_Type_names[58], 5}, 1},
        {{&TripLeg_Node_Type_names[63], 17}, 9},
        {{&TripLeg_Node_Type_names[80], 8}, 8},
        {{&TripLeg_Node_Type_names[88], 19}, 0},
        {{&TripLeg_Node_Type_names[107], 11}, 12},
        {{&TripLeg_Node_Type_names[118], 10}, 3},
        {{&TripLeg_Node_Type_names[128], 11}, 11},
        {{&TripLeg_Node_Type_names[139], 14}, 4},
        {{&TripLeg_Node_Type_names[153], 16}, 6},
        {{&TripLeg_Node_Type_names[169], 15}, 5},
};

static const int TripLeg_Node_Type_entries_by_number[] = {
    8,  // 0 -> kStreetIntersection
    5,  // 1 -> kGate
    1,  // 2 -> kBollard
    10,  // 3 -> kTollBooth
    12,  // 4 -> kTransitEgress
    14,  // 5 -> kTransitStation
    13,  // 6 -> kTransitPlatform
    0,  // 7 -> kBikeShare
    7,  // 8 -> kParking
    6,  // 9 -> kMotorwayJunction
    2,  // 10 -> kBorderControl
    11,  // 11 -> kTollGantry
    9,  // 12 -> kSumpBuster
    3,  // 13 -> kBuildingEntrance
    4,  // 14 -> kElevator
};

const std::string& TripLeg_Node_Type_Name(TripLeg_Node_Type value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          TripLeg_Node_Type_entries, TripLeg_Node_Type_entries_by_number,
          15, TripLeg_Node_Type_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      TripLeg_Node_Type_entries, TripLeg_Node_Type_entries_by_number, 15,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : TripLeg_Node_Type_strings[idx].get();
}

bool TripLeg_Node_Type_Parse(absl::string_view name, TripLeg_Node_Type* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      TripLeg_Node_Type_entries, 15, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Node_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr TripLeg_Node_Type TripLeg_Node::kStreetIntersection;
constexpr TripLeg_Node_Type TripLeg_Node::kGate;
constexpr TripLeg_Node_Type TripLeg_Node::kBollard;
constexpr TripLeg_Node_Type TripLeg_Node::kTollBooth;
constexpr TripLeg_Node_Type TripLeg_Node::kTransitEgress;
constexpr TripLeg_Node_Type TripLeg_Node::kTransitStation;
constexpr TripLeg_Node_Type TripLeg_Node::kTransitPlatform;
constexpr TripLeg_Node_Type TripLeg_Node::kBikeShare;
constexpr TripLeg_Node_Type TripLeg_Node::kParking;
constexpr TripLeg_Node_Type TripLeg_Node::kMotorwayJunction;
constexpr TripLeg_Node_Type TripLeg_Node::kBorderControl;
constexpr TripLeg_Node_Type TripLeg_Node::kTollGantry;
constexpr TripLeg_Node_Type TripLeg_Node::kSumpBuster;
constexpr TripLeg_Node_Type TripLeg_Node::kBuildingEntrance;
constexpr TripLeg_Node_Type TripLeg_Node::kElevator;
constexpr TripLeg_Node_Type TripLeg_Node::Type_MIN;
constexpr TripLeg_Node_Type TripLeg_Node::Type_MAX;
constexpr int TripLeg_Node::Type_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t TripLeg_Traversability_internal_data_[] = {
    262144u, 0u, };
bool TripLeg_Traversability_IsValid(int value) {
  return 0 <= value && value <= 3;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    TripLeg_Traversability_strings[4] = {};

static const char TripLeg_Traversability_names[] = {
    "kBackward"
    "kBoth"
    "kForward"
    "kNone"
};

static const ::google::protobuf::internal::EnumEntry TripLeg_Traversability_entries[] =
    {
        {{&TripLeg_Traversability_names[0], 9}, 2},
        {{&TripLeg_Traversability_names[9], 5}, 3},
        {{&TripLeg_Traversability_names[14], 8}, 1},
        {{&TripLeg_Traversability_names[22], 5}, 0},
};

static const int TripLeg_Traversability_entries_by_number[] = {
    3,  // 0 -> kNone
    2,  // 1 -> kForward
    0,  // 2 -> kBackward
    1,  // 3 -> kBoth
};

const std::string& TripLeg_Traversability_Name(TripLeg_Traversability value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          TripLeg_Traversability_entries, TripLeg_Traversability_entries_by_number,
          4, TripLeg_Traversability_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      TripLeg_Traversability_entries, TripLeg_Traversability_entries_by_number, 4,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : TripLeg_Traversability_strings[idx].get();
}

bool TripLeg_Traversability_Parse(absl::string_view name, TripLeg_Traversability* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      TripLeg_Traversability_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Traversability>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr TripLeg_Traversability TripLeg::kNone;
constexpr TripLeg_Traversability TripLeg::kForward;
constexpr TripLeg_Traversability TripLeg::kBackward;
constexpr TripLeg_Traversability TripLeg::kBoth;
constexpr TripLeg_Traversability TripLeg::Traversability_MIN;
constexpr TripLeg_Traversability TripLeg::Traversability_MAX;
constexpr int TripLeg::Traversability_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t TripLeg_Use_internal_data_[] = {
    786432u, 64u, 4034917120u, 1984u, };
bool TripLeg_Use_IsValid(int value) {
  return 0 <= value && value <= 54 && ((34919424132648959u >> value) & 1) != 0;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    TripLeg_Use_strings[34] = {};

static const char TripLeg_Use_names[] = {
    "kAlleyUse"
    "kBridlewayUse"
    "kBusUse"
    "kConstructionUse"
    "kCuldesacUse"
    "kCyclewayUse"
    "kDriveThruUse"
    "kDrivewayUse"
    "kEgressConnectionUse"
    "kElevatorUse"
    "kEmergencyAccessUse"
    "kEscalatorUse"
    "kFerryUse"
    "kFootwayUse"
    "kLivingStreetUse"
    "kMountainBikeUse"
    "kOtherUse"
    "kParkingAisleUse"
    "kPathUse"
    "kPedestrianCrossingUse"
    "kPedestrianUse"
    "kPlatformConnectionUse"
    "kRailFerryUse"
    "kRailUse"
    "kRampUse"
    "kRestAreaUse"
    "kRoadUse"
    "kServiceAreaUse"
    "kServiceRoadUse"
    "kSidewalkUse"
    "kStepsUse"
    "kTrackUse"
    "kTransitConnectionUse"
    "kTurnChannelUse"
};

static const ::google::protobuf::internal::EnumEntry TripLeg_Use_entries[] =
    {
        {{&TripLeg_Use_names[0], 9}, 5},
        {{&TripLeg_Use_names[9], 13}, 29},
        {{&TripLeg_Use_names[22], 7}, 51},
        {{&TripLeg_Use_names[29], 16}, 43},
        {{&TripLeg_Use_names[45], 12}, 9},
        {{&TripLeg_Use_names[57], 12}, 20},
        {{&TripLeg_Use_names[69], 13}, 8},
        {{&TripLeg_Use_names[82], 12}, 4},
        {{&TripLeg_Use_names[94], 20}, 52},
        {{&TripLeg_Use_names[114], 12}, 33},
        {{&TripLeg_Use_names[126], 19}, 7},
        {{&TripLeg_Use_names[145], 13}, 34},
        {{&TripLeg_Use_names[158], 9}, 41},
        {{&TripLeg_Use_names[167], 11}, 25},
        {{&TripLeg_Use_names[178], 16}, 10},
        {{&TripLeg_Use_names[194], 16}, 21},
        {{&TripLeg_Use_names[210], 9}, 40},
        {{&TripLeg_Use_names[219], 16}, 6},
        {{&TripLeg_Use_names[235], 8}, 27},
        {{&TripLeg_Use_names[243], 22}, 32},
        {{&TripLeg_Use_names[265], 14}, 28},
        {{&TripLeg_Use_names[279], 22}, 53},
        {{&TripLeg_Use_names[301], 13}, 42},
        {{&TripLeg_Use_names[314], 8}, 50},
        {{&TripLeg_Use_names[322], 8}, 1},
        {{&TripLeg_Use_names[330], 12}, 30},
        {{&TripLeg_Use_names[342], 8}, 0},
        {{&TripLeg_Use_names[350], 15}, 31},
        {{&TripLeg_Use_names[365], 15}, 11},
        {{&TripLeg_Use_names[380], 12}, 24},
        {{&TripLeg_Use_names[392], 9}, 26},
        {{&TripLeg_Use_names[401], 9}, 3},
        {{&TripLeg_Use_names[410], 21}, 54},
        {{&TripLeg_Use_names[431], 15}, 2},
};

static const int TripLeg_Use_entries_by_number[] = {
    26,  // 0 -> kRoadUse
    24,  // 1 -> kRampUse
    33,  // 2 -> kTurnChannelUse
    31,  // 3 -> kTrackUse
    7,  // 4 -> kDrivewayUse
    0,  // 5 -> kAlleyUse
    17,  // 6 -> kParkingAisleUse
    10,  // 7 -> kEmergencyAccessUse
    6,  // 8 -> kDriveThruUse
    4,  // 9 -> kCuldesacUse
    14,  // 10 -> kLivingStreetUse
    28,  // 11 -> kServiceRoadUse
    5,  // 20 -> kCyclewayUse
    15,  // 21 -> kMountainBikeUse
    29,  // 24 -> kSidewalkUse
    13,  // 25 -> kFootwayUse
    30,  // 26 -> kStepsUse
    18,  // 27 -> kPathUse
    20,  // 28 -> kPedestrianUse
    1,  // 29 -> kBridlewayUse
    25,  // 30 -> kRestAreaUse
    27,  // 31 -> kServiceAreaUse
    19,  // 32 -> kPedestrianCrossingUse
    9,  // 33 -> kElevatorUse
    11,  // 34 -> kEscalatorUse
    16,  // 40 -> kOtherUse
    12,  // 41 -> kFerryUse
    22,  // 42 -> kRailFerryUse
    3,  // 43 -> kConstructionUse
    23,  // 50 -> kRailUse
    2,  // 51 -> kBusUse
    8,  // 52 -> kEgressConnectionUse
    21,  // 53 -> kPlatformConnectionUse
    32,  // 54 -> kTransitConnectionUse
};

const std::string& TripLeg_Use_Name(TripLeg_Use value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          TripLeg_Use_entries, TripLeg_Use_entries_by_number,
          34, TripLeg_Use_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      TripLeg_Use_entries, TripLeg_Use_entries_by_number, 34,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : TripLeg_Use_strings[idx].get();
}

bool TripLeg_Use_Parse(absl::string_view name, TripLeg_Use* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      TripLeg_Use_entries, 34, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Use>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr TripLeg_Use TripLeg::kRoadUse;
constexpr TripLeg_Use TripLeg::kRampUse;
constexpr TripLeg_Use TripLeg::kTurnChannelUse;
constexpr TripLeg_Use TripLeg::kTrackUse;
constexpr TripLeg_Use TripLeg::kDrivewayUse;
constexpr TripLeg_Use TripLeg::kAlleyUse;
constexpr TripLeg_Use TripLeg::kParkingAisleUse;
constexpr TripLeg_Use TripLeg::kEmergencyAccessUse;
constexpr TripLeg_Use TripLeg::kDriveThruUse;
constexpr TripLeg_Use TripLeg::kCuldesacUse;
constexpr TripLeg_Use TripLeg::kLivingStreetUse;
constexpr TripLeg_Use TripLeg::kServiceRoadUse;
constexpr TripLeg_Use TripLeg::kCyclewayUse;
constexpr TripLeg_Use TripLeg::kMountainBikeUse;
constexpr TripLeg_Use TripLeg::kSidewalkUse;
constexpr TripLeg_Use TripLeg::kFootwayUse;
constexpr TripLeg_Use TripLeg::kStepsUse;
constexpr TripLeg_Use TripLeg::kPathUse;
constexpr TripLeg_Use TripLeg::kPedestrianUse;
constexpr TripLeg_Use TripLeg::kBridlewayUse;
constexpr TripLeg_Use TripLeg::kPedestrianCrossingUse;
constexpr TripLeg_Use TripLeg::kElevatorUse;
constexpr TripLeg_Use TripLeg::kEscalatorUse;
constexpr TripLeg_Use TripLeg::kRestAreaUse;
constexpr TripLeg_Use TripLeg::kServiceAreaUse;
constexpr TripLeg_Use TripLeg::kOtherUse;
constexpr TripLeg_Use TripLeg::kFerryUse;
constexpr TripLeg_Use TripLeg::kRailFerryUse;
constexpr TripLeg_Use TripLeg::kConstructionUse;
constexpr TripLeg_Use TripLeg::kRailUse;
constexpr TripLeg_Use TripLeg::kBusUse;
constexpr TripLeg_Use TripLeg::kEgressConnectionUse;
constexpr TripLeg_Use TripLeg::kPlatformConnectionUse;
constexpr TripLeg_Use TripLeg::kTransitConnectionUse;
constexpr TripLeg_Use TripLeg::Use_MIN;
constexpr TripLeg_Use TripLeg::Use_MAX;
constexpr int TripLeg::Use_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t TripLeg_Surface_internal_data_[] = {
    524288u, 0u, };
bool TripLeg_Surface_IsValid(int value) {
  return 0 <= value && value <= 7;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    TripLeg_Surface_strings[8] = {};

static const char TripLeg_Surface_names[] = {
    "kCompacted"
    "kDirt"
    "kGravel"
    "kImpassable"
    "kPath"
    "kPaved"
    "kPavedRough"
    "kPavedSmooth"
};

static const ::google::protobuf::internal::EnumEntry TripLeg_Surface_entries[] =
    {
        {{&TripLeg_Surface_names[0], 10}, 3},
        {{&TripLeg_Surface_names[10], 5}, 4},
        {{&TripLeg_Surface_names[15], 7}, 5},
        {{&TripLeg_Surface_names[22], 11}, 7},
        {{&TripLeg_Surface_names[33], 5}, 6},
        {{&TripLeg_Surface_names[38], 6}, 1},
        {{&TripLeg_Surface_names[44], 11}, 2},
        {{&TripLeg_Surface_names[55], 12}, 0},
};

static const int TripLeg_Surface_entries_by_number[] = {
    7,  // 0 -> kPavedSmooth
    5,  // 1 -> kPaved
    6,  // 2 -> kPavedRough
    0,  // 3 -> kCompacted
    1,  // 4 -> kDirt
    2,  // 5 -> kGravel
    4,  // 6 -> kPath
    3,  // 7 -> kImpassable
};

const std::string& TripLeg_Surface_Name(TripLeg_Surface value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          TripLeg_Surface_entries, TripLeg_Surface_entries_by_number,
          8, TripLeg_Surface_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      TripLeg_Surface_entries, TripLeg_Surface_entries_by_number, 8,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : TripLeg_Surface_strings[idx].get();
}

bool TripLeg_Surface_Parse(absl::string_view name, TripLeg_Surface* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      TripLeg_Surface_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Surface>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr TripLeg_Surface TripLeg::kPavedSmooth;
constexpr TripLeg_Surface TripLeg::kPaved;
constexpr TripLeg_Surface TripLeg::kPavedRough;
constexpr TripLeg_Surface TripLeg::kCompacted;
constexpr TripLeg_Surface TripLeg::kDirt;
constexpr TripLeg_Surface TripLeg::kGravel;
constexpr TripLeg_Surface TripLeg::kPath;
constexpr TripLeg_Surface TripLeg::kImpassable;
constexpr TripLeg_Surface TripLeg::Surface_MIN;
constexpr TripLeg_Surface TripLeg::Surface_MAX;
constexpr int TripLeg::Surface_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t TripLeg_CycleLane_internal_data_[] = {
    262144u, 0u, };
bool TripLeg_CycleLane_IsValid(int value) {
  return 0 <= value && value <= 3;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    TripLeg_CycleLane_strings[4] = {};

static const char TripLeg_CycleLane_names[] = {
    "kDedicated"
    "kNoCycleLane"
    "kSeparated"
    "kShared"
};

static const ::google::protobuf::internal::EnumEntry TripLeg_CycleLane_entries[] =
    {
        {{&TripLeg_CycleLane_names[0], 10}, 2},
        {{&TripLeg_CycleLane_names[10], 12}, 0},
        {{&TripLeg_CycleLane_names[22], 10}, 3},
        {{&TripLeg_CycleLane_names[32], 7}, 1},
};

static const int TripLeg_CycleLane_entries_by_number[] = {
    1,  // 0 -> kNoCycleLane
    3,  // 1 -> kShared
    0,  // 2 -> kDedicated
    2,  // 3 -> kSeparated
};

const std::string& TripLeg_CycleLane_Name(TripLeg_CycleLane value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          TripLeg_CycleLane_entries, TripLeg_CycleLane_entries_by_number,
          4, TripLeg_CycleLane_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      TripLeg_CycleLane_entries, TripLeg_CycleLane_entries_by_number, 4,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : TripLeg_CycleLane_strings[idx].get();
}

bool TripLeg_CycleLane_Parse(absl::string_view name, TripLeg_CycleLane* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      TripLeg_CycleLane_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_CycleLane>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr TripLeg_CycleLane TripLeg::kNoCycleLane;
constexpr TripLeg_CycleLane TripLeg::kShared;
constexpr TripLeg_CycleLane TripLeg::kDedicated;
constexpr TripLeg_CycleLane TripLeg::kSeparated;
constexpr TripLeg_CycleLane TripLeg::CycleLane_MIN;
constexpr TripLeg_CycleLane TripLeg::CycleLane_MAX;
constexpr int TripLeg::CycleLane_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t TripLeg_SacScale_internal_data_[] = {
    458752u, 0u, };
bool TripLeg_SacScale_IsValid(int value) {
  return 0 <= value && value <= 6;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    TripLeg_SacScale_strings[7] = {};

static const char TripLeg_SacScale_names[] = {
    "kAlpineHiking"
    "kDemandingAlpineHiking"
    "kDemandingMountainHiking"
    "kDifficultAlpineHiking"
    "kHiking"
    "kMountainHiking"
    "kNoSacScale"
};

static const ::google::protobuf::internal::EnumEntry TripLeg_SacScale_entries[] =
    {
        {{&TripLeg_SacScale_names[0], 13}, 4},
        {{&TripLeg_SacScale_names[13], 22}, 5},
        {{&TripLeg_SacScale_names[35], 24}, 3},
        {{&TripLeg_SacScale_names[59], 22}, 6},
        {{&TripLeg_SacScale_names[81], 7}, 1},
        {{&TripLeg_SacScale_names[88], 15}, 2},
        {{&TripLeg_SacScale_names[103], 11}, 0},
};

static const int TripLeg_SacScale_entries_by_number[] = {
    6,  // 0 -> kNoSacScale
    4,  // 1 -> kHiking
    5,  // 2 -> kMountainHiking
    2,  // 3 -> kDemandingMountainHiking
    0,  // 4 -> kAlpineHiking
    1,  // 5 -> kDemandingAlpineHiking
    3,  // 6 -> kDifficultAlpineHiking
};

const std::string& TripLeg_SacScale_Name(TripLeg_SacScale value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          TripLeg_SacScale_entries, TripLeg_SacScale_entries_by_number,
          7, TripLeg_SacScale_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      TripLeg_SacScale_entries, TripLeg_SacScale_entries_by_number, 7,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : TripLeg_SacScale_strings[idx].get();
}

bool TripLeg_SacScale_Parse(absl::string_view name, TripLeg_SacScale* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      TripLeg_SacScale_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_SacScale>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr TripLeg_SacScale TripLeg::kNoSacScale;
constexpr TripLeg_SacScale TripLeg::kHiking;
constexpr TripLeg_SacScale TripLeg::kMountainHiking;
constexpr TripLeg_SacScale TripLeg::kDemandingMountainHiking;
constexpr TripLeg_SacScale TripLeg::kAlpineHiking;
constexpr TripLeg_SacScale TripLeg::kDemandingAlpineHiking;
constexpr TripLeg_SacScale TripLeg::kDifficultAlpineHiking;
constexpr TripLeg_SacScale TripLeg::SacScale_MIN;
constexpr TripLeg_SacScale TripLeg::SacScale_MAX;
constexpr int TripLeg::SacScale_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t TripLeg_Sidewalk_internal_data_[] = {
    262144u, 0u, };
bool TripLeg_Sidewalk_IsValid(int value) {
  return 0 <= value && value <= 3;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    TripLeg_Sidewalk_strings[4] = {};

static const char TripLeg_Sidewalk_names[] = {
    "kBothSides"
    "kLeft"
    "kNoSidewalk"
    "kRight"
};

static const ::google::protobuf::internal::EnumEntry TripLeg_Sidewalk_entries[] =
    {
        {{&TripLeg_Sidewalk_names[0], 10}, 3},
        {{&TripLeg_Sidewalk_names[10], 5}, 1},
        {{&TripLeg_Sidewalk_names[15], 11}, 0},
        {{&TripLeg_Sidewalk_names[26], 6}, 2},
};

static const int TripLeg_Sidewalk_entries_by_number[] = {
    2,  // 0 -> kNoSidewalk
    1,  // 1 -> kLeft
    3,  // 2 -> kRight
    0,  // 3 -> kBothSides
};

const std::string& TripLeg_Sidewalk_Name(TripLeg_Sidewalk value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          TripLeg_Sidewalk_entries, TripLeg_Sidewalk_entries_by_number,
          4, TripLeg_Sidewalk_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      TripLeg_Sidewalk_entries, TripLeg_Sidewalk_entries_by_number, 4,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : TripLeg_Sidewalk_strings[idx].get();
}

bool TripLeg_Sidewalk_Parse(absl::string_view name, TripLeg_Sidewalk* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      TripLeg_Sidewalk_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Sidewalk>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr TripLeg_Sidewalk TripLeg::kNoSidewalk;
constexpr TripLeg_Sidewalk TripLeg::kLeft;
constexpr TripLeg_Sidewalk TripLeg::kRight;
constexpr TripLeg_Sidewalk TripLeg::kBothSides;
constexpr TripLeg_Sidewalk TripLeg::Sidewalk_MIN;
constexpr TripLeg_Sidewalk TripLeg::Sidewalk_MAX;
constexpr int TripLeg::Sidewalk_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
// ===================================================================

class TripLeg_LaneConnectivity::_Internal {
 public:
};

TripLeg_LaneConnectivity::TripLeg_LaneConnectivity(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.LaneConnectivity)
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_LaneConnectivity::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::TripLeg_LaneConnectivity& from_msg)
      : from_lanes_(arena, from.from_lanes_),
        to_lanes_(arena, from.to_lanes_),
        _cached_size_{0} {}

TripLeg_LaneConnectivity::TripLeg_LaneConnectivity(
    ::google::protobuf::Arena* arena,
    const TripLeg_LaneConnectivity& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TripLeg_LaneConnectivity* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.from_way_id_ = from._impl_.from_way_id_;

  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.LaneConnectivity)
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_LaneConnectivity::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : from_lanes_(arena),
        to_lanes_(arena),
        _cached_size_{0} {}

inline void TripLeg_LaneConnectivity::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.from_way_id_ = {};
}
TripLeg_LaneConnectivity::~TripLeg_LaneConnectivity() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.LaneConnectivity)
  SharedDtor(*this);
}
inline void TripLeg_LaneConnectivity::SharedDtor(MessageLite& self) {
  TripLeg_LaneConnectivity& this_ = static_cast<TripLeg_LaneConnectivity&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.from_lanes_.Destroy();
  this_._impl_.to_lanes_.Destroy();
  this_._impl_.~Impl_();
}

inline void* TripLeg_LaneConnectivity::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TripLeg_LaneConnectivity(arena);
}
constexpr auto TripLeg_LaneConnectivity::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(TripLeg_LaneConnectivity),
                                            alignof(TripLeg_LaneConnectivity));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<34> TripLeg_LaneConnectivity::_class_data_ = {
    {
        &_TripLeg_LaneConnectivity_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TripLeg_LaneConnectivity::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TripLeg_LaneConnectivity>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TripLeg_LaneConnectivity::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TripLeg_LaneConnectivity>(), &TripLeg_LaneConnectivity::ByteSizeLong,
            &TripLeg_LaneConnectivity::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TripLeg_LaneConnectivity, _impl_._cached_size_),
        true,
    },
    "valhalla.TripLeg.LaneConnectivity",
};
const ::google::protobuf::internal::ClassData* TripLeg_LaneConnectivity::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 60, 2> TripLeg_LaneConnectivity::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TripLeg_LaneConnectivity>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // uint64 from_way_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_LaneConnectivity, _impl_.from_way_id_)}},
    // string from_lanes = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_LaneConnectivity, _impl_.from_lanes_)}},
    // string to_lanes = 3;
    {::_pbi::TcParser::FastUS1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_LaneConnectivity, _impl_.to_lanes_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint64 from_way_id = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_LaneConnectivity, _impl_.from_way_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
    // string from_lanes = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg_LaneConnectivity, _impl_.from_lanes_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string to_lanes = 3;
    {PROTOBUF_FIELD_OFFSET(TripLeg_LaneConnectivity, _impl_.to_lanes_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\41\0\12\10\0\0\0\0"
    "valhalla.TripLeg.LaneConnectivity"
    "from_lanes"
    "to_lanes"
  }},
};

PROTOBUF_NOINLINE void TripLeg_LaneConnectivity::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.LaneConnectivity)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.from_lanes_.ClearToEmpty();
  _impl_.to_lanes_.ClearToEmpty();
  _impl_.from_way_id_ = ::uint64_t{0u};
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TripLeg_LaneConnectivity::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TripLeg_LaneConnectivity& this_ = static_cast<const TripLeg_LaneConnectivity&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TripLeg_LaneConnectivity::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TripLeg_LaneConnectivity& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.LaneConnectivity)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // uint64 from_way_id = 1;
          if (this_._internal_from_way_id() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
                1, this_._internal_from_way_id(), target);
          }

          // string from_lanes = 2;
          if (!this_._internal_from_lanes().empty()) {
            const std::string& _s = this_._internal_from_lanes();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TripLeg.LaneConnectivity.from_lanes");
            target = stream->WriteStringMaybeAliased(2, _s, target);
          }

          // string to_lanes = 3;
          if (!this_._internal_to_lanes().empty()) {
            const std::string& _s = this_._internal_to_lanes();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TripLeg.LaneConnectivity.to_lanes");
            target = stream->WriteStringMaybeAliased(3, _s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.LaneConnectivity)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TripLeg_LaneConnectivity::ByteSizeLong(const MessageLite& base) {
          const TripLeg_LaneConnectivity& this_ = static_cast<const TripLeg_LaneConnectivity&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TripLeg_LaneConnectivity::ByteSizeLong() const {
          const TripLeg_LaneConnectivity& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.LaneConnectivity)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // string from_lanes = 2;
            if (!this_._internal_from_lanes().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_from_lanes());
            }
            // string to_lanes = 3;
            if (!this_._internal_to_lanes().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_to_lanes());
            }
            // uint64 from_way_id = 1;
            if (this_._internal_from_way_id() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
                  this_._internal_from_way_id());
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TripLeg_LaneConnectivity::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TripLeg_LaneConnectivity*>(&to_msg);
  auto& from = static_cast<const TripLeg_LaneConnectivity&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.LaneConnectivity)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_from_lanes().empty()) {
    _this->_internal_set_from_lanes(from._internal_from_lanes());
  }
  if (!from._internal_to_lanes().empty()) {
    _this->_internal_set_to_lanes(from._internal_to_lanes());
  }
  if (from._internal_from_way_id() != 0) {
    _this->_impl_.from_way_id_ = from._impl_.from_way_id_;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_LaneConnectivity::CopyFrom(const TripLeg_LaneConnectivity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.LaneConnectivity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TripLeg_LaneConnectivity::InternalSwap(TripLeg_LaneConnectivity* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.from_lanes_, &other->_impl_.from_lanes_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.to_lanes_, &other->_impl_.to_lanes_, arena);
        swap(_impl_.from_way_id_, other->_impl_.from_way_id_);
}

// ===================================================================

class TripLeg_TrafficSegment::_Internal {
 public:
};

TripLeg_TrafficSegment::TripLeg_TrafficSegment(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.TrafficSegment)
}
TripLeg_TrafficSegment::TripLeg_TrafficSegment(
    ::google::protobuf::Arena* arena, const TripLeg_TrafficSegment& from)
    : TripLeg_TrafficSegment(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_TrafficSegment::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void TripLeg_TrafficSegment::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, segment_id_),
           0,
           offsetof(Impl_, ends_segment_) -
               offsetof(Impl_, segment_id_) +
               sizeof(Impl_::ends_segment_));
}
TripLeg_TrafficSegment::~TripLeg_TrafficSegment() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.TrafficSegment)
  SharedDtor(*this);
}
inline void TripLeg_TrafficSegment::SharedDtor(MessageLite& self) {
  TripLeg_TrafficSegment& this_ = static_cast<TripLeg_TrafficSegment&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* TripLeg_TrafficSegment::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TripLeg_TrafficSegment(arena);
}
constexpr auto TripLeg_TrafficSegment::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(TripLeg_TrafficSegment),
                                            alignof(TripLeg_TrafficSegment));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<32> TripLeg_TrafficSegment::_class_data_ = {
    {
        &_TripLeg_TrafficSegment_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TripLeg_TrafficSegment::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TripLeg_TrafficSegment>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TripLeg_TrafficSegment::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TripLeg_TrafficSegment>(), &TripLeg_TrafficSegment::ByteSizeLong,
            &TripLeg_TrafficSegment::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_._cached_size_),
        true,
    },
    "valhalla.TripLeg.TrafficSegment",
};
const ::google::protobuf::internal::ClassData* TripLeg_TrafficSegment::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 2> TripLeg_TrafficSegment::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TripLeg_TrafficSegment>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // uint64 segment_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.segment_id_)}},
    // float begin_percent = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.begin_percent_)}},
    // float end_percent = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.end_percent_)}},
    // bool starts_segment = 4;
    {::_pbi::TcParser::FastV8S1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.starts_segment_)}},
    // bool ends_segment = 5;
    {::_pbi::TcParser::FastV8S1,
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.ends_segment_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // uint64 segment_id = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.segment_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
    // float begin_percent = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.begin_percent_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float end_percent = 3;
    {PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.end_percent_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // bool starts_segment = 4;
    {PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.starts_segment_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool ends_segment = 5;
    {PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.ends_segment_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void TripLeg_TrafficSegment::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.TrafficSegment)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.segment_id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.ends_segment_) -
      reinterpret_cast<char*>(&_impl_.segment_id_)) + sizeof(_impl_.ends_segment_));
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TripLeg_TrafficSegment::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TripLeg_TrafficSegment& this_ = static_cast<const TripLeg_TrafficSegment&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TripLeg_TrafficSegment::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TripLeg_TrafficSegment& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.TrafficSegment)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // uint64 segment_id = 1;
          if (this_._internal_segment_id() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
                1, this_._internal_segment_id(), target);
          }

          // float begin_percent = 2;
          if (::absl::bit_cast<::uint32_t>(this_._internal_begin_percent()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                2, this_._internal_begin_percent(), target);
          }

          // float end_percent = 3;
          if (::absl::bit_cast<::uint32_t>(this_._internal_end_percent()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                3, this_._internal_end_percent(), target);
          }

          // bool starts_segment = 4;
          if (this_._internal_starts_segment() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                4, this_._internal_starts_segment(), target);
          }

          // bool ends_segment = 5;
          if (this_._internal_ends_segment() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                5, this_._internal_ends_segment(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.TrafficSegment)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TripLeg_TrafficSegment::ByteSizeLong(const MessageLite& base) {
          const TripLeg_TrafficSegment& this_ = static_cast<const TripLeg_TrafficSegment&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TripLeg_TrafficSegment::ByteSizeLong() const {
          const TripLeg_TrafficSegment& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.TrafficSegment)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // uint64 segment_id = 1;
            if (this_._internal_segment_id() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
                  this_._internal_segment_id());
            }
            // float begin_percent = 2;
            if (::absl::bit_cast<::uint32_t>(this_._internal_begin_percent()) != 0) {
              total_size += 5;
            }
            // float end_percent = 3;
            if (::absl::bit_cast<::uint32_t>(this_._internal_end_percent()) != 0) {
              total_size += 5;
            }
            // bool starts_segment = 4;
            if (this_._internal_starts_segment() != 0) {
              total_size += 2;
            }
            // bool ends_segment = 5;
            if (this_._internal_ends_segment() != 0) {
              total_size += 2;
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TripLeg_TrafficSegment::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TripLeg_TrafficSegment*>(&to_msg);
  auto& from = static_cast<const TripLeg_TrafficSegment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.TrafficSegment)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_segment_id() != 0) {
    _this->_impl_.segment_id_ = from._impl_.segment_id_;
  }
  if (::absl::bit_cast<::uint32_t>(from._internal_begin_percent()) != 0) {
    _this->_impl_.begin_percent_ = from._impl_.begin_percent_;
  }
  if (::absl::bit_cast<::uint32_t>(from._internal_end_percent()) != 0) {
    _this->_impl_.end_percent_ = from._impl_.end_percent_;
  }
  if (from._internal_starts_segment() != 0) {
    _this->_impl_.starts_segment_ = from._impl_.starts_segment_;
  }
  if (from._internal_ends_segment() != 0) {
    _this->_impl_.ends_segment_ = from._impl_.ends_segment_;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_TrafficSegment::CopyFrom(const TripLeg_TrafficSegment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.TrafficSegment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TripLeg_TrafficSegment::InternalSwap(TripLeg_TrafficSegment* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.ends_segment_)
      + sizeof(TripLeg_TrafficSegment::_impl_.ends_segment_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, _impl_.segment_id_)>(
          reinterpret_cast<char*>(&_impl_.segment_id_),
          reinterpret_cast<char*>(&other->_impl_.segment_id_));
}

// ===================================================================

class TripLeg_Restriction::_Internal {
 public:
};

TripLeg_Restriction::TripLeg_Restriction(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Restriction)
}
TripLeg_Restriction::TripLeg_Restriction(
    ::google::protobuf::Arena* arena, const TripLeg_Restriction& from)
    : TripLeg_Restriction(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_Restriction::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void TripLeg_Restriction::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.type_ = {};
}
TripLeg_Restriction::~TripLeg_Restriction() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Restriction)
  SharedDtor(*this);
}
inline void TripLeg_Restriction::SharedDtor(MessageLite& self) {
  TripLeg_Restriction& this_ = static_cast<TripLeg_Restriction&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* TripLeg_Restriction::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TripLeg_Restriction(arena);
}
constexpr auto TripLeg_Restriction::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(TripLeg_Restriction),
                                            alignof(TripLeg_Restriction));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<29> TripLeg_Restriction::_class_data_ = {
    {
        &_TripLeg_Restriction_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TripLeg_Restriction::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TripLeg_Restriction>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TripLeg_Restriction::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TripLeg_Restriction>(), &TripLeg_Restriction::ByteSizeLong,
            &TripLeg_Restriction::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TripLeg_Restriction, _impl_._cached_size_),
        true,
    },
    "valhalla.TripLeg.Restriction",
};
const ::google::protobuf::internal::ClassData* TripLeg_Restriction::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> TripLeg_Restriction::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TripLeg_Restriction>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // uint32 type = 1;
    {::_pbi::TcParser::FastV32S1,
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Restriction, _impl_.type_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 type = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Restriction, _impl_.type_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void TripLeg_Restriction::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Restriction)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_ = 0u;
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TripLeg_Restriction::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TripLeg_Restriction& this_ = static_cast<const TripLeg_Restriction&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TripLeg_Restriction::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TripLeg_Restriction& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Restriction)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // uint32 type = 1;
          if (this_._internal_type() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                1, this_._internal_type(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Restriction)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TripLeg_Restriction::ByteSizeLong(const MessageLite& base) {
          const TripLeg_Restriction& this_ = static_cast<const TripLeg_Restriction&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TripLeg_Restriction::ByteSizeLong() const {
          const TripLeg_Restriction& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Restriction)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

           {
            // uint32 type = 1;
            if (this_._internal_type() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_type());
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TripLeg_Restriction::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TripLeg_Restriction*>(&to_msg);
  auto& from = static_cast<const TripLeg_Restriction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Restriction)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_type() != 0) {
    _this->_impl_.type_ = from._impl_.type_;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Restriction::CopyFrom(const TripLeg_Restriction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Restriction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TripLeg_Restriction::InternalSwap(TripLeg_Restriction* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
        swap(_impl_.type_, other->_impl_.type_);
}

// ===================================================================

class TripLeg_TimeDomain::_Internal {
 public:
};

TripLeg_TimeDomain::TripLeg_TimeDomain(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.TimeDomain)
}
TripLeg_TimeDomain::TripLeg_TimeDomain(
    ::google::protobuf::Arena* arena, const TripLeg_TimeDomain& from)
    : TripLeg_TimeDomain(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_TimeDomain::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void TripLeg_TimeDomain::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, day_dow_type_),
           0,
           offsetof(Impl_, end_week_) -
               offsetof(Impl_, day_dow_type_) +
               sizeof(Impl_::end_week_));
}
TripLeg_TimeDomain::~TripLeg_TimeDomain() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.TimeDomain)
  SharedDtor(*this);
}
inline void TripLeg_TimeDomain::SharedDtor(MessageLite& self) {
  TripLeg_TimeDomain& this_ = static_cast<TripLeg_TimeDomain&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* TripLeg_TimeDomain::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TripLeg_TimeDomain(arena);
}
constexpr auto TripLeg_TimeDomain::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(TripLeg_TimeDomain),
                                            alignof(TripLeg_TimeDomain));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<28> TripLeg_TimeDomain::_class_data_ = {
    {
        &_TripLeg_TimeDomain_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TripLeg_TimeDomain::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TripLeg_TimeDomain>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TripLeg_TimeDomain::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TripLeg_TimeDomain>(), &TripLeg_TimeDomain::ByteSizeLong,
            &TripLeg_TimeDomain::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_._cached_size_),
        true,
    },
    "valhalla.TripLeg.TimeDomain",
};
const ::google::protobuf::internal::ClassData* TripLeg_TimeDomain::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 12, 0, 0, 2> TripLeg_TimeDomain::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    12, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294963200,  // skipmap
    offsetof(decltype(_table_), field_entries),
    12,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TripLeg_TimeDomain>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .valhalla.TripLeg.TimeDomain.DayDowType day_dow_type = 1;
    {::_pbi::TcParser::FastV32S1,
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.day_dow_type_)}},
    // uint32 dow_mask = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.dow_mask_)}},
    // uint32 begin_hrs = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.begin_hrs_)}},
    // uint32 begin_mins = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.begin_mins_)}},
    // uint32 begin_month = 5;
    {::_pbi::TcParser::FastV32S1,
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.begin_month_)}},
    // uint32 begin_day_dow = 6;
    {::_pbi::TcParser::FastV32S1,
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.begin_day_dow_)}},
    // uint32 begin_week = 7;
    {::_pbi::TcParser::FastV32S1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.begin_week_)}},
    // uint32 end_hrs = 8;
    {::_pbi::TcParser::FastV32S1,
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.end_hrs_)}},
    // uint32 end_mins = 9;
    {::_pbi::TcParser::FastV32S1,
     {72, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.end_mins_)}},
    // uint32 end_month = 10;
    {::_pbi::TcParser::FastV32S1,
     {80, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.end_month_)}},
    // uint32 end_day_dow = 11;
    {::_pbi::TcParser::FastV32S1,
     {88, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.end_day_dow_)}},
    // uint32 end_week = 12;
    {::_pbi::TcParser::FastV32S1,
     {96, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.end_week_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .valhalla.TripLeg.TimeDomain.DayDowType day_dow_type = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.day_dow_type_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // uint32 dow_mask = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.dow_mask_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 begin_hrs = 3;
    {PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.begin_hrs_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 begin_mins = 4;
    {PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.begin_mins_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 begin_month = 5;
    {PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.begin_month_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 begin_day_dow = 6;
    {PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.begin_day_dow_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 begin_week = 7;
    {PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.begin_week_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 end_hrs = 8;
    {PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.end_hrs_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 end_mins = 9;
    {PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.end_mins_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 end_month = 10;
    {PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.end_month_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 end_day_dow = 11;
    {PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.end_day_dow_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 end_week = 12;
    {PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.end_week_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void TripLeg_TimeDomain::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.TimeDomain)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.day_dow_type_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.end_week_) -
      reinterpret_cast<char*>(&_impl_.day_dow_type_)) + sizeof(_impl_.end_week_));
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TripLeg_TimeDomain::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TripLeg_TimeDomain& this_ = static_cast<const TripLeg_TimeDomain&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TripLeg_TimeDomain::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TripLeg_TimeDomain& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.TimeDomain)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // .valhalla.TripLeg.TimeDomain.DayDowType day_dow_type = 1;
          if (this_._internal_day_dow_type() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                1, this_._internal_day_dow_type(), target);
          }

          // uint32 dow_mask = 2;
          if (this_._internal_dow_mask() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                2, this_._internal_dow_mask(), target);
          }

          // uint32 begin_hrs = 3;
          if (this_._internal_begin_hrs() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                3, this_._internal_begin_hrs(), target);
          }

          // uint32 begin_mins = 4;
          if (this_._internal_begin_mins() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                4, this_._internal_begin_mins(), target);
          }

          // uint32 begin_month = 5;
          if (this_._internal_begin_month() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                5, this_._internal_begin_month(), target);
          }

          // uint32 begin_day_dow = 6;
          if (this_._internal_begin_day_dow() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                6, this_._internal_begin_day_dow(), target);
          }

          // uint32 begin_week = 7;
          if (this_._internal_begin_week() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                7, this_._internal_begin_week(), target);
          }

          // uint32 end_hrs = 8;
          if (this_._internal_end_hrs() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                8, this_._internal_end_hrs(), target);
          }

          // uint32 end_mins = 9;
          if (this_._internal_end_mins() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                9, this_._internal_end_mins(), target);
          }

          // uint32 end_month = 10;
          if (this_._internal_end_month() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                10, this_._internal_end_month(), target);
          }

          // uint32 end_day_dow = 11;
          if (this_._internal_end_day_dow() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                11, this_._internal_end_day_dow(), target);
          }

          // uint32 end_week = 12;
          if (this_._internal_end_week() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                12, this_._internal_end_week(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.TimeDomain)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TripLeg_TimeDomain::ByteSizeLong(const MessageLite& base) {
          const TripLeg_TimeDomain& this_ = static_cast<const TripLeg_TimeDomain&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TripLeg_TimeDomain::ByteSizeLong() const {
          const TripLeg_TimeDomain& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.TimeDomain)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // .valhalla.TripLeg.TimeDomain.DayDowType day_dow_type = 1;
            if (this_._internal_day_dow_type() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_day_dow_type());
            }
            // uint32 dow_mask = 2;
            if (this_._internal_dow_mask() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_dow_mask());
            }
            // uint32 begin_hrs = 3;
            if (this_._internal_begin_hrs() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_begin_hrs());
            }
            // uint32 begin_mins = 4;
            if (this_._internal_begin_mins() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_begin_mins());
            }
            // uint32 begin_month = 5;
            if (this_._internal_begin_month() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_begin_month());
            }
            // uint32 begin_day_dow = 6;
            if (this_._internal_begin_day_dow() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_begin_day_dow());
            }
            // uint32 begin_week = 7;
            if (this_._internal_begin_week() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_begin_week());
            }
            // uint32 end_hrs = 8;
            if (this_._internal_end_hrs() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_end_hrs());
            }
            // uint32 end_mins = 9;
            if (this_._internal_end_mins() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_end_mins());
            }
            // uint32 end_month = 10;
            if (this_._internal_end_month() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_end_month());
            }
            // uint32 end_day_dow = 11;
            if (this_._internal_end_day_dow() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_end_day_dow());
            }
            // uint32 end_week = 12;
            if (this_._internal_end_week() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_end_week());
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TripLeg_TimeDomain::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TripLeg_TimeDomain*>(&to_msg);
  auto& from = static_cast<const TripLeg_TimeDomain&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.TimeDomain)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_day_dow_type() != 0) {
    _this->_impl_.day_dow_type_ = from._impl_.day_dow_type_;
  }
  if (from._internal_dow_mask() != 0) {
    _this->_impl_.dow_mask_ = from._impl_.dow_mask_;
  }
  if (from._internal_begin_hrs() != 0) {
    _this->_impl_.begin_hrs_ = from._impl_.begin_hrs_;
  }
  if (from._internal_begin_mins() != 0) {
    _this->_impl_.begin_mins_ = from._impl_.begin_mins_;
  }
  if (from._internal_begin_month() != 0) {
    _this->_impl_.begin_month_ = from._impl_.begin_month_;
  }
  if (from._internal_begin_day_dow() != 0) {
    _this->_impl_.begin_day_dow_ = from._impl_.begin_day_dow_;
  }
  if (from._internal_begin_week() != 0) {
    _this->_impl_.begin_week_ = from._impl_.begin_week_;
  }
  if (from._internal_end_hrs() != 0) {
    _this->_impl_.end_hrs_ = from._impl_.end_hrs_;
  }
  if (from._internal_end_mins() != 0) {
    _this->_impl_.end_mins_ = from._impl_.end_mins_;
  }
  if (from._internal_end_month() != 0) {
    _this->_impl_.end_month_ = from._impl_.end_month_;
  }
  if (from._internal_end_day_dow() != 0) {
    _this->_impl_.end_day_dow_ = from._impl_.end_day_dow_;
  }
  if (from._internal_end_week() != 0) {
    _this->_impl_.end_week_ = from._impl_.end_week_;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_TimeDomain::CopyFrom(const TripLeg_TimeDomain& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.TimeDomain)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TripLeg_TimeDomain::InternalSwap(TripLeg_TimeDomain* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.end_week_)
      + sizeof(TripLeg_TimeDomain::_impl_.end_week_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_TimeDomain, _impl_.day_dow_type_)>(
          reinterpret_cast<char*>(&_impl_.day_dow_type_),
          reinterpret_cast<char*>(&other->_impl_.day_dow_type_));
}

// ===================================================================

class TripLeg_ConditionalSpeedLimit::_Internal {
 public:
  using HasBits =
      decltype(std::declval<TripLeg_ConditionalSpeedLimit>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(TripLeg_ConditionalSpeedLimit, _impl_._has_bits_);
};

TripLeg_ConditionalSpeedLimit::TripLeg_ConditionalSpeedLimit(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.ConditionalSpeedLimit)
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_ConditionalSpeedLimit::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::TripLeg_ConditionalSpeedLimit& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

TripLeg_ConditionalSpeedLimit::TripLeg_ConditionalSpeedLimit(
    ::google::protobuf::Arena* arena,
    const TripLeg_ConditionalSpeedLimit& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TripLeg_ConditionalSpeedLimit* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.condition_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TripLeg_TimeDomain>(
                              arena, *from._impl_.condition_)
                        : nullptr;
  _impl_.speed_limit_ = from._impl_.speed_limit_;

  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.ConditionalSpeedLimit)
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_ConditionalSpeedLimit::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void TripLeg_ConditionalSpeedLimit::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, condition_),
           0,
           offsetof(Impl_, speed_limit_) -
               offsetof(Impl_, condition_) +
               sizeof(Impl_::speed_limit_));
}
TripLeg_ConditionalSpeedLimit::~TripLeg_ConditionalSpeedLimit() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.ConditionalSpeedLimit)
  SharedDtor(*this);
}
inline void TripLeg_ConditionalSpeedLimit::SharedDtor(MessageLite& self) {
  TripLeg_ConditionalSpeedLimit& this_ = static_cast<TripLeg_ConditionalSpeedLimit&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.condition_;
  this_._impl_.~Impl_();
}

inline void* TripLeg_ConditionalSpeedLimit::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TripLeg_ConditionalSpeedLimit(arena);
}
constexpr auto TripLeg_ConditionalSpeedLimit::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(TripLeg_ConditionalSpeedLimit),
                                            alignof(TripLeg_ConditionalSpeedLimit));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<39> TripLeg_ConditionalSpeedLimit::_class_data_ = {
    {
        &_TripLeg_ConditionalSpeedLimit_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TripLeg_ConditionalSpeedLimit::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TripLeg_ConditionalSpeedLimit>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TripLeg_ConditionalSpeedLimit::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TripLeg_ConditionalSpeedLimit>(), &TripLeg_ConditionalSpeedLimit::ByteSizeLong,
            &TripLeg_ConditionalSpeedLimit::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TripLeg_ConditionalSpeedLimit, _impl_._cached_size_),
        true,
    },
    "valhalla.TripLeg.ConditionalSpeedLimit",
};
const ::google::protobuf::internal::ClassData* TripLeg_ConditionalSpeedLimit::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2> TripLeg_ConditionalSpeedLimit::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TripLeg_ConditionalSpeedLimit, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TripLeg_ConditionalSpeedLimit>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .valhalla.TripLeg.TimeDomain condition = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(TripLeg_ConditionalSpeedLimit, _impl_.condition_)}},
    // uint32 speed_limit = 1;
    {::_pbi::TcParser::FastV32S1,
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_ConditionalSpeedLimit, _impl_.speed_limit_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 speed_limit = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_ConditionalSpeedLimit, _impl_.speed_limit_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // .valhalla.TripLeg.TimeDomain condition = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg_ConditionalSpeedLimit, _impl_.condition_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_TimeDomain>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void TripLeg_ConditionalSpeedLimit::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.ConditionalSpeedLimit)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.condition_ != nullptr);
    _impl_.condition_->Clear();
  }
  _impl_.speed_limit_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TripLeg_ConditionalSpeedLimit::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TripLeg_ConditionalSpeedLimit& this_ = static_cast<const TripLeg_ConditionalSpeedLimit&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TripLeg_ConditionalSpeedLimit::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TripLeg_ConditionalSpeedLimit& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.ConditionalSpeedLimit)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // uint32 speed_limit = 1;
          if (this_._internal_speed_limit() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                1, this_._internal_speed_limit(), target);
          }

          cached_has_bits = this_._impl_._has_bits_[0];
          // .valhalla.TripLeg.TimeDomain condition = 2;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                2, *this_._impl_.condition_, this_._impl_.condition_->GetCachedSize(), target,
                stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.ConditionalSpeedLimit)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TripLeg_ConditionalSpeedLimit::ByteSizeLong(const MessageLite& base) {
          const TripLeg_ConditionalSpeedLimit& this_ = static_cast<const TripLeg_ConditionalSpeedLimit&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TripLeg_ConditionalSpeedLimit::ByteSizeLong() const {
          const TripLeg_ConditionalSpeedLimit& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.ConditionalSpeedLimit)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // .valhalla.TripLeg.TimeDomain condition = 2;
            cached_has_bits = this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.condition_);
            }
          }
           {
            // uint32 speed_limit = 1;
            if (this_._internal_speed_limit() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_speed_limit());
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TripLeg_ConditionalSpeedLimit::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TripLeg_ConditionalSpeedLimit*>(&to_msg);
  auto& from = static_cast<const TripLeg_ConditionalSpeedLimit&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.ConditionalSpeedLimit)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(from._impl_.condition_ != nullptr);
    if (_this->_impl_.condition_ == nullptr) {
      _this->_impl_.condition_ =
          ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TripLeg_TimeDomain>(arena, *from._impl_.condition_);
    } else {
      _this->_impl_.condition_->MergeFrom(*from._impl_.condition_);
    }
  }
  if (from._internal_speed_limit() != 0) {
    _this->_impl_.speed_limit_ = from._impl_.speed_limit_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_ConditionalSpeedLimit::CopyFrom(const TripLeg_ConditionalSpeedLimit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.ConditionalSpeedLimit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TripLeg_ConditionalSpeedLimit::InternalSwap(TripLeg_ConditionalSpeedLimit* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_ConditionalSpeedLimit, _impl_.speed_limit_)
      + sizeof(TripLeg_ConditionalSpeedLimit::_impl_.speed_limit_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_ConditionalSpeedLimit, _impl_.condition_)>(
          reinterpret_cast<char*>(&_impl_.condition_),
          reinterpret_cast<char*>(&other->_impl_.condition_));
}

// ===================================================================

class TripLeg_Edge_Level::_Internal {
 public:
};

TripLeg_Edge_Level::TripLeg_Edge_Level(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Edge.Level)
}
TripLeg_Edge_Level::TripLeg_Edge_Level(
    ::google::protobuf::Arena* arena, const TripLeg_Edge_Level& from)
    : TripLeg_Edge_Level(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_Edge_Level::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void TripLeg_Edge_Level::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, start_),
           0,
           offsetof(Impl_, end_) -
               offsetof(Impl_, start_) +
               sizeof(Impl_::end_));
}
TripLeg_Edge_Level::~TripLeg_Edge_Level() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Edge.Level)
  SharedDtor(*this);
}
inline void TripLeg_Edge_Level::SharedDtor(MessageLite& self) {
  TripLeg_Edge_Level& this_ = static_cast<TripLeg_Edge_Level&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* TripLeg_Edge_Level::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TripLeg_Edge_Level(arena);
}
constexpr auto TripLeg_Edge_Level::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(TripLeg_Edge_Level),
                                            alignof(TripLeg_Edge_Level));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<28> TripLeg_Edge_Level::_class_data_ = {
    {
        &_TripLeg_Edge_Level_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TripLeg_Edge_Level::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TripLeg_Edge_Level>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TripLeg_Edge_Level::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TripLeg_Edge_Level>(), &TripLeg_Edge_Level::ByteSizeLong,
            &TripLeg_Edge_Level::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TripLeg_Edge_Level, _impl_._cached_size_),
        true,
    },
    "valhalla.TripLeg.Edge.Level",
};
const ::google::protobuf::internal::ClassData* TripLeg_Edge_Level::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> TripLeg_Edge_Level::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TripLeg_Edge_Level>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // float end = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge_Level, _impl_.end_)}},
    // float start = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge_Level, _impl_.start_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float start = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge_Level, _impl_.start_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float end = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge_Level, _impl_.end_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void TripLeg_Edge_Level::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Edge.Level)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.start_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.end_) -
      reinterpret_cast<char*>(&_impl_.start_)) + sizeof(_impl_.end_));
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TripLeg_Edge_Level::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TripLeg_Edge_Level& this_ = static_cast<const TripLeg_Edge_Level&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TripLeg_Edge_Level::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TripLeg_Edge_Level& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Edge.Level)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // float start = 1;
          if (::absl::bit_cast<::uint32_t>(this_._internal_start()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                1, this_._internal_start(), target);
          }

          // float end = 2;
          if (::absl::bit_cast<::uint32_t>(this_._internal_end()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                2, this_._internal_end(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Edge.Level)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TripLeg_Edge_Level::ByteSizeLong(const MessageLite& base) {
          const TripLeg_Edge_Level& this_ = static_cast<const TripLeg_Edge_Level&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TripLeg_Edge_Level::ByteSizeLong() const {
          const TripLeg_Edge_Level& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Edge.Level)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // float start = 1;
            if (::absl::bit_cast<::uint32_t>(this_._internal_start()) != 0) {
              total_size += 5;
            }
            // float end = 2;
            if (::absl::bit_cast<::uint32_t>(this_._internal_end()) != 0) {
              total_size += 5;
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TripLeg_Edge_Level::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TripLeg_Edge_Level*>(&to_msg);
  auto& from = static_cast<const TripLeg_Edge_Level&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Edge.Level)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (::absl::bit_cast<::uint32_t>(from._internal_start()) != 0) {
    _this->_impl_.start_ = from._impl_.start_;
  }
  if (::absl::bit_cast<::uint32_t>(from._internal_end()) != 0) {
    _this->_impl_.end_ = from._impl_.end_;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Edge_Level::CopyFrom(const TripLeg_Edge_Level& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Edge.Level)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TripLeg_Edge_Level::InternalSwap(TripLeg_Edge_Level* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Edge_Level, _impl_.end_)
      + sizeof(TripLeg_Edge_Level::_impl_.end_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Edge_Level, _impl_.start_)>(
          reinterpret_cast<char*>(&_impl_.start_),
          reinterpret_cast<char*>(&other->_impl_.start_));
}

// ===================================================================

class TripLeg_Edge::_Internal {
 public:
  using HasBits =
      decltype(std::declval<TripLeg_Edge>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_._has_bits_);
};

void TripLeg_Edge::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Clear();
}
void TripLeg_Edge::clear_sign() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sign_ != nullptr) _impl_.sign_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TripLeg_Edge::clear_transit_route_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.transit_route_info_ != nullptr) _impl_.transit_route_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void TripLeg_Edge::clear_turn_lanes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.turn_lanes_.Clear();
}
void TripLeg_Edge::clear_tagged_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tagged_value_.Clear();
}
void TripLeg_Edge::clear_landmarks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.landmarks_.Clear();
}
void TripLeg_Edge::clear_tunnel_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tunnel_name_.Clear();
}
TripLeg_Edge::TripLeg_Edge(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Edge)
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_Edge::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::TripLeg_Edge& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        name_{visibility, arena, from.name_},
        lane_connectivity_{visibility, arena, from.lane_connectivity_},
        traffic_segment_{visibility, arena, from.traffic_segment_},
        turn_lanes_{visibility, arena, from.turn_lanes_},
        tagged_value_{visibility, arena, from.tagged_value_},
        landmarks_{visibility, arena, from.landmarks_},
        tunnel_name_{visibility, arena, from.tunnel_name_},
        elevation_{visibility, arena, from.elevation_},
        conditional_speed_limits_{visibility, arena, from.conditional_speed_limits_},
        levels_{visibility, arena, from.levels_} {}

TripLeg_Edge::TripLeg_Edge(
    ::google::protobuf::Arena* arena,
    const TripLeg_Edge& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TripLeg_Edge* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.sign_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TripSign>(
                              arena, *from._impl_.sign_)
                        : nullptr;
  _impl_.transit_route_info_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TransitRouteInfo>(
                              arena, *from._impl_.transit_route_info_)
                        : nullptr;
  _impl_.restriction_ = (cached_has_bits & 0x00000004u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TripLeg_Restriction>(
                              arena, *from._impl_.restriction_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, length_km_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, length_km_),
           offsetof(Impl_, level_precision_) -
               offsetof(Impl_, length_km_) +
               sizeof(Impl_::level_precision_));

  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Edge)
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_Edge::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        name_{visibility, arena},
        lane_connectivity_{visibility, arena},
        traffic_segment_{visibility, arena},
        turn_lanes_{visibility, arena},
        tagged_value_{visibility, arena},
        landmarks_{visibility, arena},
        tunnel_name_{visibility, arena},
        elevation_{visibility, arena},
        conditional_speed_limits_{visibility, arena},
        levels_{visibility, arena} {}

inline void TripLeg_Edge::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, sign_),
           0,
           offsetof(Impl_, level_precision_) -
               offsetof(Impl_, sign_) +
               sizeof(Impl_::level_precision_));
}
TripLeg_Edge::~TripLeg_Edge() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Edge)
  SharedDtor(*this);
}
inline void TripLeg_Edge::SharedDtor(MessageLite& self) {
  TripLeg_Edge& this_ = static_cast<TripLeg_Edge&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.sign_;
  delete this_._impl_.transit_route_info_;
  delete this_._impl_.restriction_;
  this_._impl_.~Impl_();
}

inline void* TripLeg_Edge::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TripLeg_Edge(arena);
}
constexpr auto TripLeg_Edge::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.name_) +
          decltype(TripLeg_Edge::_impl_.name_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.lane_connectivity_) +
          decltype(TripLeg_Edge::_impl_.lane_connectivity_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.traffic_segment_) +
          decltype(TripLeg_Edge::_impl_.traffic_segment_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.turn_lanes_) +
          decltype(TripLeg_Edge::_impl_.turn_lanes_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.tagged_value_) +
          decltype(TripLeg_Edge::_impl_.tagged_value_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.landmarks_) +
          decltype(TripLeg_Edge::_impl_.landmarks_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.tunnel_name_) +
          decltype(TripLeg_Edge::_impl_.tunnel_name_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.elevation_) +
          decltype(TripLeg_Edge::_impl_.elevation_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.conditional_speed_limits_) +
          decltype(TripLeg_Edge::_impl_.conditional_speed_limits_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.levels_) +
          decltype(TripLeg_Edge::_impl_.levels_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(TripLeg_Edge), alignof(TripLeg_Edge), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&TripLeg_Edge::PlacementNew_,
                                 sizeof(TripLeg_Edge),
                                 alignof(TripLeg_Edge));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<22> TripLeg_Edge::_class_data_ = {
    {
        &_TripLeg_Edge_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TripLeg_Edge::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TripLeg_Edge>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TripLeg_Edge::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TripLeg_Edge>(), &TripLeg_Edge::ByteSizeLong,
            &TripLeg_Edge::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_._cached_size_),
        true,
    },
    "valhalla.TripLeg.Edge",
};
const ::google::protobuf::internal::ClassData* TripLeg_Edge::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 62, 12, 0, 9> TripLeg_Edge::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_._has_bits_),
    0, // no _extensions_
    62, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    0,  // skipmap
    offsetof(decltype(_table_), field_entries),
    62,  // num_field_entries
    12,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TripLeg_Edge>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .valhalla.StreetName name = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.name_)}},
    // float length_km = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.length_km_)}},
    // float speed = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.speed_)}},
    // .valhalla.RoadClass road_class = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.road_class_)}},
    // uint32 begin_heading = 5;
    {::_pbi::TcParser::FastV32S1,
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.begin_heading_)}},
    // uint32 end_heading = 6;
    {::_pbi::TcParser::FastV32S1,
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.end_heading_)}},
    // uint32 begin_shape_index = 7;
    {::_pbi::TcParser::FastV32S1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.begin_shape_index_)}},
    // uint32 end_shape_index = 8;
    {::_pbi::TcParser::FastV32S1,
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.end_shape_index_)}},
    // .valhalla.TripLeg.Traversability traversability = 9;
    {::_pbi::TcParser::FastV32S1,
     {72, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.traversability_)}},
    // .valhalla.TripLeg.Use use = 10;
    {::_pbi::TcParser::FastV32S1,
     {80, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.use_)}},
    // bool toll = 11;
    {::_pbi::TcParser::FastV8S1,
     {88, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.toll_)}},
    // bool unpaved = 12;
    {::_pbi::TcParser::FastV8S1,
     {96, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.unpaved_)}},
    // bool tunnel = 13;
    {::_pbi::TcParser::FastV8S1,
     {104, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.tunnel_)}},
    // bool bridge = 14;
    {::_pbi::TcParser::FastV8S1,
     {112, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.bridge_)}},
    // bool roundabout = 15;
    {::_pbi::TcParser::FastV8S1,
     {120, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.roundabout_)}},
    // bool internal_intersection = 16;
    {::_pbi::TcParser::FastV8S2,
     {384, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.internal_intersection_)}},
    // bool drive_on_left = 17;
    {::_pbi::TcParser::FastV8S2,
     {392, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.drive_on_left_)}},
    // .valhalla.TripLeg.Surface surface = 18;
    {::_pbi::TcParser::FastV32S2,
     {400, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.surface_)}},
    // .valhalla.TripSign sign = 19;
    {::_pbi::TcParser::FastMtS2,
     {410, 0, 1, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.sign_)}},
    // .valhalla.TravelMode travel_mode = 20;
    {::_pbi::TcParser::FastV32S2,
     {416, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.travel_mode_)}},
    // .valhalla.VehicleType vehicle_type = 21;
    {::_pbi::TcParser::FastV32S2,
     {424, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.vehicle_type_)}},
    // .valhalla.PedestrianType pedestrian_type = 22;
    {::_pbi::TcParser::FastV32S2,
     {432, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.pedestrian_type_)}},
    // .valhalla.BicycleType bicycle_type = 23;
    {::_pbi::TcParser::FastV32S2,
     {440, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.bicycle_type_)}},
    // .valhalla.TransitType transit_type = 24;
    {::_pbi::TcParser::FastV32S2,
     {448, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.transit_type_)}},
    // .valhalla.TransitRouteInfo transit_route_info = 25;
    {::_pbi::TcParser::FastMtS2,
     {458, 1, 2, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.transit_route_info_)}},
    // uint64 id = 26;
    {::_pbi::TcParser::FastV64S2,
     {464, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.id_)}},
    // uint64 way_id = 27;
    {::_pbi::TcParser::FastV64S2,
     {472, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.way_id_)}},
    // float weighted_grade = 28;
    {::_pbi::TcParser::FastF32S2,
     {485, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.weighted_grade_)}},
    // int32 max_upward_grade = 29;
    {::_pbi::TcParser::FastV32S2,
     {488, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.max_upward_grade_)}},
    // int32 max_downward_grade = 30;
    {::_pbi::TcParser::FastV32S2,
     {496, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.max_downward_grade_)}},
    // uint32 lane_count = 31;
    {::_pbi::TcParser::FastV32S2,
     {504, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.lane_count_)}},
  }}, {{
    33, 0, 2,
    0, 32, 49152, 48,
    65535, 65535
  }}, {{
    // repeated .valhalla.StreetName name = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.name_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // float length_km = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.length_km_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float speed = 3;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.speed_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // .valhalla.RoadClass road_class = 4;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.road_class_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // uint32 begin_heading = 5;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.begin_heading_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 end_heading = 6;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.end_heading_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 begin_shape_index = 7;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.begin_shape_index_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 end_shape_index = 8;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.end_shape_index_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // .valhalla.TripLeg.Traversability traversability = 9;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.traversability_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.TripLeg.Use use = 10;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.use_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // bool toll = 11;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.toll_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool unpaved = 12;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.unpaved_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool tunnel = 13;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.tunnel_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool bridge = 14;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.bridge_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool roundabout = 15;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.roundabout_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool internal_intersection = 16;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.internal_intersection_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool drive_on_left = 17;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.drive_on_left_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // .valhalla.TripLeg.Surface surface = 18;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.surface_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.TripSign sign = 19;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.sign_), _Internal::kHasBitsOffset + 0, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .valhalla.TravelMode travel_mode = 20;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.travel_mode_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.VehicleType vehicle_type = 21;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.vehicle_type_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.PedestrianType pedestrian_type = 22;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.pedestrian_type_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.BicycleType bicycle_type = 23;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.bicycle_type_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.TransitType transit_type = 24;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.transit_type_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.TransitRouteInfo transit_route_info = 25;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.transit_route_info_), _Internal::kHasBitsOffset + 1, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // uint64 id = 26;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
    // uint64 way_id = 27;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.way_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
    // float weighted_grade = 28;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.weighted_grade_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // int32 max_upward_grade = 29;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.max_upward_grade_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // int32 max_downward_grade = 30;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.max_downward_grade_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // uint32 lane_count = 31;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.lane_count_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // .valhalla.TripLeg.CycleLane cycle_lane = 32;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.cycle_lane_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // bool bicycle_network = 33;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.bicycle_network_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // .valhalla.TripLeg.Sidewalk sidewalk = 34;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.sidewalk_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // uint32 density = 35;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.density_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 speed_limit = 36;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.speed_limit_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // float truck_speed = 37;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.truck_speed_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // bool truck_route = 38;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.truck_route_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.lane_connectivity_), -1, 3,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // int32 mean_elevation = 40;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.mean_elevation_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.traffic_segment_), -1, 4,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .valhalla.TurnLane turn_lanes = 42;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.turn_lanes_), -1, 5,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // bool has_time_restrictions = 43;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.has_time_restrictions_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // float default_speed = 44;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.default_speed_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // .valhalla.TripLeg.Restriction restriction = 45;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.restriction_), _Internal::kHasBitsOffset + 2, 6,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // bool destination_only = 46;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.destination_only_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool is_urban = 47;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.is_urban_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // repeated .valhalla.TaggedValue tagged_value = 48;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.tagged_value_), -1, 7,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // float source_along_edge = 49;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.source_along_edge_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float target_along_edge = 50;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.target_along_edge_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // .valhalla.TripLeg.SacScale sac_scale = 51;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.sac_scale_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // bool shoulder = 52;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.shoulder_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool indoor = 53;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.indoor_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // repeated .valhalla.RouteLandmark landmarks = 54;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.landmarks_), -1, 8,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .valhalla.StreetName tunnel_name = 55;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.tunnel_name_), -1, 9,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // float elevation_sampling_interval = 56;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.elevation_sampling_interval_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // repeated float elevation = 57;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.elevation_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFloat)},
    // bool country_crossing = 58;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.country_crossing_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool forward = 59;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.forward_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // repeated .valhalla.TripLeg.ConditionalSpeedLimit conditional_speed_limits = 60;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.conditional_speed_limits_), -1, 10,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .valhalla.TripLeg.Edge.Level levels = 61;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.levels_), -1, 11,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // uint32 level_precision = 62;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.level_precision_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::StreetName>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripSign>()},
    {::_pbi::TcParser::GetTable<::valhalla::TransitRouteInfo>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_LaneConnectivity>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_TrafficSegment>()},
    {::_pbi::TcParser::GetTable<::valhalla::TurnLane>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_Restriction>()},
    {::_pbi::TcParser::GetTable<::valhalla::TaggedValue>()},
    {::_pbi::TcParser::GetTable<::valhalla::RouteLandmark>()},
    {::_pbi::TcParser::GetTable<::valhalla::StreetName>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_ConditionalSpeedLimit>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_Edge_Level>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void TripLeg_Edge::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Edge)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.Clear();
  _impl_.lane_connectivity_.Clear();
  _impl_.traffic_segment_.Clear();
  _impl_.turn_lanes_.Clear();
  _impl_.tagged_value_.Clear();
  _impl_.landmarks_.Clear();
  _impl_.tunnel_name_.Clear();
  _impl_.elevation_.Clear();
  _impl_.conditional_speed_limits_.Clear();
  _impl_.levels_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.sign_ != nullptr);
      _impl_.sign_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.transit_route_info_ != nullptr);
      _impl_.transit_route_info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.restriction_ != nullptr);
      _impl_.restriction_->Clear();
    }
  }
  ::memset(&_impl_.length_km_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.level_precision_) -
      reinterpret_cast<char*>(&_impl_.length_km_)) + sizeof(_impl_.level_precision_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TripLeg_Edge::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TripLeg_Edge& this_ = static_cast<const TripLeg_Edge&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TripLeg_Edge::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TripLeg_Edge& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Edge)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // repeated .valhalla.StreetName name = 1;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_name_size());
               i < n; i++) {
            const auto& repfield = this_._internal_name().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    1, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // float length_km = 2;
          if (::absl::bit_cast<::uint32_t>(this_._internal_length_km()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                2, this_._internal_length_km(), target);
          }

          // float speed = 3;
          if (::absl::bit_cast<::uint32_t>(this_._internal_speed()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                3, this_._internal_speed(), target);
          }

          // .valhalla.RoadClass road_class = 4;
          if (this_._internal_road_class() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                4, this_._internal_road_class(), target);
          }

          // uint32 begin_heading = 5;
          if (this_._internal_begin_heading() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                5, this_._internal_begin_heading(), target);
          }

          // uint32 end_heading = 6;
          if (this_._internal_end_heading() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                6, this_._internal_end_heading(), target);
          }

          // uint32 begin_shape_index = 7;
          if (this_._internal_begin_shape_index() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                7, this_._internal_begin_shape_index(), target);
          }

          // uint32 end_shape_index = 8;
          if (this_._internal_end_shape_index() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                8, this_._internal_end_shape_index(), target);
          }

          // .valhalla.TripLeg.Traversability traversability = 9;
          if (this_._internal_traversability() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                9, this_._internal_traversability(), target);
          }

          // .valhalla.TripLeg.Use use = 10;
          if (this_._internal_use() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                10, this_._internal_use(), target);
          }

          // bool toll = 11;
          if (this_._internal_toll() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                11, this_._internal_toll(), target);
          }

          // bool unpaved = 12;
          if (this_._internal_unpaved() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                12, this_._internal_unpaved(), target);
          }

          // bool tunnel = 13;
          if (this_._internal_tunnel() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                13, this_._internal_tunnel(), target);
          }

          // bool bridge = 14;
          if (this_._internal_bridge() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                14, this_._internal_bridge(), target);
          }

          // bool roundabout = 15;
          if (this_._internal_roundabout() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                15, this_._internal_roundabout(), target);
          }

          // bool internal_intersection = 16;
          if (this_._internal_internal_intersection() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                16, this_._internal_internal_intersection(), target);
          }

          // bool drive_on_left = 17;
          if (this_._internal_drive_on_left() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                17, this_._internal_drive_on_left(), target);
          }

          // .valhalla.TripLeg.Surface surface = 18;
          if (this_._internal_surface() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                18, this_._internal_surface(), target);
          }

          cached_has_bits = this_._impl_._has_bits_[0];
          // .valhalla.TripSign sign = 19;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                19, *this_._impl_.sign_, this_._impl_.sign_->GetCachedSize(), target,
                stream);
          }

          // .valhalla.TravelMode travel_mode = 20;
          if (this_._internal_travel_mode() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                20, this_._internal_travel_mode(), target);
          }

          // .valhalla.VehicleType vehicle_type = 21;
          if (this_._internal_vehicle_type() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                21, this_._internal_vehicle_type(), target);
          }

          // .valhalla.PedestrianType pedestrian_type = 22;
          if (this_._internal_pedestrian_type() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                22, this_._internal_pedestrian_type(), target);
          }

          // .valhalla.BicycleType bicycle_type = 23;
          if (this_._internal_bicycle_type() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                23, this_._internal_bicycle_type(), target);
          }

          // .valhalla.TransitType transit_type = 24;
          if (this_._internal_transit_type() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                24, this_._internal_transit_type(), target);
          }

          // .valhalla.TransitRouteInfo transit_route_info = 25;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                25, *this_._impl_.transit_route_info_, this_._impl_.transit_route_info_->GetCachedSize(), target,
                stream);
          }

          // uint64 id = 26;
          if (this_._internal_id() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
                26, this_._internal_id(), target);
          }

          // uint64 way_id = 27;
          if (this_._internal_way_id() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
                27, this_._internal_way_id(), target);
          }

          // float weighted_grade = 28;
          if (::absl::bit_cast<::uint32_t>(this_._internal_weighted_grade()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                28, this_._internal_weighted_grade(), target);
          }

          // int32 max_upward_grade = 29;
          if (this_._internal_max_upward_grade() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteInt32ToArray(
                29, this_._internal_max_upward_grade(), target);
          }

          // int32 max_downward_grade = 30;
          if (this_._internal_max_downward_grade() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteInt32ToArray(
                30, this_._internal_max_downward_grade(), target);
          }

          // uint32 lane_count = 31;
          if (this_._internal_lane_count() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                31, this_._internal_lane_count(), target);
          }

          // .valhalla.TripLeg.CycleLane cycle_lane = 32;
          if (this_._internal_cycle_lane() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                32, this_._internal_cycle_lane(), target);
          }

          // bool bicycle_network = 33;
          if (this_._internal_bicycle_network() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                33, this_._internal_bicycle_network(), target);
          }

          // .valhalla.TripLeg.Sidewalk sidewalk = 34;
          if (this_._internal_sidewalk() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                34, this_._internal_sidewalk(), target);
          }

          // uint32 density = 35;
          if (this_._internal_density() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                35, this_._internal_density(), target);
          }

          // uint32 speed_limit = 36;
          if (this_._internal_speed_limit() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                36, this_._internal_speed_limit(), target);
          }

          // float truck_speed = 37;
          if (::absl::bit_cast<::uint32_t>(this_._internal_truck_speed()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                37, this_._internal_truck_speed(), target);
          }

          // bool truck_route = 38;
          if (this_._internal_truck_route() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                38, this_._internal_truck_route(), target);
          }

          // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_lane_connectivity_size());
               i < n; i++) {
            const auto& repfield = this_._internal_lane_connectivity().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    39, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // int32 mean_elevation = 40;
          if (this_._internal_mean_elevation() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteInt32ToArray(
                40, this_._internal_mean_elevation(), target);
          }

          // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_traffic_segment_size());
               i < n; i++) {
            const auto& repfield = this_._internal_traffic_segment().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    41, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .valhalla.TurnLane turn_lanes = 42;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_turn_lanes_size());
               i < n; i++) {
            const auto& repfield = this_._internal_turn_lanes().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    42, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // bool has_time_restrictions = 43;
          if (this_._internal_has_time_restrictions() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                43, this_._internal_has_time_restrictions(), target);
          }

          // float default_speed = 44;
          if (::absl::bit_cast<::uint32_t>(this_._internal_default_speed()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                44, this_._internal_default_speed(), target);
          }

          // .valhalla.TripLeg.Restriction restriction = 45;
          if (cached_has_bits & 0x00000004u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                45, *this_._impl_.restriction_, this_._impl_.restriction_->GetCachedSize(), target,
                stream);
          }

          // bool destination_only = 46;
          if (this_._internal_destination_only() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                46, this_._internal_destination_only(), target);
          }

          // bool is_urban = 47;
          if (this_._internal_is_urban() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                47, this_._internal_is_urban(), target);
          }

          // repeated .valhalla.TaggedValue tagged_value = 48;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_tagged_value_size());
               i < n; i++) {
            const auto& repfield = this_._internal_tagged_value().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    48, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // float source_along_edge = 49;
          if (::absl::bit_cast<::uint32_t>(this_._internal_source_along_edge()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                49, this_._internal_source_along_edge(), target);
          }

          // float target_along_edge = 50;
          if (::absl::bit_cast<::uint32_t>(this_._internal_target_along_edge()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                50, this_._internal_target_along_edge(), target);
          }

          // .valhalla.TripLeg.SacScale sac_scale = 51;
          if (this_._internal_sac_scale() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                51, this_._internal_sac_scale(), target);
          }

          // bool shoulder = 52;
          if (this_._internal_shoulder() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                52, this_._internal_shoulder(), target);
          }

          // bool indoor = 53;
          if (this_._internal_indoor() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                53, this_._internal_indoor(), target);
          }

          // repeated .valhalla.RouteLandmark landmarks = 54;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_landmarks_size());
               i < n; i++) {
            const auto& repfield = this_._internal_landmarks().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    54, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .valhalla.StreetName tunnel_name = 55;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_tunnel_name_size());
               i < n; i++) {
            const auto& repfield = this_._internal_tunnel_name().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    55, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // float elevation_sampling_interval = 56;
          if (::absl::bit_cast<::uint32_t>(this_._internal_elevation_sampling_interval()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                56, this_._internal_elevation_sampling_interval(), target);
          }

          // repeated float elevation = 57;
          if (this_._internal_elevation_size() > 0) {
            target = stream->WriteFixedPacked(57, this_._internal_elevation(), target);
          }

          // bool country_crossing = 58;
          if (this_._internal_country_crossing() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                58, this_._internal_country_crossing(), target);
          }

          // bool forward = 59;
          if (this_._internal_forward() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                59, this_._internal_forward(), target);
          }

          // repeated .valhalla.TripLeg.ConditionalSpeedLimit conditional_speed_limits = 60;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_conditional_speed_limits_size());
               i < n; i++) {
            const auto& repfield = this_._internal_conditional_speed_limits().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    60, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .valhalla.TripLeg.Edge.Level levels = 61;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_levels_size());
               i < n; i++) {
            const auto& repfield = this_._internal_levels().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    61, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // uint32 level_precision = 62;
          if (this_._internal_level_precision() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                62, this_._internal_level_precision(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Edge)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TripLeg_Edge::ByteSizeLong(const MessageLite& base) {
          const TripLeg_Edge& this_ = static_cast<const TripLeg_Edge&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TripLeg_Edge::ByteSizeLong() const {
          const TripLeg_Edge& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Edge)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .valhalla.StreetName name = 1;
            {
              total_size += 1UL * this_._internal_name_size();
              for (const auto& msg : this_._internal_name()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
            {
              total_size += 2UL * this_._internal_lane_connectivity_size();
              for (const auto& msg : this_._internal_lane_connectivity()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
            {
              total_size += 2UL * this_._internal_traffic_segment_size();
              for (const auto& msg : this_._internal_traffic_segment()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .valhalla.TurnLane turn_lanes = 42;
            {
              total_size += 2UL * this_._internal_turn_lanes_size();
              for (const auto& msg : this_._internal_turn_lanes()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .valhalla.TaggedValue tagged_value = 48;
            {
              total_size += 2UL * this_._internal_tagged_value_size();
              for (const auto& msg : this_._internal_tagged_value()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .valhalla.RouteLandmark landmarks = 54;
            {
              total_size += 2UL * this_._internal_landmarks_size();
              for (const auto& msg : this_._internal_landmarks()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .valhalla.StreetName tunnel_name = 55;
            {
              total_size += 2UL * this_._internal_tunnel_name_size();
              for (const auto& msg : this_._internal_tunnel_name()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated float elevation = 57;
            {
              std::size_t data_size = std::size_t{4} *
                  ::_pbi::FromIntSize(this_._internal_elevation_size());
              std::size_t tag_size = data_size == 0
                  ? 0
                  : 2 + ::_pbi::WireFormatLite::Int32Size(
                                      static_cast<int32_t>(data_size));
              total_size += tag_size + data_size;
            }
            // repeated .valhalla.TripLeg.ConditionalSpeedLimit conditional_speed_limits = 60;
            {
              total_size += 2UL * this_._internal_conditional_speed_limits_size();
              for (const auto& msg : this_._internal_conditional_speed_limits()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .valhalla.TripLeg.Edge.Level levels = 61;
            {
              total_size += 2UL * this_._internal_levels_size();
              for (const auto& msg : this_._internal_levels()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000007u) {
            // .valhalla.TripSign sign = 19;
            if (cached_has_bits & 0x00000001u) {
              total_size += 2 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.sign_);
            }
            // .valhalla.TransitRouteInfo transit_route_info = 25;
            if (cached_has_bits & 0x00000002u) {
              total_size += 2 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.transit_route_info_);
            }
            // .valhalla.TripLeg.Restriction restriction = 45;
            if (cached_has_bits & 0x00000004u) {
              total_size += 2 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.restriction_);
            }
          }
           {
            // float length_km = 2;
            if (::absl::bit_cast<::uint32_t>(this_._internal_length_km()) != 0) {
              total_size += 5;
            }
            // float speed = 3;
            if (::absl::bit_cast<::uint32_t>(this_._internal_speed()) != 0) {
              total_size += 5;
            }
            // .valhalla.RoadClass road_class = 4;
            if (this_._internal_road_class() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_road_class());
            }
            // uint32 begin_heading = 5;
            if (this_._internal_begin_heading() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_begin_heading());
            }
            // uint32 end_heading = 6;
            if (this_._internal_end_heading() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_end_heading());
            }
            // uint32 begin_shape_index = 7;
            if (this_._internal_begin_shape_index() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_begin_shape_index());
            }
            // uint32 end_shape_index = 8;
            if (this_._internal_end_shape_index() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_end_shape_index());
            }
            // .valhalla.TripLeg.Traversability traversability = 9;
            if (this_._internal_traversability() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_traversability());
            }
            // .valhalla.TripLeg.Use use = 10;
            if (this_._internal_use() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_use());
            }
            // bool toll = 11;
            if (this_._internal_toll() != 0) {
              total_size += 2;
            }
            // bool unpaved = 12;
            if (this_._internal_unpaved() != 0) {
              total_size += 2;
            }
            // bool tunnel = 13;
            if (this_._internal_tunnel() != 0) {
              total_size += 2;
            }
            // bool bridge = 14;
            if (this_._internal_bridge() != 0) {
              total_size += 2;
            }
            // .valhalla.TripLeg.Surface surface = 18;
            if (this_._internal_surface() != 0) {
              total_size += 2 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_surface());
            }
            // .valhalla.TravelMode travel_mode = 20;
            if (this_._internal_travel_mode() != 0) {
              total_size += 2 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_travel_mode());
            }
            // bool roundabout = 15;
            if (this_._internal_roundabout() != 0) {
              total_size += 2;
            }
            // bool internal_intersection = 16;
            if (this_._internal_internal_intersection() != 0) {
              total_size += 3;
            }
            // bool drive_on_left = 17;
            if (this_._internal_drive_on_left() != 0) {
              total_size += 3;
            }
            // bool bicycle_network = 33;
            if (this_._internal_bicycle_network() != 0) {
              total_size += 3;
            }
            // .valhalla.VehicleType vehicle_type = 21;
            if (this_._internal_vehicle_type() != 0) {
              total_size += 2 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_vehicle_type());
            }
            // .valhalla.PedestrianType pedestrian_type = 22;
            if (this_._internal_pedestrian_type() != 0) {
              total_size += 2 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_pedestrian_type());
            }
            // .valhalla.BicycleType bicycle_type = 23;
            if (this_._internal_bicycle_type() != 0) {
              total_size += 2 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_bicycle_type());
            }
            // uint64 id = 26;
            if (this_._internal_id() != 0) {
              total_size += 2 + ::_pbi::WireFormatLite::UInt64Size(
                                              this_._internal_id());
            }
            // .valhalla.TransitType transit_type = 24;
            if (this_._internal_transit_type() != 0) {
              total_size += 2 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_transit_type());
            }
            // float weighted_grade = 28;
            if (::absl::bit_cast<::uint32_t>(this_._internal_weighted_grade()) != 0) {
              total_size += 6;
            }
            // uint64 way_id = 27;
            if (this_._internal_way_id() != 0) {
              total_size += 2 + ::_pbi::WireFormatLite::UInt64Size(
                                              this_._internal_way_id());
            }
            // int32 max_upward_grade = 29;
            if (this_._internal_max_upward_grade() != 0) {
              total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                              this_._internal_max_upward_grade());
            }
            // int32 max_downward_grade = 30;
            if (this_._internal_max_downward_grade() != 0) {
              total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                              this_._internal_max_downward_grade());
            }
            // uint32 lane_count = 31;
            if (this_._internal_lane_count() != 0) {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_lane_count());
            }
            // .valhalla.TripLeg.CycleLane cycle_lane = 32;
            if (this_._internal_cycle_lane() != 0) {
              total_size += 2 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_cycle_lane());
            }
            // .valhalla.TripLeg.Sidewalk sidewalk = 34;
            if (this_._internal_sidewalk() != 0) {
              total_size += 2 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_sidewalk());
            }
            // uint32 density = 35;
            if (this_._internal_density() != 0) {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_density());
            }
            // uint32 speed_limit = 36;
            if (this_._internal_speed_limit() != 0) {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_speed_limit());
            }
            // float truck_speed = 37;
            if (::absl::bit_cast<::uint32_t>(this_._internal_truck_speed()) != 0) {
              total_size += 6;
            }
            // int32 mean_elevation = 40;
            if (this_._internal_mean_elevation() != 0) {
              total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                              this_._internal_mean_elevation());
            }
            // bool truck_route = 38;
            if (this_._internal_truck_route() != 0) {
              total_size += 3;
            }
            // bool has_time_restrictions = 43;
            if (this_._internal_has_time_restrictions() != 0) {
              total_size += 3;
            }
            // bool destination_only = 46;
            if (this_._internal_destination_only() != 0) {
              total_size += 3;
            }
            // bool is_urban = 47;
            if (this_._internal_is_urban() != 0) {
              total_size += 3;
            }
            // float default_speed = 44;
            if (::absl::bit_cast<::uint32_t>(this_._internal_default_speed()) != 0) {
              total_size += 6;
            }
            // float source_along_edge = 49;
            if (::absl::bit_cast<::uint32_t>(this_._internal_source_along_edge()) != 0) {
              total_size += 6;
            }
            // float target_along_edge = 50;
            if (::absl::bit_cast<::uint32_t>(this_._internal_target_along_edge()) != 0) {
              total_size += 6;
            }
            // .valhalla.TripLeg.SacScale sac_scale = 51;
            if (this_._internal_sac_scale() != 0) {
              total_size += 2 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_sac_scale());
            }
            // bool shoulder = 52;
            if (this_._internal_shoulder() != 0) {
              total_size += 3;
            }
            // bool indoor = 53;
            if (this_._internal_indoor() != 0) {
              total_size += 3;
            }
            // bool country_crossing = 58;
            if (this_._internal_country_crossing() != 0) {
              total_size += 3;
            }
            // bool forward = 59;
            if (this_._internal_forward() != 0) {
              total_size += 3;
            }
            // float elevation_sampling_interval = 56;
            if (::absl::bit_cast<::uint32_t>(this_._internal_elevation_sampling_interval()) != 0) {
              total_size += 6;
            }
            // uint32 level_precision = 62;
            if (this_._internal_level_precision() != 0) {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_level_precision());
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TripLeg_Edge::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TripLeg_Edge*>(&to_msg);
  auto& from = static_cast<const TripLeg_Edge&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Edge)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_name()->MergeFrom(
      from._internal_name());
  _this->_internal_mutable_lane_connectivity()->MergeFrom(
      from._internal_lane_connectivity());
  _this->_internal_mutable_traffic_segment()->MergeFrom(
      from._internal_traffic_segment());
  _this->_internal_mutable_turn_lanes()->MergeFrom(
      from._internal_turn_lanes());
  _this->_internal_mutable_tagged_value()->MergeFrom(
      from._internal_tagged_value());
  _this->_internal_mutable_landmarks()->MergeFrom(
      from._internal_landmarks());
  _this->_internal_mutable_tunnel_name()->MergeFrom(
      from._internal_tunnel_name());
  _this->_internal_mutable_elevation()->MergeFrom(from._internal_elevation());
  _this->_internal_mutable_conditional_speed_limits()->MergeFrom(
      from._internal_conditional_speed_limits());
  _this->_internal_mutable_levels()->MergeFrom(
      from._internal_levels());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.sign_ != nullptr);
      if (_this->_impl_.sign_ == nullptr) {
        _this->_impl_.sign_ =
            ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TripSign>(arena, *from._impl_.sign_);
      } else {
        _this->_impl_.sign_->MergeFrom(*from._impl_.sign_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.transit_route_info_ != nullptr);
      if (_this->_impl_.transit_route_info_ == nullptr) {
        _this->_impl_.transit_route_info_ =
            ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TransitRouteInfo>(arena, *from._impl_.transit_route_info_);
      } else {
        _this->_impl_.transit_route_info_->MergeFrom(*from._impl_.transit_route_info_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(from._impl_.restriction_ != nullptr);
      if (_this->_impl_.restriction_ == nullptr) {
        _this->_impl_.restriction_ =
            ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TripLeg_Restriction>(arena, *from._impl_.restriction_);
      } else {
        _this->_impl_.restriction_->MergeFrom(*from._impl_.restriction_);
      }
    }
  }
  if (::absl::bit_cast<::uint32_t>(from._internal_length_km()) != 0) {
    _this->_impl_.length_km_ = from._impl_.length_km_;
  }
  if (::absl::bit_cast<::uint32_t>(from._internal_speed()) != 0) {
    _this->_impl_.speed_ = from._impl_.speed_;
  }
  if (from._internal_road_class() != 0) {
    _this->_impl_.road_class_ = from._impl_.road_class_;
  }
  if (from._internal_begin_heading() != 0) {
    _this->_impl_.begin_heading_ = from._impl_.begin_heading_;
  }
  if (from._internal_end_heading() != 0) {
    _this->_impl_.end_heading_ = from._impl_.end_heading_;
  }
  if (from._internal_begin_shape_index() != 0) {
    _this->_impl_.begin_shape_index_ = from._impl_.begin_shape_index_;
  }
  if (from._internal_end_shape_index() != 0) {
    _this->_impl_.end_shape_index_ = from._impl_.end_shape_index_;
  }
  if (from._internal_traversability() != 0) {
    _this->_impl_.traversability_ = from._impl_.traversability_;
  }
  if (from._internal_use() != 0) {
    _this->_impl_.use_ = from._impl_.use_;
  }
  if (from._internal_toll() != 0) {
    _this->_impl_.toll_ = from._impl_.toll_;
  }
  if (from._internal_unpaved() != 0) {
    _this->_impl_.unpaved_ = from._impl_.unpaved_;
  }
  if (from._internal_tunnel() != 0) {
    _this->_impl_.tunnel_ = from._impl_.tunnel_;
  }
  if (from._internal_bridge() != 0) {
    _this->_impl_.bridge_ = from._impl_.bridge_;
  }
  if (from._internal_surface() != 0) {
    _this->_impl_.surface_ = from._impl_.surface_;
  }
  if (from._internal_travel_mode() != 0) {
    _this->_impl_.travel_mode_ = from._impl_.travel_mode_;
  }
  if (from._internal_roundabout() != 0) {
    _this->_impl_.roundabout_ = from._impl_.roundabout_;
  }
  if (from._internal_internal_intersection() != 0) {
    _this->_impl_.internal_intersection_ = from._impl_.internal_intersection_;
  }
  if (from._internal_drive_on_left() != 0) {
    _this->_impl_.drive_on_left_ = from._impl_.drive_on_left_;
  }
  if (from._internal_bicycle_network() != 0) {
    _this->_impl_.bicycle_network_ = from._impl_.bicycle_network_;
  }
  if (from._internal_vehicle_type() != 0) {
    _this->_impl_.vehicle_type_ = from._impl_.vehicle_type_;
  }
  if (from._internal_pedestrian_type() != 0) {
    _this->_impl_.pedestrian_type_ = from._impl_.pedestrian_type_;
  }
  if (from._internal_bicycle_type() != 0) {
    _this->_impl_.bicycle_type_ = from._impl_.bicycle_type_;
  }
  if (from._internal_id() != 0) {
    _this->_impl_.id_ = from._impl_.id_;
  }
  if (from._internal_transit_type() != 0) {
    _this->_impl_.transit_type_ = from._impl_.transit_type_;
  }
  if (::absl::bit_cast<::uint32_t>(from._internal_weighted_grade()) != 0) {
    _this->_impl_.weighted_grade_ = from._impl_.weighted_grade_;
  }
  if (from._internal_way_id() != 0) {
    _this->_impl_.way_id_ = from._impl_.way_id_;
  }
  if (from._internal_max_upward_grade() != 0) {
    _this->_impl_.max_upward_grade_ = from._impl_.max_upward_grade_;
  }
  if (from._internal_max_downward_grade() != 0) {
    _this->_impl_.max_downward_grade_ = from._impl_.max_downward_grade_;
  }
  if (from._internal_lane_count() != 0) {
    _this->_impl_.lane_count_ = from._impl_.lane_count_;
  }
  if (from._internal_cycle_lane() != 0) {
    _this->_impl_.cycle_lane_ = from._impl_.cycle_lane_;
  }
  if (from._internal_sidewalk() != 0) {
    _this->_impl_.sidewalk_ = from._impl_.sidewalk_;
  }
  if (from._internal_density() != 0) {
    _this->_impl_.density_ = from._impl_.density_;
  }
  if (from._internal_speed_limit() != 0) {
    _this->_impl_.speed_limit_ = from._impl_.speed_limit_;
  }
  if (::absl::bit_cast<::uint32_t>(from._internal_truck_speed()) != 0) {
    _this->_impl_.truck_speed_ = from._impl_.truck_speed_;
  }
  if (from._internal_mean_elevation() != 0) {
    _this->_impl_.mean_elevation_ = from._impl_.mean_elevation_;
  }
  if (from._internal_truck_route() != 0) {
    _this->_impl_.truck_route_ = from._impl_.truck_route_;
  }
  if (from._internal_has_time_restrictions() != 0) {
    _this->_impl_.has_time_restrictions_ = from._impl_.has_time_restrictions_;
  }
  if (from._internal_destination_only() != 0) {
    _this->_impl_.destination_only_ = from._impl_.destination_only_;
  }
  if (from._internal_is_urban() != 0) {
    _this->_impl_.is_urban_ = from._impl_.is_urban_;
  }
  if (::absl::bit_cast<::uint32_t>(from._internal_default_speed()) != 0) {
    _this->_impl_.default_speed_ = from._impl_.default_speed_;
  }
  if (::absl::bit_cast<::uint32_t>(from._internal_source_along_edge()) != 0) {
    _this->_impl_.source_along_edge_ = from._impl_.source_along_edge_;
  }
  if (::absl::bit_cast<::uint32_t>(from._internal_target_along_edge()) != 0) {
    _this->_impl_.target_along_edge_ = from._impl_.target_along_edge_;
  }
  if (from._internal_sac_scale() != 0) {
    _this->_impl_.sac_scale_ = from._impl_.sac_scale_;
  }
  if (from._internal_shoulder() != 0) {
    _this->_impl_.shoulder_ = from._impl_.shoulder_;
  }
  if (from._internal_indoor() != 0) {
    _this->_impl_.indoor_ = from._impl_.indoor_;
  }
  if (from._internal_country_crossing() != 0) {
    _this->_impl_.country_crossing_ = from._impl_.country_crossing_;
  }
  if (from._internal_forward() != 0) {
    _this->_impl_.forward_ = from._impl_.forward_;
  }
  if (::absl::bit_cast<::uint32_t>(from._internal_elevation_sampling_interval()) != 0) {
    _this->_impl_.elevation_sampling_interval_ = from._impl_.elevation_sampling_interval_;
  }
  if (from._internal_level_precision() != 0) {
    _this->_impl_.level_precision_ = from._impl_.level_precision_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Edge::CopyFrom(const TripLeg_Edge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Edge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TripLeg_Edge::InternalSwap(TripLeg_Edge* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.name_.InternalSwap(&other->_impl_.name_);
  _impl_.lane_connectivity_.InternalSwap(&other->_impl_.lane_connectivity_);
  _impl_.traffic_segment_.InternalSwap(&other->_impl_.traffic_segment_);
  _impl_.turn_lanes_.InternalSwap(&other->_impl_.turn_lanes_);
  _impl_.tagged_value_.InternalSwap(&other->_impl_.tagged_value_);
  _impl_.landmarks_.InternalSwap(&other->_impl_.landmarks_);
  _impl_.tunnel_name_.InternalSwap(&other->_impl_.tunnel_name_);
  _impl_.elevation_.InternalSwap(&other->_impl_.elevation_);
  _impl_.conditional_speed_limits_.InternalSwap(&other->_impl_.conditional_speed_limits_);
  _impl_.levels_.InternalSwap(&other->_impl_.levels_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.level_precision_)
      + sizeof(TripLeg_Edge::_impl_.level_precision_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Edge, _impl_.sign_)>(
          reinterpret_cast<char*>(&_impl_.sign_),
          reinterpret_cast<char*>(&other->_impl_.sign_));
}

// ===================================================================

class TripLeg_IntersectingEdge::_Internal {
 public:
  using HasBits =
      decltype(std::declval<TripLeg_IntersectingEdge>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_._has_bits_);
};

void TripLeg_IntersectingEdge::clear_sign() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sign_ != nullptr) _impl_.sign_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TripLeg_IntersectingEdge::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Clear();
}
TripLeg_IntersectingEdge::TripLeg_IntersectingEdge(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.IntersectingEdge)
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_IntersectingEdge::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::TripLeg_IntersectingEdge& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        name_{visibility, arena, from.name_} {}

TripLeg_IntersectingEdge::TripLeg_IntersectingEdge(
    ::google::protobuf::Arena* arena,
    const TripLeg_IntersectingEdge& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TripLeg_IntersectingEdge* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.sign_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TripSign>(
                              arena, *from._impl_.sign_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, begin_heading_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, begin_heading_),
           offsetof(Impl_, lane_count_) -
               offsetof(Impl_, begin_heading_) +
               sizeof(Impl_::lane_count_));

  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.IntersectingEdge)
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_IntersectingEdge::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        name_{visibility, arena} {}

inline void TripLeg_IntersectingEdge::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, sign_),
           0,
           offsetof(Impl_, lane_count_) -
               offsetof(Impl_, sign_) +
               sizeof(Impl_::lane_count_));
}
TripLeg_IntersectingEdge::~TripLeg_IntersectingEdge() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.IntersectingEdge)
  SharedDtor(*this);
}
inline void TripLeg_IntersectingEdge::SharedDtor(MessageLite& self) {
  TripLeg_IntersectingEdge& this_ = static_cast<TripLeg_IntersectingEdge&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.sign_;
  this_._impl_.~Impl_();
}

inline void* TripLeg_IntersectingEdge::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TripLeg_IntersectingEdge(arena);
}
constexpr auto TripLeg_IntersectingEdge::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.name_) +
          decltype(TripLeg_IntersectingEdge::_impl_.name_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(TripLeg_IntersectingEdge), alignof(TripLeg_IntersectingEdge), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&TripLeg_IntersectingEdge::PlacementNew_,
                                 sizeof(TripLeg_IntersectingEdge),
                                 alignof(TripLeg_IntersectingEdge));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<34> TripLeg_IntersectingEdge::_class_data_ = {
    {
        &_TripLeg_IntersectingEdge_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TripLeg_IntersectingEdge::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TripLeg_IntersectingEdge>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TripLeg_IntersectingEdge::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TripLeg_IntersectingEdge>(), &TripLeg_IntersectingEdge::ByteSizeLong,
            &TripLeg_IntersectingEdge::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_._cached_size_),
        true,
    },
    "valhalla.TripLeg.IntersectingEdge",
};
const ::google::protobuf::internal::ClassData* TripLeg_IntersectingEdge::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 11, 2, 0, 2> TripLeg_IntersectingEdge::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_._has_bits_),
    0, // no _extensions_
    21, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4293917696,  // skipmap
    offsetof(decltype(_table_), field_entries),
    11,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TripLeg_IntersectingEdge>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // uint32 begin_heading = 1;
    {::_pbi::TcParser::FastV32S1,
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.begin_heading_)}},
    // bool prev_name_consistency = 2;
    {::_pbi::TcParser::FastV8S1,
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.prev_name_consistency_)}},
    // bool curr_name_consistency = 3;
    {::_pbi::TcParser::FastV8S1,
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.curr_name_consistency_)}},
    // .valhalla.TripLeg.Traversability driveability = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.driveability_)}},
    // .valhalla.TripLeg.Traversability cyclability = 5;
    {::_pbi::TcParser::FastV32S1,
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.cyclability_)}},
    // .valhalla.TripLeg.Traversability walkability = 6;
    {::_pbi::TcParser::FastV32S1,
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.walkability_)}},
    // .valhalla.TripLeg.Use use = 7;
    {::_pbi::TcParser::FastV32S1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.use_)}},
    // .valhalla.RoadClass road_class = 8;
    {::_pbi::TcParser::FastV32S1,
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.road_class_)}},
    // uint32 lane_count = 9;
    {::_pbi::TcParser::FastV32S1,
     {72, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.lane_count_)}},
    // .valhalla.TripSign sign = 10;
    {::_pbi::TcParser::FastMtS1,
     {82, 0, 0, PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.sign_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 begin_heading = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.begin_heading_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // bool prev_name_consistency = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.prev_name_consistency_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool curr_name_consistency = 3;
    {PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.curr_name_consistency_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // .valhalla.TripLeg.Traversability driveability = 4;
    {PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.driveability_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.TripLeg.Traversability cyclability = 5;
    {PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.cyclability_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.TripLeg.Traversability walkability = 6;
    {PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.walkability_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.TripLeg.Use use = 7;
    {PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.use_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.RoadClass road_class = 8;
    {PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.road_class_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // uint32 lane_count = 9;
    {PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.lane_count_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // .valhalla.TripSign sign = 10;
    {PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.sign_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .valhalla.StreetName name = 21;
    {PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.name_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::TripSign>()},
    {::_pbi::TcParser::GetTable<::valhalla::StreetName>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void TripLeg_IntersectingEdge::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.IntersectingEdge)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.sign_ != nullptr);
    _impl_.sign_->Clear();
  }
  ::memset(&_impl_.begin_heading_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.lane_count_) -
      reinterpret_cast<char*>(&_impl_.begin_heading_)) + sizeof(_impl_.lane_count_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TripLeg_IntersectingEdge::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TripLeg_IntersectingEdge& this_ = static_cast<const TripLeg_IntersectingEdge&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TripLeg_IntersectingEdge::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TripLeg_IntersectingEdge& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.IntersectingEdge)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // uint32 begin_heading = 1;
          if (this_._internal_begin_heading() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                1, this_._internal_begin_heading(), target);
          }

          // bool prev_name_consistency = 2;
          if (this_._internal_prev_name_consistency() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                2, this_._internal_prev_name_consistency(), target);
          }

          // bool curr_name_consistency = 3;
          if (this_._internal_curr_name_consistency() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                3, this_._internal_curr_name_consistency(), target);
          }

          // .valhalla.TripLeg.Traversability driveability = 4;
          if (this_._internal_driveability() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                4, this_._internal_driveability(), target);
          }

          // .valhalla.TripLeg.Traversability cyclability = 5;
          if (this_._internal_cyclability() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                5, this_._internal_cyclability(), target);
          }

          // .valhalla.TripLeg.Traversability walkability = 6;
          if (this_._internal_walkability() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                6, this_._internal_walkability(), target);
          }

          // .valhalla.TripLeg.Use use = 7;
          if (this_._internal_use() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                7, this_._internal_use(), target);
          }

          // .valhalla.RoadClass road_class = 8;
          if (this_._internal_road_class() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                8, this_._internal_road_class(), target);
          }

          // uint32 lane_count = 9;
          if (this_._internal_lane_count() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                9, this_._internal_lane_count(), target);
          }

          cached_has_bits = this_._impl_._has_bits_[0];
          // .valhalla.TripSign sign = 10;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                10, *this_._impl_.sign_, this_._impl_.sign_->GetCachedSize(), target,
                stream);
          }

          // repeated .valhalla.StreetName name = 21;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_name_size());
               i < n; i++) {
            const auto& repfield = this_._internal_name().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    21, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.IntersectingEdge)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TripLeg_IntersectingEdge::ByteSizeLong(const MessageLite& base) {
          const TripLeg_IntersectingEdge& this_ = static_cast<const TripLeg_IntersectingEdge&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TripLeg_IntersectingEdge::ByteSizeLong() const {
          const TripLeg_IntersectingEdge& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.IntersectingEdge)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .valhalla.StreetName name = 21;
            {
              total_size += 2UL * this_._internal_name_size();
              for (const auto& msg : this_._internal_name()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
           {
            // .valhalla.TripSign sign = 10;
            cached_has_bits = this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.sign_);
            }
          }
           {
            // uint32 begin_heading = 1;
            if (this_._internal_begin_heading() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_begin_heading());
            }
            // bool prev_name_consistency = 2;
            if (this_._internal_prev_name_consistency() != 0) {
              total_size += 2;
            }
            // bool curr_name_consistency = 3;
            if (this_._internal_curr_name_consistency() != 0) {
              total_size += 2;
            }
            // .valhalla.TripLeg.Traversability driveability = 4;
            if (this_._internal_driveability() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_driveability());
            }
            // .valhalla.TripLeg.Traversability cyclability = 5;
            if (this_._internal_cyclability() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_cyclability());
            }
            // .valhalla.TripLeg.Traversability walkability = 6;
            if (this_._internal_walkability() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_walkability());
            }
            // .valhalla.TripLeg.Use use = 7;
            if (this_._internal_use() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_use());
            }
            // .valhalla.RoadClass road_class = 8;
            if (this_._internal_road_class() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_road_class());
            }
            // uint32 lane_count = 9;
            if (this_._internal_lane_count() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_lane_count());
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TripLeg_IntersectingEdge::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TripLeg_IntersectingEdge*>(&to_msg);
  auto& from = static_cast<const TripLeg_IntersectingEdge&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.IntersectingEdge)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_name()->MergeFrom(
      from._internal_name());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(from._impl_.sign_ != nullptr);
    if (_this->_impl_.sign_ == nullptr) {
      _this->_impl_.sign_ =
          ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TripSign>(arena, *from._impl_.sign_);
    } else {
      _this->_impl_.sign_->MergeFrom(*from._impl_.sign_);
    }
  }
  if (from._internal_begin_heading() != 0) {
    _this->_impl_.begin_heading_ = from._impl_.begin_heading_;
  }
  if (from._internal_prev_name_consistency() != 0) {
    _this->_impl_.prev_name_consistency_ = from._impl_.prev_name_consistency_;
  }
  if (from._internal_curr_name_consistency() != 0) {
    _this->_impl_.curr_name_consistency_ = from._impl_.curr_name_consistency_;
  }
  if (from._internal_driveability() != 0) {
    _this->_impl_.driveability_ = from._impl_.driveability_;
  }
  if (from._internal_cyclability() != 0) {
    _this->_impl_.cyclability_ = from._impl_.cyclability_;
  }
  if (from._internal_walkability() != 0) {
    _this->_impl_.walkability_ = from._impl_.walkability_;
  }
  if (from._internal_use() != 0) {
    _this->_impl_.use_ = from._impl_.use_;
  }
  if (from._internal_road_class() != 0) {
    _this->_impl_.road_class_ = from._impl_.road_class_;
  }
  if (from._internal_lane_count() != 0) {
    _this->_impl_.lane_count_ = from._impl_.lane_count_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_IntersectingEdge::CopyFrom(const TripLeg_IntersectingEdge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.IntersectingEdge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TripLeg_IntersectingEdge::InternalSwap(TripLeg_IntersectingEdge* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.name_.InternalSwap(&other->_impl_.name_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.lane_count_)
      + sizeof(TripLeg_IntersectingEdge::_impl_.lane_count_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, _impl_.sign_)>(
          reinterpret_cast<char*>(&_impl_.sign_),
          reinterpret_cast<char*>(&other->_impl_.sign_));
}

// ===================================================================

class TripLeg_Cost::_Internal {
 public:
};

TripLeg_Cost::TripLeg_Cost(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Cost)
}
TripLeg_Cost::TripLeg_Cost(
    ::google::protobuf::Arena* arena, const TripLeg_Cost& from)
    : TripLeg_Cost(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_Cost::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void TripLeg_Cost::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, seconds_),
           0,
           offsetof(Impl_, cost_) -
               offsetof(Impl_, seconds_) +
               sizeof(Impl_::cost_));
}
TripLeg_Cost::~TripLeg_Cost() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Cost)
  SharedDtor(*this);
}
inline void TripLeg_Cost::SharedDtor(MessageLite& self) {
  TripLeg_Cost& this_ = static_cast<TripLeg_Cost&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* TripLeg_Cost::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TripLeg_Cost(arena);
}
constexpr auto TripLeg_Cost::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(TripLeg_Cost),
                                            alignof(TripLeg_Cost));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<22> TripLeg_Cost::_class_data_ = {
    {
        &_TripLeg_Cost_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TripLeg_Cost::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TripLeg_Cost>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TripLeg_Cost::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TripLeg_Cost>(), &TripLeg_Cost::ByteSizeLong,
            &TripLeg_Cost::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TripLeg_Cost, _impl_._cached_size_),
        true,
    },
    "valhalla.TripLeg.Cost",
};
const ::google::protobuf::internal::ClassData* TripLeg_Cost::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> TripLeg_Cost::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TripLeg_Cost>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // double cost = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Cost, _impl_.cost_)}},
    // double seconds = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Cost, _impl_.seconds_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double seconds = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Cost, _impl_.seconds_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double cost = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Cost, _impl_.cost_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void TripLeg_Cost::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Cost)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.seconds_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.cost_) -
      reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.cost_));
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TripLeg_Cost::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TripLeg_Cost& this_ = static_cast<const TripLeg_Cost&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TripLeg_Cost::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TripLeg_Cost& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Cost)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // double seconds = 1;
          if (::absl::bit_cast<::uint64_t>(this_._internal_seconds()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                1, this_._internal_seconds(), target);
          }

          // double cost = 2;
          if (::absl::bit_cast<::uint64_t>(this_._internal_cost()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                2, this_._internal_cost(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Cost)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TripLeg_Cost::ByteSizeLong(const MessageLite& base) {
          const TripLeg_Cost& this_ = static_cast<const TripLeg_Cost&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TripLeg_Cost::ByteSizeLong() const {
          const TripLeg_Cost& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Cost)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // double seconds = 1;
            if (::absl::bit_cast<::uint64_t>(this_._internal_seconds()) != 0) {
              total_size += 9;
            }
            // double cost = 2;
            if (::absl::bit_cast<::uint64_t>(this_._internal_cost()) != 0) {
              total_size += 9;
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TripLeg_Cost::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TripLeg_Cost*>(&to_msg);
  auto& from = static_cast<const TripLeg_Cost&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Cost)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (::absl::bit_cast<::uint64_t>(from._internal_seconds()) != 0) {
    _this->_impl_.seconds_ = from._impl_.seconds_;
  }
  if (::absl::bit_cast<::uint64_t>(from._internal_cost()) != 0) {
    _this->_impl_.cost_ = from._impl_.cost_;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Cost::CopyFrom(const TripLeg_Cost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Cost)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TripLeg_Cost::InternalSwap(TripLeg_Cost* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Cost, _impl_.cost_)
      + sizeof(TripLeg_Cost::_impl_.cost_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Cost, _impl_.seconds_)>(
          reinterpret_cast<char*>(&_impl_.seconds_),
          reinterpret_cast<char*>(&other->_impl_.seconds_));
}

// ===================================================================

class TripLeg_PathCost::_Internal {
 public:
  using HasBits =
      decltype(std::declval<TripLeg_PathCost>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, _impl_._has_bits_);
};

TripLeg_PathCost::TripLeg_PathCost(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.PathCost)
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_PathCost::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::TripLeg_PathCost& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

TripLeg_PathCost::TripLeg_PathCost(
    ::google::protobuf::Arena* arena,
    const TripLeg_PathCost& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TripLeg_PathCost* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.elapsed_cost_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TripLeg_Cost>(
                              arena, *from._impl_.elapsed_cost_)
                        : nullptr;
  _impl_.transition_cost_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TripLeg_Cost>(
                              arena, *from._impl_.transition_cost_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.PathCost)
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_PathCost::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void TripLeg_PathCost::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, elapsed_cost_),
           0,
           offsetof(Impl_, transition_cost_) -
               offsetof(Impl_, elapsed_cost_) +
               sizeof(Impl_::transition_cost_));
}
TripLeg_PathCost::~TripLeg_PathCost() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.PathCost)
  SharedDtor(*this);
}
inline void TripLeg_PathCost::SharedDtor(MessageLite& self) {
  TripLeg_PathCost& this_ = static_cast<TripLeg_PathCost&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.elapsed_cost_;
  delete this_._impl_.transition_cost_;
  this_._impl_.~Impl_();
}

inline void* TripLeg_PathCost::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TripLeg_PathCost(arena);
}
constexpr auto TripLeg_PathCost::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(TripLeg_PathCost),
                                            alignof(TripLeg_PathCost));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<26> TripLeg_PathCost::_class_data_ = {
    {
        &_TripLeg_PathCost_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TripLeg_PathCost::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TripLeg_PathCost>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TripLeg_PathCost::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TripLeg_PathCost>(), &TripLeg_PathCost::ByteSizeLong,
            &TripLeg_PathCost::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, _impl_._cached_size_),
        true,
    },
    "valhalla.TripLeg.PathCost",
};
const ::google::protobuf::internal::ClassData* TripLeg_PathCost::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 2, 0, 2> TripLeg_PathCost::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TripLeg_PathCost>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .valhalla.TripLeg.Cost transition_cost = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, _impl_.transition_cost_)}},
    // .valhalla.TripLeg.Cost elapsed_cost = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, _impl_.elapsed_cost_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .valhalla.TripLeg.Cost elapsed_cost = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, _impl_.elapsed_cost_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .valhalla.TripLeg.Cost transition_cost = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, _impl_.transition_cost_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_Cost>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_Cost>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void TripLeg_PathCost::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.PathCost)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.elapsed_cost_ != nullptr);
      _impl_.elapsed_cost_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.transition_cost_ != nullptr);
      _impl_.transition_cost_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TripLeg_PathCost::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TripLeg_PathCost& this_ = static_cast<const TripLeg_PathCost&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TripLeg_PathCost::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TripLeg_PathCost& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.PathCost)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // .valhalla.TripLeg.Cost elapsed_cost = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.elapsed_cost_, this_._impl_.elapsed_cost_->GetCachedSize(), target,
                stream);
          }

          // .valhalla.TripLeg.Cost transition_cost = 2;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                2, *this_._impl_.transition_cost_, this_._impl_.transition_cost_->GetCachedSize(), target,
                stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.PathCost)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TripLeg_PathCost::ByteSizeLong(const MessageLite& base) {
          const TripLeg_PathCost& this_ = static_cast<const TripLeg_PathCost&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TripLeg_PathCost::ByteSizeLong() const {
          const TripLeg_PathCost& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.PathCost)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000003u) {
            // .valhalla.TripLeg.Cost elapsed_cost = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.elapsed_cost_);
            }
            // .valhalla.TripLeg.Cost transition_cost = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.transition_cost_);
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TripLeg_PathCost::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TripLeg_PathCost*>(&to_msg);
  auto& from = static_cast<const TripLeg_PathCost&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.PathCost)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.elapsed_cost_ != nullptr);
      if (_this->_impl_.elapsed_cost_ == nullptr) {
        _this->_impl_.elapsed_cost_ =
            ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TripLeg_Cost>(arena, *from._impl_.elapsed_cost_);
      } else {
        _this->_impl_.elapsed_cost_->MergeFrom(*from._impl_.elapsed_cost_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.transition_cost_ != nullptr);
      if (_this->_impl_.transition_cost_ == nullptr) {
        _this->_impl_.transition_cost_ =
            ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TripLeg_Cost>(arena, *from._impl_.transition_cost_);
      } else {
        _this->_impl_.transition_cost_->MergeFrom(*from._impl_.transition_cost_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_PathCost::CopyFrom(const TripLeg_PathCost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.PathCost)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TripLeg_PathCost::InternalSwap(TripLeg_PathCost* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, _impl_.transition_cost_)
      + sizeof(TripLeg_PathCost::_impl_.transition_cost_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, _impl_.elapsed_cost_)>(
          reinterpret_cast<char*>(&_impl_.elapsed_cost_),
          reinterpret_cast<char*>(&other->_impl_.elapsed_cost_));
}

// ===================================================================

class TripLeg_Node::_Internal {
 public:
  using HasBits =
      decltype(std::declval<TripLeg_Node>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_._has_bits_);
};

void TripLeg_Node::clear_transit_platform_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.transit_platform_info_ != nullptr) _impl_.transit_platform_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void TripLeg_Node::clear_transit_station_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.transit_station_info_ != nullptr) _impl_.transit_station_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void TripLeg_Node::clear_transit_egress_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.transit_egress_info_ != nullptr) _impl_.transit_egress_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void TripLeg_Node::clear_bss_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.bss_info_ != nullptr) _impl_.bss_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
TripLeg_Node::TripLeg_Node(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Node)
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_Node::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::TripLeg_Node& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        intersecting_edge_{visibility, arena, from.intersecting_edge_},
        recosts_{visibility, arena, from.recosts_},
        time_zone_(arena, from.time_zone_) {}

TripLeg_Node::TripLeg_Node(
    ::google::protobuf::Arena* arena,
    const TripLeg_Node& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TripLeg_Node* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.edge_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TripLeg_Edge>(
                              arena, *from._impl_.edge_)
                        : nullptr;
  _impl_.transit_platform_info_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TransitPlatformInfo>(
                              arena, *from._impl_.transit_platform_info_)
                        : nullptr;
  _impl_.transit_station_info_ = (cached_has_bits & 0x00000004u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TransitStationInfo>(
                              arena, *from._impl_.transit_station_info_)
                        : nullptr;
  _impl_.transit_egress_info_ = (cached_has_bits & 0x00000008u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TransitEgressInfo>(
                              arena, *from._impl_.transit_egress_info_)
                        : nullptr;
  _impl_.cost_ = (cached_has_bits & 0x00000010u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TripLeg_PathCost>(
                              arena, *from._impl_.cost_)
                        : nullptr;
  _impl_.bss_info_ = (cached_has_bits & 0x00000020u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::BikeShareStationInfo>(
                              arena, *from._impl_.bss_info_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, admin_index_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, admin_index_),
           offsetof(Impl_, traffic_signal_) -
               offsetof(Impl_, admin_index_) +
               sizeof(Impl_::traffic_signal_));

  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Node)
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_Node::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        intersecting_edge_{visibility, arena},
        recosts_{visibility, arena},
        time_zone_(arena) {}

inline void TripLeg_Node::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, edge_),
           0,
           offsetof(Impl_, traffic_signal_) -
               offsetof(Impl_, edge_) +
               sizeof(Impl_::traffic_signal_));
}
TripLeg_Node::~TripLeg_Node() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Node)
  SharedDtor(*this);
}
inline void TripLeg_Node::SharedDtor(MessageLite& self) {
  TripLeg_Node& this_ = static_cast<TripLeg_Node&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.time_zone_.Destroy();
  delete this_._impl_.edge_;
  delete this_._impl_.transit_platform_info_;
  delete this_._impl_.transit_station_info_;
  delete this_._impl_.transit_egress_info_;
  delete this_._impl_.cost_;
  delete this_._impl_.bss_info_;
  this_._impl_.~Impl_();
}

inline void* TripLeg_Node::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TripLeg_Node(arena);
}
constexpr auto TripLeg_Node::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.intersecting_edge_) +
          decltype(TripLeg_Node::_impl_.intersecting_edge_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.recosts_) +
          decltype(TripLeg_Node::_impl_.recosts_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(TripLeg_Node), alignof(TripLeg_Node), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&TripLeg_Node::PlacementNew_,
                                 sizeof(TripLeg_Node),
                                 alignof(TripLeg_Node));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<22> TripLeg_Node::_class_data_ = {
    {
        &_TripLeg_Node_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TripLeg_Node::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TripLeg_Node>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TripLeg_Node::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TripLeg_Node>(), &TripLeg_Node::ByteSizeLong,
            &TripLeg_Node::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_._cached_size_),
        true,
    },
    "valhalla.TripLeg.Node",
};
const ::google::protobuf::internal::ClassData* TripLeg_Node::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 13, 8, 47, 2> TripLeg_Node::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_._has_bits_),
    0, // no _extensions_
    21, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4293902720,  // skipmap
    offsetof(decltype(_table_), field_entries),
    13,  // num_field_entries
    8,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TripLeg_Node>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .valhalla.TripLeg.Edge edge = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.edge_)}},
    // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 1, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.intersecting_edge_)}},
    // uint32 admin_index = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.admin_index_)}},
    // .valhalla.TripLeg.Node.Type type = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.type_)}},
    // bool fork = 5;
    {::_pbi::TcParser::FastV8S1,
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.fork_)}},
    // .valhalla.TransitPlatformInfo transit_platform_info = 6;
    {::_pbi::TcParser::FastMtS1,
     {50, 1, 2, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.transit_platform_info_)}},
    // .valhalla.TransitStationInfo transit_station_info = 7;
    {::_pbi::TcParser::FastMtS1,
     {58, 2, 3, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.transit_station_info_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // .valhalla.TransitEgressInfo transit_egress_info = 10;
    {::_pbi::TcParser::FastMtS1,
     {82, 3, 4, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.transit_egress_info_)}},
    // string time_zone = 11;
    {::_pbi::TcParser::FastUS1,
     {90, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.time_zone_)}},
    // .valhalla.TripLeg.PathCost cost = 12;
    {::_pbi::TcParser::FastMtS1,
     {98, 4, 5, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.cost_)}},
    // repeated .valhalla.TripLeg.PathCost recosts = 13;
    {::_pbi::TcParser::FastMtR1,
     {106, 63, 6, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.recosts_)}},
    // .valhalla.BikeShareStationInfo bss_info = 14;
    {::_pbi::TcParser::FastMtS1,
     {114, 5, 7, PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.bss_info_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .valhalla.TripLeg.Edge edge = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.edge_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.intersecting_edge_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // uint32 admin_index = 3;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.admin_index_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // .valhalla.TripLeg.Node.Type type = 4;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.type_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // bool fork = 5;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.fork_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // .valhalla.TransitPlatformInfo transit_platform_info = 6;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.transit_platform_info_), _Internal::kHasBitsOffset + 1, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .valhalla.TransitStationInfo transit_station_info = 7;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.transit_station_info_), _Internal::kHasBitsOffset + 2, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .valhalla.TransitEgressInfo transit_egress_info = 10;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.transit_egress_info_), _Internal::kHasBitsOffset + 3, 4,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // string time_zone = 11;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.time_zone_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .valhalla.TripLeg.PathCost cost = 12;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.cost_), _Internal::kHasBitsOffset + 4, 5,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .valhalla.TripLeg.PathCost recosts = 13;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.recosts_), -1, 6,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // .valhalla.BikeShareStationInfo bss_info = 14;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.bss_info_), _Internal::kHasBitsOffset + 5, 7,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // bool traffic_signal = 21;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.traffic_signal_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_Edge>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_IntersectingEdge>()},
    {::_pbi::TcParser::GetTable<::valhalla::TransitPlatformInfo>()},
    {::_pbi::TcParser::GetTable<::valhalla::TransitStationInfo>()},
    {::_pbi::TcParser::GetTable<::valhalla::TransitEgressInfo>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_PathCost>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_PathCost>()},
    {::_pbi::TcParser::GetTable<::valhalla::BikeShareStationInfo>()},
  }}, {{
    "\25\0\0\0\0\0\0\0\0\11\0\0\0\0\0\0"
    "valhalla.TripLeg.Node"
    "time_zone"
  }},
};

PROTOBUF_NOINLINE void TripLeg_Node::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Node)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.intersecting_edge_.Clear();
  _impl_.recosts_.Clear();
  _impl_.time_zone_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.edge_ != nullptr);
      _impl_.edge_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.transit_platform_info_ != nullptr);
      _impl_.transit_platform_info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.transit_station_info_ != nullptr);
      _impl_.transit_station_info_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.transit_egress_info_ != nullptr);
      _impl_.transit_egress_info_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.cost_ != nullptr);
      _impl_.cost_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(_impl_.bss_info_ != nullptr);
      _impl_.bss_info_->Clear();
    }
  }
  ::memset(&_impl_.admin_index_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.traffic_signal_) -
      reinterpret_cast<char*>(&_impl_.admin_index_)) + sizeof(_impl_.traffic_signal_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TripLeg_Node::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TripLeg_Node& this_ = static_cast<const TripLeg_Node&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TripLeg_Node::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TripLeg_Node& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Node)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // .valhalla.TripLeg.Edge edge = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.edge_, this_._impl_.edge_->GetCachedSize(), target,
                stream);
          }

          // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_intersecting_edge_size());
               i < n; i++) {
            const auto& repfield = this_._internal_intersecting_edge().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    2, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // uint32 admin_index = 3;
          if (this_._internal_admin_index() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                3, this_._internal_admin_index(), target);
          }

          // .valhalla.TripLeg.Node.Type type = 4;
          if (this_._internal_type() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                4, this_._internal_type(), target);
          }

          // bool fork = 5;
          if (this_._internal_fork() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                5, this_._internal_fork(), target);
          }

          // .valhalla.TransitPlatformInfo transit_platform_info = 6;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                6, *this_._impl_.transit_platform_info_, this_._impl_.transit_platform_info_->GetCachedSize(), target,
                stream);
          }

          // .valhalla.TransitStationInfo transit_station_info = 7;
          if (cached_has_bits & 0x00000004u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                7, *this_._impl_.transit_station_info_, this_._impl_.transit_station_info_->GetCachedSize(), target,
                stream);
          }

          // .valhalla.TransitEgressInfo transit_egress_info = 10;
          if (cached_has_bits & 0x00000008u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                10, *this_._impl_.transit_egress_info_, this_._impl_.transit_egress_info_->GetCachedSize(), target,
                stream);
          }

          // string time_zone = 11;
          if (!this_._internal_time_zone().empty()) {
            const std::string& _s = this_._internal_time_zone();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TripLeg.Node.time_zone");
            target = stream->WriteStringMaybeAliased(11, _s, target);
          }

          // .valhalla.TripLeg.PathCost cost = 12;
          if (cached_has_bits & 0x00000010u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                12, *this_._impl_.cost_, this_._impl_.cost_->GetCachedSize(), target,
                stream);
          }

          // repeated .valhalla.TripLeg.PathCost recosts = 13;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_recosts_size());
               i < n; i++) {
            const auto& repfield = this_._internal_recosts().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    13, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // .valhalla.BikeShareStationInfo bss_info = 14;
          if (cached_has_bits & 0x00000020u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                14, *this_._impl_.bss_info_, this_._impl_.bss_info_->GetCachedSize(), target,
                stream);
          }

          // bool traffic_signal = 21;
          if (this_._internal_traffic_signal() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                21, this_._internal_traffic_signal(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Node)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TripLeg_Node::ByteSizeLong(const MessageLite& base) {
          const TripLeg_Node& this_ = static_cast<const TripLeg_Node&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TripLeg_Node::ByteSizeLong() const {
          const TripLeg_Node& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Node)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
            {
              total_size += 1UL * this_._internal_intersecting_edge_size();
              for (const auto& msg : this_._internal_intersecting_edge()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .valhalla.TripLeg.PathCost recosts = 13;
            {
              total_size += 1UL * this_._internal_recosts_size();
              for (const auto& msg : this_._internal_recosts()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
           {
            // string time_zone = 11;
            if (!this_._internal_time_zone().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_time_zone());
            }
          }
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x0000003fu) {
            // .valhalla.TripLeg.Edge edge = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.edge_);
            }
            // .valhalla.TransitPlatformInfo transit_platform_info = 6;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.transit_platform_info_);
            }
            // .valhalla.TransitStationInfo transit_station_info = 7;
            if (cached_has_bits & 0x00000004u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.transit_station_info_);
            }
            // .valhalla.TransitEgressInfo transit_egress_info = 10;
            if (cached_has_bits & 0x00000008u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.transit_egress_info_);
            }
            // .valhalla.TripLeg.PathCost cost = 12;
            if (cached_has_bits & 0x00000010u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.cost_);
            }
            // .valhalla.BikeShareStationInfo bss_info = 14;
            if (cached_has_bits & 0x00000020u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.bss_info_);
            }
          }
           {
            // uint32 admin_index = 3;
            if (this_._internal_admin_index() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_admin_index());
            }
            // .valhalla.TripLeg.Node.Type type = 4;
            if (this_._internal_type() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_type());
            }
            // bool fork = 5;
            if (this_._internal_fork() != 0) {
              total_size += 2;
            }
            // bool traffic_signal = 21;
            if (this_._internal_traffic_signal() != 0) {
              total_size += 3;
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TripLeg_Node::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TripLeg_Node*>(&to_msg);
  auto& from = static_cast<const TripLeg_Node&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Node)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_intersecting_edge()->MergeFrom(
      from._internal_intersecting_edge());
  _this->_internal_mutable_recosts()->MergeFrom(
      from._internal_recosts());
  if (!from._internal_time_zone().empty()) {
    _this->_internal_set_time_zone(from._internal_time_zone());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.edge_ != nullptr);
      if (_this->_impl_.edge_ == nullptr) {
        _this->_impl_.edge_ =
            ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TripLeg_Edge>(arena, *from._impl_.edge_);
      } else {
        _this->_impl_.edge_->MergeFrom(*from._impl_.edge_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.transit_platform_info_ != nullptr);
      if (_this->_impl_.transit_platform_info_ == nullptr) {
        _this->_impl_.transit_platform_info_ =
            ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TransitPlatformInfo>(arena, *from._impl_.transit_platform_info_);
      } else {
        _this->_impl_.transit_platform_info_->MergeFrom(*from._impl_.transit_platform_info_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(from._impl_.transit_station_info_ != nullptr);
      if (_this->_impl_.transit_station_info_ == nullptr) {
        _this->_impl_.transit_station_info_ =
            ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TransitStationInfo>(arena, *from._impl_.transit_station_info_);
      } else {
        _this->_impl_.transit_station_info_->MergeFrom(*from._impl_.transit_station_info_);
      }
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(from._impl_.transit_egress_info_ != nullptr);
      if (_this->_impl_.transit_egress_info_ == nullptr) {
        _this->_impl_.transit_egress_info_ =
            ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TransitEgressInfo>(arena, *from._impl_.transit_egress_info_);
      } else {
        _this->_impl_.transit_egress_info_->MergeFrom(*from._impl_.transit_egress_info_);
      }
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(from._impl_.cost_ != nullptr);
      if (_this->_impl_.cost_ == nullptr) {
        _this->_impl_.cost_ =
            ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TripLeg_PathCost>(arena, *from._impl_.cost_);
      } else {
        _this->_impl_.cost_->MergeFrom(*from._impl_.cost_);
      }
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(from._impl_.bss_info_ != nullptr);
      if (_this->_impl_.bss_info_ == nullptr) {
        _this->_impl_.bss_info_ =
            ::google::protobuf::MessageLite::CopyConstruct<::valhalla::BikeShareStationInfo>(arena, *from._impl_.bss_info_);
      } else {
        _this->_impl_.bss_info_->MergeFrom(*from._impl_.bss_info_);
      }
    }
  }
  if (from._internal_admin_index() != 0) {
    _this->_impl_.admin_index_ = from._impl_.admin_index_;
  }
  if (from._internal_type() != 0) {
    _this->_impl_.type_ = from._impl_.type_;
  }
  if (from._internal_fork() != 0) {
    _this->_impl_.fork_ = from._impl_.fork_;
  }
  if (from._internal_traffic_signal() != 0) {
    _this->_impl_.traffic_signal_ = from._impl_.traffic_signal_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Node::CopyFrom(const TripLeg_Node& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Node)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TripLeg_Node::InternalSwap(TripLeg_Node* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.intersecting_edge_.InternalSwap(&other->_impl_.intersecting_edge_);
  _impl_.recosts_.InternalSwap(&other->_impl_.recosts_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.time_zone_, &other->_impl_.time_zone_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.traffic_signal_)
      + sizeof(TripLeg_Node::_impl_.traffic_signal_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Node, _impl_.edge_)>(
          reinterpret_cast<char*>(&_impl_.edge_),
          reinterpret_cast<char*>(&other->_impl_.edge_));
}

// ===================================================================

class TripLeg_Admin::_Internal {
 public:
};

TripLeg_Admin::TripLeg_Admin(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Admin)
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_Admin::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::TripLeg_Admin& from_msg)
      : country_code_(arena, from.country_code_),
        country_text_(arena, from.country_text_),
        state_code_(arena, from.state_code_),
        state_text_(arena, from.state_text_),
        _cached_size_{0} {}

TripLeg_Admin::TripLeg_Admin(
    ::google::protobuf::Arena* arena,
    const TripLeg_Admin& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TripLeg_Admin* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Admin)
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_Admin::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : country_code_(arena),
        country_text_(arena),
        state_code_(arena),
        state_text_(arena),
        _cached_size_{0} {}

inline void TripLeg_Admin::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
TripLeg_Admin::~TripLeg_Admin() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Admin)
  SharedDtor(*this);
}
inline void TripLeg_Admin::SharedDtor(MessageLite& self) {
  TripLeg_Admin& this_ = static_cast<TripLeg_Admin&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.country_code_.Destroy();
  this_._impl_.country_text_.Destroy();
  this_._impl_.state_code_.Destroy();
  this_._impl_.state_text_.Destroy();
  this_._impl_.~Impl_();
}

inline void* TripLeg_Admin::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TripLeg_Admin(arena);
}
constexpr auto TripLeg_Admin::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(TripLeg_Admin),
                                            alignof(TripLeg_Admin));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<23> TripLeg_Admin::_class_data_ = {
    {
        &_TripLeg_Admin_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TripLeg_Admin::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TripLeg_Admin>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TripLeg_Admin::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TripLeg_Admin>(), &TripLeg_Admin::ByteSizeLong,
            &TripLeg_Admin::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TripLeg_Admin, _impl_._cached_size_),
        true,
    },
    "valhalla.TripLeg.Admin",
};
const ::google::protobuf::internal::ClassData* TripLeg_Admin::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 75, 2> TripLeg_Admin::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TripLeg_Admin>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string state_text = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Admin, _impl_.state_text_)}},
    // string country_code = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Admin, _impl_.country_code_)}},
    // string country_text = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Admin, _impl_.country_text_)}},
    // string state_code = 3;
    {::_pbi::TcParser::FastUS1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Admin, _impl_.state_code_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string country_code = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Admin, _impl_.country_code_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string country_text = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Admin, _impl_.country_text_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string state_code = 3;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Admin, _impl_.state_code_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string state_text = 4;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Admin, _impl_.state_text_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\26\14\14\12\12\0\0\0"
    "valhalla.TripLeg.Admin"
    "country_code"
    "country_text"
    "state_code"
    "state_text"
  }},
};

PROTOBUF_NOINLINE void TripLeg_Admin::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Admin)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.country_code_.ClearToEmpty();
  _impl_.country_text_.ClearToEmpty();
  _impl_.state_code_.ClearToEmpty();
  _impl_.state_text_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TripLeg_Admin::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TripLeg_Admin& this_ = static_cast<const TripLeg_Admin&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TripLeg_Admin::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TripLeg_Admin& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Admin)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string country_code = 1;
          if (!this_._internal_country_code().empty()) {
            const std::string& _s = this_._internal_country_code();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TripLeg.Admin.country_code");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // string country_text = 2;
          if (!this_._internal_country_text().empty()) {
            const std::string& _s = this_._internal_country_text();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TripLeg.Admin.country_text");
            target = stream->WriteStringMaybeAliased(2, _s, target);
          }

          // string state_code = 3;
          if (!this_._internal_state_code().empty()) {
            const std::string& _s = this_._internal_state_code();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TripLeg.Admin.state_code");
            target = stream->WriteStringMaybeAliased(3, _s, target);
          }

          // string state_text = 4;
          if (!this_._internal_state_text().empty()) {
            const std::string& _s = this_._internal_state_text();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TripLeg.Admin.state_text");
            target = stream->WriteStringMaybeAliased(4, _s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Admin)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TripLeg_Admin::ByteSizeLong(const MessageLite& base) {
          const TripLeg_Admin& this_ = static_cast<const TripLeg_Admin&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TripLeg_Admin::ByteSizeLong() const {
          const TripLeg_Admin& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Admin)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // string country_code = 1;
            if (!this_._internal_country_code().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_country_code());
            }
            // string country_text = 2;
            if (!this_._internal_country_text().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_country_text());
            }
            // string state_code = 3;
            if (!this_._internal_state_code().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_state_code());
            }
            // string state_text = 4;
            if (!this_._internal_state_text().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_state_text());
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TripLeg_Admin::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TripLeg_Admin*>(&to_msg);
  auto& from = static_cast<const TripLeg_Admin&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Admin)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_country_code().empty()) {
    _this->_internal_set_country_code(from._internal_country_code());
  }
  if (!from._internal_country_text().empty()) {
    _this->_internal_set_country_text(from._internal_country_text());
  }
  if (!from._internal_state_code().empty()) {
    _this->_internal_set_state_code(from._internal_state_code());
  }
  if (!from._internal_state_text().empty()) {
    _this->_internal_set_state_text(from._internal_state_text());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Admin::CopyFrom(const TripLeg_Admin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Admin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TripLeg_Admin::InternalSwap(TripLeg_Admin* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.country_code_, &other->_impl_.country_code_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.country_text_, &other->_impl_.country_text_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.state_code_, &other->_impl_.state_code_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.state_text_, &other->_impl_.state_text_, arena);
}

// ===================================================================

class TripLeg_ShapeAttributes::_Internal {
 public:
};

TripLeg_ShapeAttributes::TripLeg_ShapeAttributes(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.ShapeAttributes)
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_ShapeAttributes::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::TripLeg_ShapeAttributes& from_msg)
      : time_{visibility, arena, from.time_},
        _time_cached_byte_size_{0},
        length_{visibility, arena, from.length_},
        _length_cached_byte_size_{0},
        speed_{visibility, arena, from.speed_},
        _speed_cached_byte_size_{0},
        speed_limit_{visibility, arena, from.speed_limit_},
        _speed_limit_cached_byte_size_{0},
        _cached_size_{0} {}

TripLeg_ShapeAttributes::TripLeg_ShapeAttributes(
    ::google::protobuf::Arena* arena,
    const TripLeg_ShapeAttributes& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TripLeg_ShapeAttributes* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.ShapeAttributes)
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_ShapeAttributes::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : time_{visibility, arena},
        _time_cached_byte_size_{0},
        length_{visibility, arena},
        _length_cached_byte_size_{0},
        speed_{visibility, arena},
        _speed_cached_byte_size_{0},
        speed_limit_{visibility, arena},
        _speed_limit_cached_byte_size_{0},
        _cached_size_{0} {}

inline void TripLeg_ShapeAttributes::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
TripLeg_ShapeAttributes::~TripLeg_ShapeAttributes() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.ShapeAttributes)
  SharedDtor(*this);
}
inline void TripLeg_ShapeAttributes::SharedDtor(MessageLite& self) {
  TripLeg_ShapeAttributes& this_ = static_cast<TripLeg_ShapeAttributes&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* TripLeg_ShapeAttributes::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TripLeg_ShapeAttributes(arena);
}
constexpr auto TripLeg_ShapeAttributes::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(TripLeg_ShapeAttributes, _impl_.time_) +
          decltype(TripLeg_ShapeAttributes::_impl_.time_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TripLeg_ShapeAttributes, _impl_.length_) +
          decltype(TripLeg_ShapeAttributes::_impl_.length_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TripLeg_ShapeAttributes, _impl_.speed_) +
          decltype(TripLeg_ShapeAttributes::_impl_.speed_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TripLeg_ShapeAttributes, _impl_.speed_limit_) +
          decltype(TripLeg_ShapeAttributes::_impl_.speed_limit_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(TripLeg_ShapeAttributes), alignof(TripLeg_ShapeAttributes), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&TripLeg_ShapeAttributes::PlacementNew_,
                                 sizeof(TripLeg_ShapeAttributes),
                                 alignof(TripLeg_ShapeAttributes));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<33> TripLeg_ShapeAttributes::_class_data_ = {
    {
        &_TripLeg_ShapeAttributes_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TripLeg_ShapeAttributes::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TripLeg_ShapeAttributes>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TripLeg_ShapeAttributes::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TripLeg_ShapeAttributes>(), &TripLeg_ShapeAttributes::ByteSizeLong,
            &TripLeg_ShapeAttributes::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TripLeg_ShapeAttributes, _impl_._cached_size_),
        true,
    },
    "valhalla.TripLeg.ShapeAttributes",
};
const ::google::protobuf::internal::ClassData* TripLeg_ShapeAttributes::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 4, 0, 0, 2> TripLeg_ShapeAttributes::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967272,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TripLeg_ShapeAttributes>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated uint32 time = 1 [packed = true];
    {::_pbi::TcParser::FastV32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_ShapeAttributes, _impl_.time_)}},
    // repeated uint32 length = 2 [packed = true];
    {::_pbi::TcParser::FastV32P1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_ShapeAttributes, _impl_.length_)}},
    // repeated uint32 speed = 3 [packed = true];
    {::_pbi::TcParser::FastV32P1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_ShapeAttributes, _impl_.speed_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated uint32 speed_limit = 5 [packed = true];
    {::_pbi::TcParser::FastV32P1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_ShapeAttributes, _impl_.speed_limit_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated uint32 time = 1 [packed = true];
    {PROTOBUF_FIELD_OFFSET(TripLeg_ShapeAttributes, _impl_.time_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedUInt32)},
    // repeated uint32 length = 2 [packed = true];
    {PROTOBUF_FIELD_OFFSET(TripLeg_ShapeAttributes, _impl_.length_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedUInt32)},
    // repeated uint32 speed = 3 [packed = true];
    {PROTOBUF_FIELD_OFFSET(TripLeg_ShapeAttributes, _impl_.speed_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedUInt32)},
    // repeated uint32 speed_limit = 5 [packed = true];
    {PROTOBUF_FIELD_OFFSET(TripLeg_ShapeAttributes, _impl_.speed_limit_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedUInt32)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void TripLeg_ShapeAttributes::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.ShapeAttributes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.time_.Clear();
  _impl_.length_.Clear();
  _impl_.speed_.Clear();
  _impl_.speed_limit_.Clear();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TripLeg_ShapeAttributes::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TripLeg_ShapeAttributes& this_ = static_cast<const TripLeg_ShapeAttributes&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TripLeg_ShapeAttributes::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TripLeg_ShapeAttributes& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.ShapeAttributes)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // repeated uint32 time = 1 [packed = true];
          {
            int byte_size = this_._impl_._time_cached_byte_size_.Get();
            if (byte_size > 0) {
              target = stream->WriteUInt32Packed(
                  1, this_._internal_time(), byte_size, target);
            }
          }

          // repeated uint32 length = 2 [packed = true];
          {
            int byte_size = this_._impl_._length_cached_byte_size_.Get();
            if (byte_size > 0) {
              target = stream->WriteUInt32Packed(
                  2, this_._internal_length(), byte_size, target);
            }
          }

          // repeated uint32 speed = 3 [packed = true];
          {
            int byte_size = this_._impl_._speed_cached_byte_size_.Get();
            if (byte_size > 0) {
              target = stream->WriteUInt32Packed(
                  3, this_._internal_speed(), byte_size, target);
            }
          }

          // repeated uint32 speed_limit = 5 [packed = true];
          {
            int byte_size = this_._impl_._speed_limit_cached_byte_size_.Get();
            if (byte_size > 0) {
              target = stream->WriteUInt32Packed(
                  5, this_._internal_speed_limit(), byte_size, target);
            }
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.ShapeAttributes)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TripLeg_ShapeAttributes::ByteSizeLong(const MessageLite& base) {
          const TripLeg_ShapeAttributes& this_ = static_cast<const TripLeg_ShapeAttributes&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TripLeg_ShapeAttributes::ByteSizeLong() const {
          const TripLeg_ShapeAttributes& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.ShapeAttributes)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated uint32 time = 1 [packed = true];
            {
              total_size +=
                  ::_pbi::WireFormatLite::UInt32SizeWithPackedTagSize(
                      this_._internal_time(), 1,
                      this_._impl_._time_cached_byte_size_);
            }
            // repeated uint32 length = 2 [packed = true];
            {
              total_size +=
                  ::_pbi::WireFormatLite::UInt32SizeWithPackedTagSize(
                      this_._internal_length(), 1,
                      this_._impl_._length_cached_byte_size_);
            }
            // repeated uint32 speed = 3 [packed = true];
            {
              total_size +=
                  ::_pbi::WireFormatLite::UInt32SizeWithPackedTagSize(
                      this_._internal_speed(), 1,
                      this_._impl_._speed_cached_byte_size_);
            }
            // repeated uint32 speed_limit = 5 [packed = true];
            {
              total_size +=
                  ::_pbi::WireFormatLite::UInt32SizeWithPackedTagSize(
                      this_._internal_speed_limit(), 1,
                      this_._impl_._speed_limit_cached_byte_size_);
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TripLeg_ShapeAttributes::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TripLeg_ShapeAttributes*>(&to_msg);
  auto& from = static_cast<const TripLeg_ShapeAttributes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.ShapeAttributes)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_time()->MergeFrom(from._internal_time());
  _this->_internal_mutable_length()->MergeFrom(from._internal_length());
  _this->_internal_mutable_speed()->MergeFrom(from._internal_speed());
  _this->_internal_mutable_speed_limit()->MergeFrom(from._internal_speed_limit());
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_ShapeAttributes::CopyFrom(const TripLeg_ShapeAttributes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.ShapeAttributes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TripLeg_ShapeAttributes::InternalSwap(TripLeg_ShapeAttributes* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.time_.InternalSwap(&other->_impl_.time_);
  _impl_.length_.InternalSwap(&other->_impl_.length_);
  _impl_.speed_.InternalSwap(&other->_impl_.speed_);
  _impl_.speed_limit_.InternalSwap(&other->_impl_.speed_limit_);
}

// ===================================================================

class TripLeg_Incident::_Internal {
 public:
  using HasBits =
      decltype(std::declval<TripLeg_Incident>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_._has_bits_);
};

void TripLeg_Incident::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
TripLeg_Incident::TripLeg_Incident(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Incident)
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_Incident::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::TripLeg_Incident& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

TripLeg_Incident::TripLeg_Incident(
    ::google::protobuf::Arena* arena,
    const TripLeg_Incident& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TripLeg_Incident* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.metadata_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::IncidentsTile_Metadata>(
                              arena, *from._impl_.metadata_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, begin_shape_index_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, begin_shape_index_),
           offsetof(Impl_, end_shape_index_) -
               offsetof(Impl_, begin_shape_index_) +
               sizeof(Impl_::end_shape_index_));

  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Incident)
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_Incident::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void TripLeg_Incident::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, metadata_),
           0,
           offsetof(Impl_, end_shape_index_) -
               offsetof(Impl_, metadata_) +
               sizeof(Impl_::end_shape_index_));
}
TripLeg_Incident::~TripLeg_Incident() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Incident)
  SharedDtor(*this);
}
inline void TripLeg_Incident::SharedDtor(MessageLite& self) {
  TripLeg_Incident& this_ = static_cast<TripLeg_Incident&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.metadata_;
  this_._impl_.~Impl_();
}

inline void* TripLeg_Incident::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TripLeg_Incident(arena);
}
constexpr auto TripLeg_Incident::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(TripLeg_Incident),
                                            alignof(TripLeg_Incident));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<26> TripLeg_Incident::_class_data_ = {
    {
        &_TripLeg_Incident_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TripLeg_Incident::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TripLeg_Incident>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TripLeg_Incident::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TripLeg_Incident>(), &TripLeg_Incident::ByteSizeLong,
            &TripLeg_Incident::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_._cached_size_),
        true,
    },
    "valhalla.TripLeg.Incident",
};
const ::google::protobuf::internal::ClassData* TripLeg_Incident::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 0, 2> TripLeg_Incident::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967282,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TripLeg_Incident>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // uint32 end_shape_index = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_.end_shape_index_)}},
    // .valhalla.IncidentsTile.Metadata metadata = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_.metadata_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // uint32 begin_shape_index = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_.begin_shape_index_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .valhalla.IncidentsTile.Metadata metadata = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_.metadata_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // uint32 begin_shape_index = 3;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_.begin_shape_index_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 end_shape_index = 4;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_.end_shape_index_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::IncidentsTile_Metadata>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void TripLeg_Incident::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Incident)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  ::memset(&_impl_.begin_shape_index_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.end_shape_index_) -
      reinterpret_cast<char*>(&_impl_.begin_shape_index_)) + sizeof(_impl_.end_shape_index_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TripLeg_Incident::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TripLeg_Incident& this_ = static_cast<const TripLeg_Incident&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TripLeg_Incident::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TripLeg_Incident& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Incident)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // .valhalla.IncidentsTile.Metadata metadata = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.metadata_, this_._impl_.metadata_->GetCachedSize(), target,
                stream);
          }

          // uint32 begin_shape_index = 3;
          if (this_._internal_begin_shape_index() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                3, this_._internal_begin_shape_index(), target);
          }

          // uint32 end_shape_index = 4;
          if (this_._internal_end_shape_index() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                4, this_._internal_end_shape_index(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Incident)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TripLeg_Incident::ByteSizeLong(const MessageLite& base) {
          const TripLeg_Incident& this_ = static_cast<const TripLeg_Incident&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TripLeg_Incident::ByteSizeLong() const {
          const TripLeg_Incident& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Incident)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // .valhalla.IncidentsTile.Metadata metadata = 1;
            cached_has_bits = this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.metadata_);
            }
          }
           {
            // uint32 begin_shape_index = 3;
            if (this_._internal_begin_shape_index() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_begin_shape_index());
            }
            // uint32 end_shape_index = 4;
            if (this_._internal_end_shape_index() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_end_shape_index());
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TripLeg_Incident::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TripLeg_Incident*>(&to_msg);
  auto& from = static_cast<const TripLeg_Incident&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Incident)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(from._impl_.metadata_ != nullptr);
    if (_this->_impl_.metadata_ == nullptr) {
      _this->_impl_.metadata_ =
          ::google::protobuf::MessageLite::CopyConstruct<::valhalla::IncidentsTile_Metadata>(arena, *from._impl_.metadata_);
    } else {
      _this->_impl_.metadata_->MergeFrom(*from._impl_.metadata_);
    }
  }
  if (from._internal_begin_shape_index() != 0) {
    _this->_impl_.begin_shape_index_ = from._impl_.begin_shape_index_;
  }
  if (from._internal_end_shape_index() != 0) {
    _this->_impl_.end_shape_index_ = from._impl_.end_shape_index_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Incident::CopyFrom(const TripLeg_Incident& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Incident)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TripLeg_Incident::InternalSwap(TripLeg_Incident* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_.end_shape_index_)
      + sizeof(TripLeg_Incident::_impl_.end_shape_index_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Incident, _impl_.metadata_)>(
          reinterpret_cast<char*>(&_impl_.metadata_),
          reinterpret_cast<char*>(&other->_impl_.metadata_));
}

// ===================================================================

class TripLeg_Closure::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::valhalla::TripLeg_Closure, _impl_._oneof_case_);
};

TripLeg_Closure::TripLeg_Closure(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Closure)
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_Closure::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::TripLeg_Closure& from_msg)
      : has_begin_shape_index_{},
        has_end_shape_index_{},
        _cached_size_{0},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

TripLeg_Closure::TripLeg_Closure(
    ::google::protobuf::Arena* arena,
    const TripLeg_Closure& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TripLeg_Closure* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  switch (has_begin_shape_index_case()) {
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET:
      break;
      case kBeginShapeIndex:
        _impl_.has_begin_shape_index_.begin_shape_index_ = from._impl_.has_begin_shape_index_.begin_shape_index_;
        break;
  }
  switch (has_end_shape_index_case()) {
    case HAS_END_SHAPE_INDEX_NOT_SET:
      break;
      case kEndShapeIndex:
        _impl_.has_end_shape_index_.end_shape_index_ = from._impl_.has_end_shape_index_.end_shape_index_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Closure)
}
inline PROTOBUF_NDEBUG_INLINE TripLeg_Closure::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : has_begin_shape_index_{},
        has_end_shape_index_{},
        _cached_size_{0},
        _oneof_case_{} {}

inline void TripLeg_Closure::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
TripLeg_Closure::~TripLeg_Closure() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Closure)
  SharedDtor(*this);
}
inline void TripLeg_Closure::SharedDtor(MessageLite& self) {
  TripLeg_Closure& this_ = static_cast<TripLeg_Closure&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  if (this_.has_has_begin_shape_index()) {
    this_.clear_has_begin_shape_index();
  }
  if (this_.has_has_end_shape_index()) {
    this_.clear_has_end_shape_index();
  }
  this_._impl_.~Impl_();
}

void TripLeg_Closure::clear_has_begin_shape_index() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Closure)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      // No need to clear
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}

void TripLeg_Closure::clear_has_end_shape_index() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Closure)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_end_shape_index_case()) {
    case kEndShapeIndex: {
      // No need to clear
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_END_SHAPE_INDEX_NOT_SET;
}


inline void* TripLeg_Closure::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TripLeg_Closure(arena);
}
constexpr auto TripLeg_Closure::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(TripLeg_Closure),
                                            alignof(TripLeg_Closure));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<25> TripLeg_Closure::_class_data_ = {
    {
        &_TripLeg_Closure_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TripLeg_Closure::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TripLeg_Closure>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TripLeg_Closure::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TripLeg_Closure>(), &TripLeg_Closure::ByteSizeLong,
            &TripLeg_Closure::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TripLeg_Closure, _impl_._cached_size_),
        true,
    },
    "valhalla.TripLeg.Closure",
};
const ::google::protobuf::internal::ClassData* TripLeg_Closure::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 2, 0, 0, 2> TripLeg_Closure::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TripLeg_Closure>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 begin_shape_index = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Closure, _impl_.has_begin_shape_index_.begin_shape_index_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // uint32 end_shape_index = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg_Closure, _impl_.has_end_shape_index_.end_shape_index_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void TripLeg_Closure::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Closure)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_has_begin_shape_index();
  clear_has_end_shape_index();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TripLeg_Closure::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TripLeg_Closure& this_ = static_cast<const TripLeg_Closure&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TripLeg_Closure::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TripLeg_Closure& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Closure)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // uint32 begin_shape_index = 1;
          if (this_.has_begin_shape_index_case() == kBeginShapeIndex) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                1, this_._internal_begin_shape_index(), target);
          }

          // uint32 end_shape_index = 2;
          if (this_.has_end_shape_index_case() == kEndShapeIndex) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                2, this_._internal_end_shape_index(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Closure)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TripLeg_Closure::ByteSizeLong(const MessageLite& base) {
          const TripLeg_Closure& this_ = static_cast<const TripLeg_Closure&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TripLeg_Closure::ByteSizeLong() const {
          const TripLeg_Closure& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Closure)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          switch (this_.has_begin_shape_index_case()) {
            // uint32 begin_shape_index = 1;
            case kBeginShapeIndex: {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_begin_shape_index());
              break;
            }
            case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
              break;
            }
          }
          switch (this_.has_end_shape_index_case()) {
            // uint32 end_shape_index = 2;
            case kEndShapeIndex: {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_end_shape_index());
              break;
            }
            case HAS_END_SHAPE_INDEX_NOT_SET: {
              break;
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TripLeg_Closure::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TripLeg_Closure*>(&to_msg);
  auto& from = static_cast<const TripLeg_Closure&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Closure)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_begin_shape_index();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kBeginShapeIndex: {
        _this->_impl_.has_begin_shape_index_.begin_shape_index_ = from._impl_.has_begin_shape_index_.begin_shape_index_;
        break;
      }
      case HAS_BEGIN_SHAPE_INDEX_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_end_shape_index();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kEndShapeIndex: {
        _this->_impl_.has_end_shape_index_.end_shape_index_ = from._impl_.has_end_shape_index_.end_shape_index_;
        break;
      }
      case HAS_END_SHAPE_INDEX_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Closure::CopyFrom(const TripLeg_Closure& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Closure)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TripLeg_Closure::InternalSwap(TripLeg_Closure* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.has_begin_shape_index_, other->_impl_.has_begin_shape_index_);
  swap(_impl_.has_end_shape_index_, other->_impl_.has_end_shape_index_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

// ===================================================================

class TripLeg::_Internal {
 public:
  using HasBits =
      decltype(std::declval<TripLeg>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(TripLeg, _impl_._has_bits_);
};

void TripLeg::clear_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.location_.Clear();
}
void TripLeg::clear_bbox() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.bbox_ != nullptr) _impl_.bbox_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TripLeg::clear_summary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.summary_ != nullptr) _impl_.summary_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void TripLeg::clear_level_changes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_changes_.Clear();
}
TripLeg::TripLeg(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg)
}
inline PROTOBUF_NDEBUG_INLINE TripLeg::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::TripLeg& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        location_{visibility, arena, from.location_},
        node_{visibility, arena, from.node_},
        admin_{visibility, arena, from.admin_},
        incidents_{visibility, arena, from.incidents_},
        algorithms_{visibility, arena, from.algorithms_},
        closures_{visibility, arena, from.closures_},
        level_changes_{visibility, arena, from.level_changes_},
        shape_(arena, from.shape_) {}

TripLeg::TripLeg(
    ::google::protobuf::Arena* arena,
    const TripLeg& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TripLeg* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.bbox_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::BoundingBox>(
                              arena, *from._impl_.bbox_)
                        : nullptr;
  _impl_.shape_attributes_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TripLeg_ShapeAttributes>(
                              arena, *from._impl_.shape_attributes_)
                        : nullptr;
  _impl_.summary_ = (cached_has_bits & 0x00000004u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::Summary>(
                              arena, *from._impl_.summary_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, osm_changeset_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, osm_changeset_),
           offsetof(Impl_, leg_count_) -
               offsetof(Impl_, osm_changeset_) +
               sizeof(Impl_::leg_count_));

  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg)
}
inline PROTOBUF_NDEBUG_INLINE TripLeg::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        location_{visibility, arena},
        node_{visibility, arena},
        admin_{visibility, arena},
        incidents_{visibility, arena},
        algorithms_{visibility, arena},
        closures_{visibility, arena},
        level_changes_{visibility, arena},
        shape_(arena) {}

inline void TripLeg::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, bbox_),
           0,
           offsetof(Impl_, leg_count_) -
               offsetof(Impl_, bbox_) +
               sizeof(Impl_::leg_count_));
}
TripLeg::~TripLeg() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg)
  SharedDtor(*this);
}
inline void TripLeg::SharedDtor(MessageLite& self) {
  TripLeg& this_ = static_cast<TripLeg&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.shape_.Destroy();
  delete this_._impl_.bbox_;
  delete this_._impl_.shape_attributes_;
  delete this_._impl_.summary_;
  this_._impl_.~Impl_();
}

inline void* TripLeg::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TripLeg(arena);
}
constexpr auto TripLeg::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.location_) +
          decltype(TripLeg::_impl_.location_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.node_) +
          decltype(TripLeg::_impl_.node_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.admin_) +
          decltype(TripLeg::_impl_.admin_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.incidents_) +
          decltype(TripLeg::_impl_.incidents_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.algorithms_) +
          decltype(TripLeg::_impl_.algorithms_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.closures_) +
          decltype(TripLeg::_impl_.closures_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.level_changes_) +
          decltype(TripLeg::_impl_.level_changes_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(TripLeg), alignof(TripLeg), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&TripLeg::PlacementNew_,
                                 sizeof(TripLeg),
                                 alignof(TripLeg));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<17> TripLeg::_class_data_ = {
    {
        &_TripLeg_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TripLeg::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TripLeg>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TripLeg::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TripLeg>(), &TripLeg::ByteSizeLong,
            &TripLeg::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TripLeg, _impl_._cached_size_),
        true,
    },
    "valhalla.TripLeg",
};
const ::google::protobuf::internal::ClassData* TripLeg::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 15, 9, 48, 2> TripLeg::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TripLeg, _impl_._has_bits_),
    0, // no _extensions_
    15, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294934528,  // skipmap
    offsetof(decltype(_table_), field_entries),
    15,  // num_field_entries
    9,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TripLeg>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // uint64 osm_changeset = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.osm_changeset_)}},
    // uint64 trip_id = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.trip_id_)}},
    // uint32 leg_id = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.leg_id_)}},
    // uint32 leg_count = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.leg_count_)}},
    // repeated .valhalla.Location location = 5;
    {::_pbi::TcParser::FastMtR1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.location_)}},
    // repeated .valhalla.TripLeg.Node node = 6;
    {::_pbi::TcParser::FastMtR1,
     {50, 63, 1, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.node_)}},
    // repeated .valhalla.TripLeg.Admin admin = 7;
    {::_pbi::TcParser::FastMtR1,
     {58, 63, 2, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.admin_)}},
    // string shape = 8;
    {::_pbi::TcParser::FastUS1,
     {66, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.shape_)}},
    // .valhalla.BoundingBox bbox = 9;
    {::_pbi::TcParser::FastMtS1,
     {74, 0, 3, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.bbox_)}},
    // .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
    {::_pbi::TcParser::FastMtS1,
     {82, 1, 4, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.shape_attributes_)}},
    // repeated .valhalla.TripLeg.Incident incidents = 11;
    {::_pbi::TcParser::FastMtR1,
     {90, 63, 5, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.incidents_)}},
    // repeated string algorithms = 12;
    {::_pbi::TcParser::FastUR1,
     {98, 63, 0, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.algorithms_)}},
    // repeated .valhalla.TripLeg.Closure closures = 13;
    {::_pbi::TcParser::FastMtR1,
     {106, 63, 6, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.closures_)}},
    // .valhalla.Summary summary = 14;
    {::_pbi::TcParser::FastMtS1,
     {114, 2, 7, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.summary_)}},
    // repeated .valhalla.LevelChange level_changes = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 8, PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.level_changes_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint64 osm_changeset = 1;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.osm_changeset_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
    // uint64 trip_id = 2;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.trip_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
    // uint32 leg_id = 3;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.leg_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 leg_count = 4;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.leg_count_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // repeated .valhalla.Location location = 5;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.location_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .valhalla.TripLeg.Node node = 6;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.node_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .valhalla.TripLeg.Admin admin = 7;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.admin_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // string shape = 8;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.shape_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .valhalla.BoundingBox bbox = 9;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.bbox_), _Internal::kHasBitsOffset + 0, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.shape_attributes_), _Internal::kHasBitsOffset + 1, 4,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .valhalla.TripLeg.Incident incidents = 11;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.incidents_), -1, 5,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated string algorithms = 12;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.algorithms_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
    // repeated .valhalla.TripLeg.Closure closures = 13;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.closures_), -1, 6,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // .valhalla.Summary summary = 14;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.summary_), _Internal::kHasBitsOffset + 2, 7,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .valhalla.LevelChange level_changes = 15;
    {PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.level_changes_), -1, 8,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::Location>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_Node>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_Admin>()},
    {::_pbi::TcParser::GetTable<::valhalla::BoundingBox>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_ShapeAttributes>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_Incident>()},
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg_Closure>()},
    {::_pbi::TcParser::GetTable<::valhalla::Summary>()},
    {::_pbi::TcParser::GetTable<::valhalla::LevelChange>()},
  }}, {{
    "\20\0\0\0\0\0\0\0\5\0\0\0\12\0\0\0"
    "valhalla.TripLeg"
    "shape"
    "algorithms"
  }},
};

PROTOBUF_NOINLINE void TripLeg::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.location_.Clear();
  _impl_.node_.Clear();
  _impl_.admin_.Clear();
  _impl_.incidents_.Clear();
  _impl_.algorithms_.Clear();
  _impl_.closures_.Clear();
  _impl_.level_changes_.Clear();
  _impl_.shape_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.bbox_ != nullptr);
      _impl_.bbox_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.shape_attributes_ != nullptr);
      _impl_.shape_attributes_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.summary_ != nullptr);
      _impl_.summary_->Clear();
    }
  }
  ::memset(&_impl_.osm_changeset_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.leg_count_) -
      reinterpret_cast<char*>(&_impl_.osm_changeset_)) + sizeof(_impl_.leg_count_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TripLeg::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TripLeg& this_ = static_cast<const TripLeg&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TripLeg::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TripLeg& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // uint64 osm_changeset = 1;
          if (this_._internal_osm_changeset() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
                1, this_._internal_osm_changeset(), target);
          }

          // uint64 trip_id = 2;
          if (this_._internal_trip_id() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
                2, this_._internal_trip_id(), target);
          }

          // uint32 leg_id = 3;
          if (this_._internal_leg_id() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                3, this_._internal_leg_id(), target);
          }

          // uint32 leg_count = 4;
          if (this_._internal_leg_count() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                4, this_._internal_leg_count(), target);
          }

          // repeated .valhalla.Location location = 5;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_location_size());
               i < n; i++) {
            const auto& repfield = this_._internal_location().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    5, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .valhalla.TripLeg.Node node = 6;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_node_size());
               i < n; i++) {
            const auto& repfield = this_._internal_node().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    6, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .valhalla.TripLeg.Admin admin = 7;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_admin_size());
               i < n; i++) {
            const auto& repfield = this_._internal_admin().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    7, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // string shape = 8;
          if (!this_._internal_shape().empty()) {
            const std::string& _s = this_._internal_shape();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TripLeg.shape");
            target = stream->WriteStringMaybeAliased(8, _s, target);
          }

          cached_has_bits = this_._impl_._has_bits_[0];
          // .valhalla.BoundingBox bbox = 9;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                9, *this_._impl_.bbox_, this_._impl_.bbox_->GetCachedSize(), target,
                stream);
          }

          // .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                10, *this_._impl_.shape_attributes_, this_._impl_.shape_attributes_->GetCachedSize(), target,
                stream);
          }

          // repeated .valhalla.TripLeg.Incident incidents = 11;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_incidents_size());
               i < n; i++) {
            const auto& repfield = this_._internal_incidents().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    11, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated string algorithms = 12;
          for (int i = 0, n = this_._internal_algorithms_size(); i < n; ++i) {
            const auto& s = this_._internal_algorithms().Get(i);
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TripLeg.algorithms");
            target = stream->WriteString(12, s, target);
          }

          // repeated .valhalla.TripLeg.Closure closures = 13;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_closures_size());
               i < n; i++) {
            const auto& repfield = this_._internal_closures().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    13, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // .valhalla.Summary summary = 14;
          if (cached_has_bits & 0x00000004u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                14, *this_._impl_.summary_, this_._impl_.summary_->GetCachedSize(), target,
                stream);
          }

          // repeated .valhalla.LevelChange level_changes = 15;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_level_changes_size());
               i < n; i++) {
            const auto& repfield = this_._internal_level_changes().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    15, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TripLeg::ByteSizeLong(const MessageLite& base) {
          const TripLeg& this_ = static_cast<const TripLeg&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TripLeg::ByteSizeLong() const {
          const TripLeg& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .valhalla.Location location = 5;
            {
              total_size += 1UL * this_._internal_location_size();
              for (const auto& msg : this_._internal_location()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .valhalla.TripLeg.Node node = 6;
            {
              total_size += 1UL * this_._internal_node_size();
              for (const auto& msg : this_._internal_node()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .valhalla.TripLeg.Admin admin = 7;
            {
              total_size += 1UL * this_._internal_admin_size();
              for (const auto& msg : this_._internal_admin()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .valhalla.TripLeg.Incident incidents = 11;
            {
              total_size += 1UL * this_._internal_incidents_size();
              for (const auto& msg : this_._internal_incidents()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated string algorithms = 12;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_algorithms().size());
              for (int i = 0, n = this_._internal_algorithms().size(); i < n; ++i) {
                total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
                    this_._internal_algorithms().Get(i));
              }
            }
            // repeated .valhalla.TripLeg.Closure closures = 13;
            {
              total_size += 1UL * this_._internal_closures_size();
              for (const auto& msg : this_._internal_closures()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .valhalla.LevelChange level_changes = 15;
            {
              total_size += 1UL * this_._internal_level_changes_size();
              for (const auto& msg : this_._internal_level_changes()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
           {
            // string shape = 8;
            if (!this_._internal_shape().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_shape());
            }
          }
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000007u) {
            // .valhalla.BoundingBox bbox = 9;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.bbox_);
            }
            // .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.shape_attributes_);
            }
            // .valhalla.Summary summary = 14;
            if (cached_has_bits & 0x00000004u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.summary_);
            }
          }
           {
            // uint64 osm_changeset = 1;
            if (this_._internal_osm_changeset() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
                  this_._internal_osm_changeset());
            }
            // uint64 trip_id = 2;
            if (this_._internal_trip_id() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
                  this_._internal_trip_id());
            }
            // uint32 leg_id = 3;
            if (this_._internal_leg_id() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_leg_id());
            }
            // uint32 leg_count = 4;
            if (this_._internal_leg_count() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_leg_count());
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TripLeg::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TripLeg*>(&to_msg);
  auto& from = static_cast<const TripLeg&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_location()->MergeFrom(
      from._internal_location());
  _this->_internal_mutable_node()->MergeFrom(
      from._internal_node());
  _this->_internal_mutable_admin()->MergeFrom(
      from._internal_admin());
  _this->_internal_mutable_incidents()->MergeFrom(
      from._internal_incidents());
  _this->_internal_mutable_algorithms()->MergeFrom(from._internal_algorithms());
  _this->_internal_mutable_closures()->MergeFrom(
      from._internal_closures());
  _this->_internal_mutable_level_changes()->MergeFrom(
      from._internal_level_changes());
  if (!from._internal_shape().empty()) {
    _this->_internal_set_shape(from._internal_shape());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.bbox_ != nullptr);
      if (_this->_impl_.bbox_ == nullptr) {
        _this->_impl_.bbox_ =
            ::google::protobuf::MessageLite::CopyConstruct<::valhalla::BoundingBox>(arena, *from._impl_.bbox_);
      } else {
        _this->_impl_.bbox_->MergeFrom(*from._impl_.bbox_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.shape_attributes_ != nullptr);
      if (_this->_impl_.shape_attributes_ == nullptr) {
        _this->_impl_.shape_attributes_ =
            ::google::protobuf::MessageLite::CopyConstruct<::valhalla::TripLeg_ShapeAttributes>(arena, *from._impl_.shape_attributes_);
      } else {
        _this->_impl_.shape_attributes_->MergeFrom(*from._impl_.shape_attributes_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(from._impl_.summary_ != nullptr);
      if (_this->_impl_.summary_ == nullptr) {
        _this->_impl_.summary_ =
            ::google::protobuf::MessageLite::CopyConstruct<::valhalla::Summary>(arena, *from._impl_.summary_);
      } else {
        _this->_impl_.summary_->MergeFrom(*from._impl_.summary_);
      }
    }
  }
  if (from._internal_osm_changeset() != 0) {
    _this->_impl_.osm_changeset_ = from._impl_.osm_changeset_;
  }
  if (from._internal_trip_id() != 0) {
    _this->_impl_.trip_id_ = from._impl_.trip_id_;
  }
  if (from._internal_leg_id() != 0) {
    _this->_impl_.leg_id_ = from._impl_.leg_id_;
  }
  if (from._internal_leg_count() != 0) {
    _this->_impl_.leg_count_ = from._impl_.leg_count_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg::CopyFrom(const TripLeg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TripLeg::InternalSwap(TripLeg* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.location_.InternalSwap(&other->_impl_.location_);
  _impl_.node_.InternalSwap(&other->_impl_.node_);
  _impl_.admin_.InternalSwap(&other->_impl_.admin_);
  _impl_.incidents_.InternalSwap(&other->_impl_.incidents_);
  _impl_.algorithms_.InternalSwap(&other->_impl_.algorithms_);
  _impl_.closures_.InternalSwap(&other->_impl_.closures_);
  _impl_.level_changes_.InternalSwap(&other->_impl_.level_changes_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.shape_, &other->_impl_.shape_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.leg_count_)
      + sizeof(TripLeg::_impl_.leg_count_)
      - PROTOBUF_FIELD_OFFSET(TripLeg, _impl_.bbox_)>(
          reinterpret_cast<char*>(&_impl_.bbox_),
          reinterpret_cast<char*>(&other->_impl_.bbox_));
}

// ===================================================================

class TripRoute::_Internal {
 public:
};

TripRoute::TripRoute(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TripRoute)
}
inline PROTOBUF_NDEBUG_INLINE TripRoute::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::TripRoute& from_msg)
      : legs_{visibility, arena, from.legs_},
        _cached_size_{0} {}

TripRoute::TripRoute(
    ::google::protobuf::Arena* arena,
    const TripRoute& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TripRoute* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:valhalla.TripRoute)
}
inline PROTOBUF_NDEBUG_INLINE TripRoute::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : legs_{visibility, arena},
        _cached_size_{0} {}

inline void TripRoute::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
TripRoute::~TripRoute() {
  // @@protoc_insertion_point(destructor:valhalla.TripRoute)
  SharedDtor(*this);
}
inline void TripRoute::SharedDtor(MessageLite& self) {
  TripRoute& this_ = static_cast<TripRoute&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* TripRoute::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TripRoute(arena);
}
constexpr auto TripRoute::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(TripRoute, _impl_.legs_) +
          decltype(TripRoute::_impl_.legs_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(TripRoute), alignof(TripRoute), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&TripRoute::PlacementNew_,
                                 sizeof(TripRoute),
                                 alignof(TripRoute));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<19> TripRoute::_class_data_ = {
    {
        &_TripRoute_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TripRoute::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TripRoute>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TripRoute::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TripRoute>(), &TripRoute::ByteSizeLong,
            &TripRoute::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TripRoute, _impl_._cached_size_),
        true,
    },
    "valhalla.TripRoute",
};
const ::google::protobuf::internal::ClassData* TripRoute::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2> TripRoute::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TripRoute>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .valhalla.TripLeg legs = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(TripRoute, _impl_.legs_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .valhalla.TripLeg legs = 1;
    {PROTOBUF_FIELD_OFFSET(TripRoute, _impl_.legs_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::TripLeg>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void TripRoute::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripRoute)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.legs_.Clear();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TripRoute::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TripRoute& this_ = static_cast<const TripRoute&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TripRoute::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TripRoute& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripRoute)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // repeated .valhalla.TripLeg legs = 1;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_legs_size());
               i < n; i++) {
            const auto& repfield = this_._internal_legs().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    1, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripRoute)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TripRoute::ByteSizeLong(const MessageLite& base) {
          const TripRoute& this_ = static_cast<const TripRoute&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TripRoute::ByteSizeLong() const {
          const TripRoute& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TripRoute)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .valhalla.TripLeg legs = 1;
            {
              total_size += 1UL * this_._internal_legs_size();
              for (const auto& msg : this_._internal_legs()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TripRoute::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TripRoute*>(&to_msg);
  auto& from = static_cast<const TripRoute&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripRoute)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_legs()->MergeFrom(
      from._internal_legs());
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripRoute::CopyFrom(const TripRoute& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripRoute)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TripRoute::InternalSwap(TripRoute* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.legs_.InternalSwap(&other->_impl_.legs_);
}

// ===================================================================

class Trip::_Internal {
 public:
};

Trip::Trip(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.Trip)
}
inline PROTOBUF_NDEBUG_INLINE Trip::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::Trip& from_msg)
      : routes_{visibility, arena, from.routes_},
        _cached_size_{0} {}

Trip::Trip(
    ::google::protobuf::Arena* arena,
    const Trip& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Trip* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:valhalla.Trip)
}
inline PROTOBUF_NDEBUG_INLINE Trip::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : routes_{visibility, arena},
        _cached_size_{0} {}

inline void Trip::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
Trip::~Trip() {
  // @@protoc_insertion_point(destructor:valhalla.Trip)
  SharedDtor(*this);
}
inline void Trip::SharedDtor(MessageLite& self) {
  Trip& this_ = static_cast<Trip&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* Trip::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) Trip(arena);
}
constexpr auto Trip::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(Trip, _impl_.routes_) +
          decltype(Trip::_impl_.routes_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(Trip), alignof(Trip), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&Trip::PlacementNew_,
                                 sizeof(Trip),
                                 alignof(Trip));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<14> Trip::_class_data_ = {
    {
        &_Trip_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &Trip::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<Trip>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &Trip::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<Trip>(), &Trip::ByteSizeLong,
            &Trip::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(Trip, _impl_._cached_size_),
        true,
    },
    "valhalla.Trip",
};
const ::google::protobuf::internal::ClassData* Trip::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2> Trip::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::Trip>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .valhalla.TripRoute routes = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(Trip, _impl_.routes_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .valhalla.TripRoute routes = 1;
    {PROTOBUF_FIELD_OFFSET(Trip, _impl_.routes_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::TripRoute>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void Trip::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Trip)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.routes_.Clear();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Trip::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Trip& this_ = static_cast<const Trip&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Trip::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Trip& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.Trip)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // repeated .valhalla.TripRoute routes = 1;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_routes_size());
               i < n; i++) {
            const auto& repfield = this_._internal_routes().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    1, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.Trip)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Trip::ByteSizeLong(const MessageLite& base) {
          const Trip& this_ = static_cast<const Trip&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Trip::ByteSizeLong() const {
          const Trip& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.Trip)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .valhalla.TripRoute routes = 1;
            {
              total_size += 1UL * this_._internal_routes_size();
              for (const auto& msg : this_._internal_routes()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void Trip::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Trip*>(&to_msg);
  auto& from = static_cast<const Trip&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Trip)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_routes()->MergeFrom(
      from._internal_routes());
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Trip::CopyFrom(const Trip& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Trip)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Trip::InternalSwap(Trip* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.routes_.InternalSwap(&other->_impl_.routes_);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace valhalla
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
