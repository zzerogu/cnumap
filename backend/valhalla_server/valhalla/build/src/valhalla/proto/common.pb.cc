// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: common.proto
// Protobuf C++ Version: 5.29.1

#include "common.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/io/zero_copy_stream_impl_lite.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace valhalla {

inline constexpr TurnLane::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : directions_mask_{0u},
        state_{static_cast< ::valhalla::TurnLane_State >(0)},
        active_direction_{0u},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR TurnLane::TurnLane(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TurnLaneDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TurnLaneDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TurnLaneDefaultTypeInternal() {}
  union {
    TurnLane _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TurnLaneDefaultTypeInternal _TurnLane_default_instance_;

inline constexpr TaggedValue::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : value_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        type_{static_cast< ::valhalla::TaggedValue_Type >(0)},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR TaggedValue::TaggedValue(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TaggedValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TaggedValueDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TaggedValueDefaultTypeInternal() {}
  union {
    TaggedValue _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TaggedValueDefaultTypeInternal _TaggedValue_default_instance_;

inline constexpr SearchFilter::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : exclude_tunnel_{false},
        exclude_bridge_{false},
        exclude_ramp_{false},
        exclude_toll_{false},
        exclude_ferry_{false},
        has_min_road_class_{},
        has_max_road_class_{},
        has_exclude_closures_{},
        has_level_{},
        _cached_size_{0},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR SearchFilter::SearchFilter(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SearchFilterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SearchFilterDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SearchFilterDefaultTypeInternal() {}
  union {
    SearchFilter _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SearchFilterDefaultTypeInternal _SearchFilter_default_instance_;

inline constexpr Pronunciation::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : value_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        alphabet_{static_cast< ::valhalla::Pronunciation_Alphabet >(0)},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Pronunciation::Pronunciation(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PronunciationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PronunciationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PronunciationDefaultTypeInternal() {}
  union {
    Pronunciation _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PronunciationDefaultTypeInternal _Pronunciation_default_instance_;

inline constexpr LevelChange::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : shape_index_{0u},
        level_{0},
        precision_{0u},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR LevelChange::LevelChange(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LevelChangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LevelChangeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LevelChangeDefaultTypeInternal() {}
  union {
    LevelChange _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LevelChangeDefaultTypeInternal _LevelChange_default_instance_;

inline constexpr LatLng::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : has_lat_{},
        has_lng_{},
        _cached_size_{0},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR LatLng::LatLng(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LatLngDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LatLngDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LatLngDefaultTypeInternal() {}
  union {
    LatLng _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LatLngDefaultTypeInternal _LatLng_default_instance_;

inline constexpr BikeShareStationInfo::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        ref_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        network_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        operator__(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        capacity_{0u},
        rent_cost_{0},
        return_cost_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR BikeShareStationInfo::BikeShareStationInfo(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BikeShareStationInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BikeShareStationInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BikeShareStationInfoDefaultTypeInternal() {}
  union {
    BikeShareStationInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BikeShareStationInfoDefaultTypeInternal _BikeShareStationInfo_default_instance_;

inline constexpr TransitStationInfo::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        onestop_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        ll_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR TransitStationInfo::TransitStationInfo(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TransitStationInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransitStationInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransitStationInfoDefaultTypeInternal() {}
  union {
    TransitStationInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransitStationInfoDefaultTypeInternal _TransitStationInfo_default_instance_;

inline constexpr TransitPlatformInfo::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        onestop_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        arrival_date_time_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        departure_date_time_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        station_onestop_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        station_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        ll_{nullptr},
        type_{static_cast< ::valhalla::TransitPlatformInfo_Type >(0)},
        assumed_schedule_{false} {}

template <typename>
PROTOBUF_CONSTEXPR TransitPlatformInfo::TransitPlatformInfo(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TransitPlatformInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransitPlatformInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransitPlatformInfoDefaultTypeInternal() {}
  union {
    TransitPlatformInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransitPlatformInfoDefaultTypeInternal _TransitPlatformInfo_default_instance_;

inline constexpr TransitEgressInfo::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        onestop_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        ll_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR TransitEgressInfo::TransitEgressInfo(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TransitEgressInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransitEgressInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransitEgressInfoDefaultTypeInternal() {}
  union {
    TransitEgressInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransitEgressInfoDefaultTypeInternal _TransitEgressInfo_default_instance_;

inline constexpr StreetName::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        value_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        pronunciation_{nullptr},
        is_route_number_{false},
        language_tag_{static_cast< ::valhalla::LanguageTag >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR StreetName::StreetName(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct StreetNameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreetNameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreetNameDefaultTypeInternal() {}
  union {
    StreetName _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreetNameDefaultTypeInternal _StreetName_default_instance_;

inline constexpr RouteLandmark::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        lat_lng_{nullptr},
        type_{static_cast< ::valhalla::RouteLandmark_Type >(0)},
        right_{false},
        distance_{0} {}

template <typename>
PROTOBUF_CONSTEXPR RouteLandmark::RouteLandmark(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RouteLandmarkDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RouteLandmarkDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RouteLandmarkDefaultTypeInternal() {}
  union {
    RouteLandmark _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RouteLandmarkDefaultTypeInternal _RouteLandmark_default_instance_;

inline constexpr PathEdge::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        names_{},
        ll_{nullptr},
        graph_id_{::uint64_t{0u}},
        percent_along_{0},
        distance_{0},
        side_of_street_{static_cast< ::valhalla::Location_SideOfStreet >(0)},
        begin_node_{false},
        end_node_{false},
        outbound_reach_{0},
        inbound_reach_{0},
        heading_{0} {}

template <typename>
PROTOBUF_CONSTEXPR PathEdge::PathEdge(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PathEdgeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PathEdgeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PathEdgeDefaultTypeInternal() {}
  union {
    PathEdge _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PathEdgeDefaultTypeInternal _PathEdge_default_instance_;

inline constexpr BoundingBox::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        min_ll_{nullptr},
        max_ll_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR BoundingBox::BoundingBox(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BoundingBoxDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BoundingBoxDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BoundingBoxDefaultTypeInternal() {}
  union {
    BoundingBox _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BoundingBoxDefaultTypeInternal _BoundingBox_default_instance_;

inline constexpr TransitRouteInfo::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : transit_stops_{},
        onestop_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        short_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        long_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        headsign_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        description_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        operator_onestop_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        operator_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        operator_url_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        block_id_{0u},
        trip_id_{0u},
        color_{0u},
        text_color_{0u},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR TransitRouteInfo::TransitRouteInfo(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TransitRouteInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransitRouteInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransitRouteInfoDefaultTypeInternal() {}
  union {
    TransitRouteInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransitRouteInfoDefaultTypeInternal _TransitRouteInfo_default_instance_;

inline constexpr Summary::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        bbox_{nullptr},
        time_{0},
        length_{0},
        has_time_restrictions_{false},
        has_toll_{false},
        has_ferry_{false},
        has_highway_{false} {}

template <typename>
PROTOBUF_CONSTEXPR Summary::Summary(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SummaryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SummaryDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SummaryDefaultTypeInternal() {}
  union {
    Summary _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SummaryDefaultTypeInternal _Summary_default_instance_;

inline constexpr Correlation::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        edges_{},
        filtered_edges_{},
        projected_ll_{nullptr},
        original_index_{0u},
        leg_shape_index_{0u},
        distance_from_leg_origin_{0},
        route_index_{0u},
        waypoint_index_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR Correlation::Correlation(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CorrelationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CorrelationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CorrelationDefaultTypeInternal() {}
  union {
    Correlation _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CorrelationDefaultTypeInternal _Correlation_default_instance_;

inline constexpr Location::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        street_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        date_time_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        time_zone_offset_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        time_zone_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        ll_{nullptr},
        display_ll_{nullptr},
        search_filter_{nullptr},
        correlation_{nullptr},
        type_{static_cast< ::valhalla::Location_Type >(0)},
        side_of_street_{static_cast< ::valhalla::Location_SideOfStreet >(0)},
        skip_ranking_candidates_{false},
        preferred_side_{static_cast< ::valhalla::Location_PreferredSide >(0)},
        waiting_secs_{0},
        has_heading_{},
        has_heading_tolerance_{},
        has_node_snap_tolerance_{},
        has_minimum_reachability_{},
        has_radius_{},
        has_accuracy_{},
        has_time_{},
        has_search_cutoff_{},
        has_street_side_tolerance_{},
        has_street_side_max_distance_{},
        has_preferred_layer_{},
        has_street_side_cutoff_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR Location::Location(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LocationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LocationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LocationDefaultTypeInternal() {}
  union {
    Location _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LocationDefaultTypeInternal _Location_default_instance_;
}  // namespace valhalla
namespace valhalla {
PROTOBUF_CONSTINIT const uint32_t RouteLandmark_Type_internal_data_[] = {
    1245184u, 0u, };
bool RouteLandmark_Type_IsValid(int value) {
  return 0 <= value && value <= 18;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    RouteLandmark_Type_strings[19] = {};

static const char RouteLandmark_Type_names[] = {
    "kBank"
    "kBar"
    "kCafe"
    "kCarWash"
    "kCasino"
    "kCinema"
    "kClinic"
    "kFastFood"
    "kFireStation"
    "kFuel"
    "kHospital"
    "kKindergarten"
    "kPharmacy"
    "kPolice"
    "kPostOffice"
    "kPub"
    "kRestaurant"
    "kTheatre"
    "kUnused"
};

static const ::google::protobuf::internal::EnumEntry RouteLandmark_Type_entries[] =
    {
        {{&RouteLandmark_Type_names[0], 5}, 9},
        {{&RouteLandmark_Type_names[5], 4}, 12},
        {{&RouteLandmark_Type_names[9], 5}, 8},
        {{&RouteLandmark_Type_names[14], 8}, 5},
        {{&RouteLandmark_Type_names[22], 7}, 18},
        {{&RouteLandmark_Type_names[29], 7}, 17},
        {{&RouteLandmark_Type_names[36], 7}, 15},
        {{&RouteLandmark_Type_names[43], 9}, 7},
        {{&RouteLandmark_Type_names[52], 12}, 4},
        {{&RouteLandmark_Type_names[64], 5}, 1},
        {{&RouteLandmark_Type_names[69], 9}, 13},
        {{&RouteLandmark_Type_names[78], 13}, 11},
        {{&RouteLandmark_Type_names[91], 9}, 10},
        {{&RouteLandmark_Type_names[100], 7}, 3},
        {{&RouteLandmark_Type_names[107], 11}, 2},
        {{&RouteLandmark_Type_names[118], 4}, 14},
        {{&RouteLandmark_Type_names[122], 11}, 6},
        {{&RouteLandmark_Type_names[133], 8}, 16},
        {{&RouteLandmark_Type_names[141], 7}, 0},
};

static const int RouteLandmark_Type_entries_by_number[] = {
    18,  // 0 -> kUnused
    9,  // 1 -> kFuel
    14,  // 2 -> kPostOffice
    13,  // 3 -> kPolice
    8,  // 4 -> kFireStation
    3,  // 5 -> kCarWash
    16,  // 6 -> kRestaurant
    7,  // 7 -> kFastFood
    2,  // 8 -> kCafe
    0,  // 9 -> kBank
    12,  // 10 -> kPharmacy
    11,  // 11 -> kKindergarten
    1,  // 12 -> kBar
    10,  // 13 -> kHospital
    15,  // 14 -> kPub
    6,  // 15 -> kClinic
    17,  // 16 -> kTheatre
    5,  // 17 -> kCinema
    4,  // 18 -> kCasino
};

const std::string& RouteLandmark_Type_Name(RouteLandmark_Type value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          RouteLandmark_Type_entries, RouteLandmark_Type_entries_by_number,
          19, RouteLandmark_Type_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      RouteLandmark_Type_entries, RouteLandmark_Type_entries_by_number, 19,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : RouteLandmark_Type_strings[idx].get();
}

bool RouteLandmark_Type_Parse(absl::string_view name, RouteLandmark_Type* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      RouteLandmark_Type_entries, 19, name, &int_value);
  if (success) {
    *value = static_cast<RouteLandmark_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr RouteLandmark_Type RouteLandmark::kUnused;
constexpr RouteLandmark_Type RouteLandmark::kFuel;
constexpr RouteLandmark_Type RouteLandmark::kPostOffice;
constexpr RouteLandmark_Type RouteLandmark::kPolice;
constexpr RouteLandmark_Type RouteLandmark::kFireStation;
constexpr RouteLandmark_Type RouteLandmark::kCarWash;
constexpr RouteLandmark_Type RouteLandmark::kRestaurant;
constexpr RouteLandmark_Type RouteLandmark::kFastFood;
constexpr RouteLandmark_Type RouteLandmark::kCafe;
constexpr RouteLandmark_Type RouteLandmark::kBank;
constexpr RouteLandmark_Type RouteLandmark::kPharmacy;
constexpr RouteLandmark_Type RouteLandmark::kKindergarten;
constexpr RouteLandmark_Type RouteLandmark::kBar;
constexpr RouteLandmark_Type RouteLandmark::kHospital;
constexpr RouteLandmark_Type RouteLandmark::kPub;
constexpr RouteLandmark_Type RouteLandmark::kClinic;
constexpr RouteLandmark_Type RouteLandmark::kTheatre;
constexpr RouteLandmark_Type RouteLandmark::kCinema;
constexpr RouteLandmark_Type RouteLandmark::kCasino;
constexpr RouteLandmark_Type RouteLandmark::Type_MIN;
constexpr RouteLandmark_Type RouteLandmark::Type_MAX;
constexpr int RouteLandmark::Type_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t Location_Type_internal_data_[] = {
    262144u, 0u, };
bool Location_Type_IsValid(int value) {
  return 0 <= value && value <= 3;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    Location_Type_strings[4] = {};

static const char Location_Type_names[] = {
    "kBreak"
    "kBreakThrough"
    "kThrough"
    "kVia"
};

static const ::google::protobuf::internal::EnumEntry Location_Type_entries[] =
    {
        {{&Location_Type_names[0], 6}, 0},
        {{&Location_Type_names[6], 13}, 3},
        {{&Location_Type_names[19], 8}, 1},
        {{&Location_Type_names[27], 4}, 2},
};

static const int Location_Type_entries_by_number[] = {
    0,  // 0 -> kBreak
    2,  // 1 -> kThrough
    3,  // 2 -> kVia
    1,  // 3 -> kBreakThrough
};

const std::string& Location_Type_Name(Location_Type value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          Location_Type_entries, Location_Type_entries_by_number,
          4, Location_Type_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      Location_Type_entries, Location_Type_entries_by_number, 4,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : Location_Type_strings[idx].get();
}

bool Location_Type_Parse(absl::string_view name, Location_Type* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      Location_Type_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<Location_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Location_Type Location::kBreak;
constexpr Location_Type Location::kThrough;
constexpr Location_Type Location::kVia;
constexpr Location_Type Location::kBreakThrough;
constexpr Location_Type Location::Type_MIN;
constexpr Location_Type Location::Type_MAX;
constexpr int Location::Type_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t Location_PreferredSide_internal_data_[] = {
    196608u, 0u, };
bool Location_PreferredSide_IsValid(int value) {
  return 0 <= value && value <= 2;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    Location_PreferredSide_strings[3] = {};

static const char Location_PreferredSide_names[] = {
    "either"
    "opposite"
    "same"
};

static const ::google::protobuf::internal::EnumEntry Location_PreferredSide_entries[] =
    {
        {{&Location_PreferredSide_names[0], 6}, 0},
        {{&Location_PreferredSide_names[6], 8}, 2},
        {{&Location_PreferredSide_names[14], 4}, 1},
};

static const int Location_PreferredSide_entries_by_number[] = {
    0,  // 0 -> either
    2,  // 1 -> same
    1,  // 2 -> opposite
};

const std::string& Location_PreferredSide_Name(Location_PreferredSide value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          Location_PreferredSide_entries, Location_PreferredSide_entries_by_number,
          3, Location_PreferredSide_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      Location_PreferredSide_entries, Location_PreferredSide_entries_by_number, 3,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : Location_PreferredSide_strings[idx].get();
}

bool Location_PreferredSide_Parse(absl::string_view name, Location_PreferredSide* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      Location_PreferredSide_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<Location_PreferredSide>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Location_PreferredSide Location::either;
constexpr Location_PreferredSide Location::same;
constexpr Location_PreferredSide Location::opposite;
constexpr Location_PreferredSide Location::PreferredSide_MIN;
constexpr Location_PreferredSide Location::PreferredSide_MAX;
constexpr int Location::PreferredSide_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t Location_SideOfStreet_internal_data_[] = {
    196608u, 0u, };
bool Location_SideOfStreet_IsValid(int value) {
  return 0 <= value && value <= 2;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    Location_SideOfStreet_strings[3] = {};

static const char Location_SideOfStreet_names[] = {
    "kLeft"
    "kNone"
    "kRight"
};

static const ::google::protobuf::internal::EnumEntry Location_SideOfStreet_entries[] =
    {
        {{&Location_SideOfStreet_names[0], 5}, 1},
        {{&Location_SideOfStreet_names[5], 5}, 0},
        {{&Location_SideOfStreet_names[10], 6}, 2},
};

static const int Location_SideOfStreet_entries_by_number[] = {
    1,  // 0 -> kNone
    0,  // 1 -> kLeft
    2,  // 2 -> kRight
};

const std::string& Location_SideOfStreet_Name(Location_SideOfStreet value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          Location_SideOfStreet_entries, Location_SideOfStreet_entries_by_number,
          3, Location_SideOfStreet_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      Location_SideOfStreet_entries, Location_SideOfStreet_entries_by_number, 3,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : Location_SideOfStreet_strings[idx].get();
}

bool Location_SideOfStreet_Parse(absl::string_view name, Location_SideOfStreet* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      Location_SideOfStreet_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<Location_SideOfStreet>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Location_SideOfStreet Location::kNone;
constexpr Location_SideOfStreet Location::kLeft;
constexpr Location_SideOfStreet Location::kRight;
constexpr Location_SideOfStreet Location::SideOfStreet_MIN;
constexpr Location_SideOfStreet Location::SideOfStreet_MAX;
constexpr int Location::SideOfStreet_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t TransitPlatformInfo_Type_internal_data_[] = {
    131072u, 0u, };
bool TransitPlatformInfo_Type_IsValid(int value) {
  return 0 <= value && value <= 1;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    TransitPlatformInfo_Type_strings[2] = {};

static const char TransitPlatformInfo_Type_names[] = {
    "kStation"
    "kStop"
};

static const ::google::protobuf::internal::EnumEntry TransitPlatformInfo_Type_entries[] =
    {
        {{&TransitPlatformInfo_Type_names[0], 8}, 1},
        {{&TransitPlatformInfo_Type_names[8], 5}, 0},
};

static const int TransitPlatformInfo_Type_entries_by_number[] = {
    1,  // 0 -> kStop
    0,  // 1 -> kStation
};

const std::string& TransitPlatformInfo_Type_Name(TransitPlatformInfo_Type value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          TransitPlatformInfo_Type_entries, TransitPlatformInfo_Type_entries_by_number,
          2, TransitPlatformInfo_Type_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      TransitPlatformInfo_Type_entries, TransitPlatformInfo_Type_entries_by_number, 2,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : TransitPlatformInfo_Type_strings[idx].get();
}

bool TransitPlatformInfo_Type_Parse(absl::string_view name, TransitPlatformInfo_Type* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      TransitPlatformInfo_Type_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<TransitPlatformInfo_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr TransitPlatformInfo_Type TransitPlatformInfo::kStop;
constexpr TransitPlatformInfo_Type TransitPlatformInfo::kStation;
constexpr TransitPlatformInfo_Type TransitPlatformInfo::Type_MIN;
constexpr TransitPlatformInfo_Type TransitPlatformInfo::Type_MAX;
constexpr int TransitPlatformInfo::Type_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t Pronunciation_Alphabet_internal_data_[] = {
    327680u, 0u, };
bool Pronunciation_Alphabet_IsValid(int value) {
  return 0 <= value && value <= 4;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    Pronunciation_Alphabet_strings[5] = {};

static const char Pronunciation_Alphabet_names[] = {
    "kIpa"
    "kJeita"
    "kKatakana"
    "kNone"
    "kNtSampa"
};

static const ::google::protobuf::internal::EnumEntry Pronunciation_Alphabet_entries[] =
    {
        {{&Pronunciation_Alphabet_names[0], 4}, 1},
        {{&Pronunciation_Alphabet_names[4], 6}, 3},
        {{&Pronunciation_Alphabet_names[10], 9}, 2},
        {{&Pronunciation_Alphabet_names[19], 5}, 0},
        {{&Pronunciation_Alphabet_names[24], 8}, 4},
};

static const int Pronunciation_Alphabet_entries_by_number[] = {
    3,  // 0 -> kNone
    0,  // 1 -> kIpa
    2,  // 2 -> kKatakana
    1,  // 3 -> kJeita
    4,  // 4 -> kNtSampa
};

const std::string& Pronunciation_Alphabet_Name(Pronunciation_Alphabet value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          Pronunciation_Alphabet_entries, Pronunciation_Alphabet_entries_by_number,
          5, Pronunciation_Alphabet_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      Pronunciation_Alphabet_entries, Pronunciation_Alphabet_entries_by_number, 5,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : Pronunciation_Alphabet_strings[idx].get();
}

bool Pronunciation_Alphabet_Parse(absl::string_view name, Pronunciation_Alphabet* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      Pronunciation_Alphabet_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<Pronunciation_Alphabet>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Pronunciation_Alphabet Pronunciation::kNone;
constexpr Pronunciation_Alphabet Pronunciation::kIpa;
constexpr Pronunciation_Alphabet Pronunciation::kKatakana;
constexpr Pronunciation_Alphabet Pronunciation::kJeita;
constexpr Pronunciation_Alphabet Pronunciation::kNtSampa;
constexpr Pronunciation_Alphabet Pronunciation::Alphabet_MIN;
constexpr Pronunciation_Alphabet Pronunciation::Alphabet_MAX;
constexpr int Pronunciation::Alphabet_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t TurnLane_State_internal_data_[] = {
    196608u, 0u, };
bool TurnLane_State_IsValid(int value) {
  return 0 <= value && value <= 2;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    TurnLane_State_strings[3] = {};

static const char TurnLane_State_names[] = {
    "kActive"
    "kInvalid"
    "kValid"
};

static const ::google::protobuf::internal::EnumEntry TurnLane_State_entries[] =
    {
        {{&TurnLane_State_names[0], 7}, 2},
        {{&TurnLane_State_names[7], 8}, 0},
        {{&TurnLane_State_names[15], 6}, 1},
};

static const int TurnLane_State_entries_by_number[] = {
    1,  // 0 -> kInvalid
    2,  // 1 -> kValid
    0,  // 2 -> kActive
};

const std::string& TurnLane_State_Name(TurnLane_State value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          TurnLane_State_entries, TurnLane_State_entries_by_number,
          3, TurnLane_State_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      TurnLane_State_entries, TurnLane_State_entries_by_number, 3,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : TurnLane_State_strings[idx].get();
}

bool TurnLane_State_Parse(absl::string_view name, TurnLane_State* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      TurnLane_State_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<TurnLane_State>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr TurnLane_State TurnLane::kInvalid;
constexpr TurnLane_State TurnLane::kValid;
constexpr TurnLane_State TurnLane::kActive;
constexpr TurnLane_State TurnLane::State_MIN;
constexpr TurnLane_State TurnLane::State_MAX;
constexpr int TurnLane::State_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t TaggedValue_Type_internal_data_[] = {
    589824u, 64u, 0u, 768u, };
bool TaggedValue_Type_IsValid(int value) {
  return 0 <= value && value <= 50 && ((1688849860264447u >> value) & 1) != 0;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    TaggedValue_Type_strings[11] = {};

static const char TaggedValue_Type_names[] = {
    "kBridge"
    "kBssInfo"
    "kConditionalSpeedLimits"
    "kLandmark"
    "kLayer"
    "kLevel"
    "kLevelRef"
    "kLevels"
    "kNone"
    "kPronunciation"
    "kTunnel"
};

static const ::google::protobuf::internal::EnumEntry TaggedValue_Type_entries[] =
    {
        {{&TaggedValue_Type_names[0], 7}, 50},
        {{&TaggedValue_Type_names[7], 8}, 3},
        {{&TaggedValue_Type_names[15], 23}, 7},
        {{&TaggedValue_Type_names[38], 9}, 6},
        {{&TaggedValue_Type_names[47], 6}, 1},
        {{&TaggedValue_Type_names[53], 6}, 4},
        {{&TaggedValue_Type_names[59], 9}, 5},
        {{&TaggedValue_Type_names[68], 7}, 8},
        {{&TaggedValue_Type_names[75], 5}, 0},
        {{&TaggedValue_Type_names[80], 14}, 2},
        {{&TaggedValue_Type_names[94], 7}, 49},
};

static const int TaggedValue_Type_entries_by_number[] = {
    8,  // 0 -> kNone
    4,  // 1 -> kLayer
    9,  // 2 -> kPronunciation
    1,  // 3 -> kBssInfo
    5,  // 4 -> kLevel
    6,  // 5 -> kLevelRef
    3,  // 6 -> kLandmark
    2,  // 7 -> kConditionalSpeedLimits
    7,  // 8 -> kLevels
    10,  // 49 -> kTunnel
    0,  // 50 -> kBridge
};

const std::string& TaggedValue_Type_Name(TaggedValue_Type value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          TaggedValue_Type_entries, TaggedValue_Type_entries_by_number,
          11, TaggedValue_Type_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      TaggedValue_Type_entries, TaggedValue_Type_entries_by_number, 11,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : TaggedValue_Type_strings[idx].get();
}

bool TaggedValue_Type_Parse(absl::string_view name, TaggedValue_Type* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      TaggedValue_Type_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<TaggedValue_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr TaggedValue_Type TaggedValue::kNone;
constexpr TaggedValue_Type TaggedValue::kLayer;
constexpr TaggedValue_Type TaggedValue::kPronunciation;
constexpr TaggedValue_Type TaggedValue::kBssInfo;
constexpr TaggedValue_Type TaggedValue::kLevel;
constexpr TaggedValue_Type TaggedValue::kLevelRef;
constexpr TaggedValue_Type TaggedValue::kLandmark;
constexpr TaggedValue_Type TaggedValue::kConditionalSpeedLimits;
constexpr TaggedValue_Type TaggedValue::kLevels;
constexpr TaggedValue_Type TaggedValue::kTunnel;
constexpr TaggedValue_Type TaggedValue::kBridge;
constexpr TaggedValue_Type TaggedValue::Type_MIN;
constexpr TaggedValue_Type TaggedValue::Type_MAX;
constexpr int TaggedValue::Type_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t LanguageTag_internal_data_[] = {
    4784128u, 0u, };
bool LanguageTag_IsValid(int value) {
  return 0 <= value && value <= 72;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    LanguageTag_strings[73] = {};

static const char LanguageTag_names[] = {
    "kAb"
    "kAm"
    "kAr"
    "kAz"
    "kBe"
    "kBg"
    "kBn"
    "kBs"
    "kCa"
    "kCkb"
    "kCs"
    "kCy"
    "kDa"
    "kDe"
    "kDv"
    "kDz"
    "kEl"
    "kEn"
    "kEs"
    "kEt"
    "kFa"
    "kFi"
    "kFr"
    "kFy"
    "kGl"
    "kHe"
    "kHr"
    "kHu"
    "kHy"
    "kId"
    "kIs"
    "kIt"
    "kJa"
    "kKa"
    "kKl"
    "kKm"
    "kKo"
    "kLo"
    "kLt"
    "kLv"
    "kMg"
    "kMk"
    "kMn"
    "kMo"
    "kMt"
    "kMy"
    "kNe"
    "kNl"
    "kNo"
    "kOc"
    "kPap"
    "kPl"
    "kPs"
    "kPt"
    "kRm"
    "kRo"
    "kRu"
    "kSk"
    "kSl"
    "kSq"
    "kSr"
    "kSrLatn"
    "kSv"
    "kTg"
    "kTh"
    "kTk"
    "kTr"
    "kUk"
    "kUnspecified"
    "kUr"
    "kUz"
    "kVi"
    "kZh"
};

static const ::google::protobuf::internal::EnumEntry LanguageTag_entries[] =
    {
        {{&LanguageTag_names[0], 3}, 1},
        {{&LanguageTag_names[3], 3}, 2},
        {{&LanguageTag_names[6], 3}, 3},
        {{&LanguageTag_names[9], 3}, 4},
        {{&LanguageTag_names[12], 3}, 5},
        {{&LanguageTag_names[15], 3}, 6},
        {{&LanguageTag_names[18], 3}, 7},
        {{&LanguageTag_names[21], 3}, 8},
        {{&LanguageTag_names[24], 3}, 9},
        {{&LanguageTag_names[27], 4}, 10},
        {{&LanguageTag_names[31], 3}, 11},
        {{&LanguageTag_names[34], 3}, 72},
        {{&LanguageTag_names[37], 3}, 12},
        {{&LanguageTag_names[40], 3}, 13},
        {{&LanguageTag_names[43], 3}, 14},
        {{&LanguageTag_names[46], 3}, 15},
        {{&LanguageTag_names[49], 3}, 16},
        {{&LanguageTag_names[52], 3}, 17},
        {{&LanguageTag_names[55], 3}, 18},
        {{&LanguageTag_names[58], 3}, 19},
        {{&LanguageTag_names[61], 3}, 20},
        {{&LanguageTag_names[64], 3}, 21},
        {{&LanguageTag_names[67], 3}, 22},
        {{&LanguageTag_names[70], 3}, 23},
        {{&LanguageTag_names[73], 3}, 24},
        {{&LanguageTag_names[76], 3}, 25},
        {{&LanguageTag_names[79], 3}, 26},
        {{&LanguageTag_names[82], 3}, 27},
        {{&LanguageTag_names[85], 3}, 28},
        {{&LanguageTag_names[88], 3}, 29},
        {{&LanguageTag_names[91], 3}, 30},
        {{&LanguageTag_names[94], 3}, 31},
        {{&LanguageTag_names[97], 3}, 32},
        {{&LanguageTag_names[100], 3}, 33},
        {{&LanguageTag_names[103], 3}, 34},
        {{&LanguageTag_names[106], 3}, 35},
        {{&LanguageTag_names[109], 3}, 36},
        {{&LanguageTag_names[112], 3}, 37},
        {{&LanguageTag_names[115], 3}, 38},
        {{&LanguageTag_names[118], 3}, 39},
        {{&LanguageTag_names[121], 3}, 40},
        {{&LanguageTag_names[124], 3}, 41},
        {{&LanguageTag_names[127], 3}, 42},
        {{&LanguageTag_names[130], 3}, 43},
        {{&LanguageTag_names[133], 3}, 44},
        {{&LanguageTag_names[136], 3}, 45},
        {{&LanguageTag_names[139], 3}, 46},
        {{&LanguageTag_names[142], 3}, 47},
        {{&LanguageTag_names[145], 3}, 48},
        {{&LanguageTag_names[148], 3}, 49},
        {{&LanguageTag_names[151], 4}, 50},
        {{&LanguageTag_names[155], 3}, 51},
        {{&LanguageTag_names[158], 3}, 52},
        {{&LanguageTag_names[161], 3}, 53},
        {{&LanguageTag_names[164], 3}, 54},
        {{&LanguageTag_names[167], 3}, 55},
        {{&LanguageTag_names[170], 3}, 56},
        {{&LanguageTag_names[173], 3}, 57},
        {{&LanguageTag_names[176], 3}, 58},
        {{&LanguageTag_names[179], 3}, 59},
        {{&LanguageTag_names[182], 3}, 60},
        {{&LanguageTag_names[185], 7}, 61},
        {{&LanguageTag_names[192], 3}, 62},
        {{&LanguageTag_names[195], 3}, 63},
        {{&LanguageTag_names[198], 3}, 64},
        {{&LanguageTag_names[201], 3}, 65},
        {{&LanguageTag_names[204], 3}, 66},
        {{&LanguageTag_names[207], 3}, 67},
        {{&LanguageTag_names[210], 12}, 0},
        {{&LanguageTag_names[222], 3}, 68},
        {{&LanguageTag_names[225], 3}, 69},
        {{&LanguageTag_names[228], 3}, 70},
        {{&LanguageTag_names[231], 3}, 71},
};

static const int LanguageTag_entries_by_number[] = {
    68,  // 0 -> kUnspecified
    0,  // 1 -> kAb
    1,  // 2 -> kAm
    2,  // 3 -> kAr
    3,  // 4 -> kAz
    4,  // 5 -> kBe
    5,  // 6 -> kBg
    6,  // 7 -> kBn
    7,  // 8 -> kBs
    8,  // 9 -> kCa
    9,  // 10 -> kCkb
    10,  // 11 -> kCs
    12,  // 12 -> kDa
    13,  // 13 -> kDe
    14,  // 14 -> kDv
    15,  // 15 -> kDz
    16,  // 16 -> kEl
    17,  // 17 -> kEn
    18,  // 18 -> kEs
    19,  // 19 -> kEt
    20,  // 20 -> kFa
    21,  // 21 -> kFi
    22,  // 22 -> kFr
    23,  // 23 -> kFy
    24,  // 24 -> kGl
    25,  // 25 -> kHe
    26,  // 26 -> kHr
    27,  // 27 -> kHu
    28,  // 28 -> kHy
    29,  // 29 -> kId
    30,  // 30 -> kIs
    31,  // 31 -> kIt
    32,  // 32 -> kJa
    33,  // 33 -> kKa
    34,  // 34 -> kKl
    35,  // 35 -> kKm
    36,  // 36 -> kKo
    37,  // 37 -> kLo
    38,  // 38 -> kLt
    39,  // 39 -> kLv
    40,  // 40 -> kMg
    41,  // 41 -> kMk
    42,  // 42 -> kMn
    43,  // 43 -> kMo
    44,  // 44 -> kMt
    45,  // 45 -> kMy
    46,  // 46 -> kNe
    47,  // 47 -> kNl
    48,  // 48 -> kNo
    49,  // 49 -> kOc
    50,  // 50 -> kPap
    51,  // 51 -> kPl
    52,  // 52 -> kPs
    53,  // 53 -> kPt
    54,  // 54 -> kRm
    55,  // 55 -> kRo
    56,  // 56 -> kRu
    57,  // 57 -> kSk
    58,  // 58 -> kSl
    59,  // 59 -> kSq
    60,  // 60 -> kSr
    61,  // 61 -> kSrLatn
    62,  // 62 -> kSv
    63,  // 63 -> kTg
    64,  // 64 -> kTh
    65,  // 65 -> kTk
    66,  // 66 -> kTr
    67,  // 67 -> kUk
    69,  // 68 -> kUr
    70,  // 69 -> kUz
    71,  // 70 -> kVi
    72,  // 71 -> kZh
    11,  // 72 -> kCy
};

const std::string& LanguageTag_Name(LanguageTag value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          LanguageTag_entries, LanguageTag_entries_by_number,
          73, LanguageTag_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      LanguageTag_entries, LanguageTag_entries_by_number, 73,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : LanguageTag_strings[idx].get();
}

bool LanguageTag_Parse(absl::string_view name, LanguageTag* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      LanguageTag_entries, 73, name, &int_value);
  if (success) {
    *value = static_cast<LanguageTag>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t RoadClass_internal_data_[] = {
    524288u, 0u, };
bool RoadClass_IsValid(int value) {
  return 0 <= value && value <= 7;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    RoadClass_strings[8] = {};

static const char RoadClass_names[] = {
    "kMotorway"
    "kPrimary"
    "kResidential"
    "kSecondary"
    "kServiceOther"
    "kTertiary"
    "kTrunk"
    "kUnclassified"
};

static const ::google::protobuf::internal::EnumEntry RoadClass_entries[] =
    {
        {{&RoadClass_names[0], 9}, 0},
        {{&RoadClass_names[9], 8}, 2},
        {{&RoadClass_names[17], 12}, 6},
        {{&RoadClass_names[29], 10}, 3},
        {{&RoadClass_names[39], 13}, 7},
        {{&RoadClass_names[52], 9}, 4},
        {{&RoadClass_names[61], 6}, 1},
        {{&RoadClass_names[67], 13}, 5},
};

static const int RoadClass_entries_by_number[] = {
    0,  // 0 -> kMotorway
    6,  // 1 -> kTrunk
    1,  // 2 -> kPrimary
    3,  // 3 -> kSecondary
    5,  // 4 -> kTertiary
    7,  // 5 -> kUnclassified
    2,  // 6 -> kResidential
    4,  // 7 -> kServiceOther
};

const std::string& RoadClass_Name(RoadClass value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          RoadClass_entries, RoadClass_entries_by_number,
          8, RoadClass_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      RoadClass_entries, RoadClass_entries_by_number, 8,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : RoadClass_strings[idx].get();
}

bool RoadClass_Parse(absl::string_view name, RoadClass* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      RoadClass_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<RoadClass>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t TravelMode_internal_data_[] = {
    262144u, 0u, };
bool TravelMode_IsValid(int value) {
  return 0 <= value && value <= 3;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    TravelMode_strings[4] = {};

static const char TravelMode_names[] = {
    "kBicycle"
    "kDrive"
    "kPedestrian"
    "kTransit"
};

static const ::google::protobuf::internal::EnumEntry TravelMode_entries[] =
    {
        {{&TravelMode_names[0], 8}, 2},
        {{&TravelMode_names[8], 6}, 0},
        {{&TravelMode_names[14], 11}, 1},
        {{&TravelMode_names[25], 8}, 3},
};

static const int TravelMode_entries_by_number[] = {
    1,  // 0 -> kDrive
    2,  // 1 -> kPedestrian
    0,  // 2 -> kBicycle
    3,  // 3 -> kTransit
};

const std::string& TravelMode_Name(TravelMode value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          TravelMode_entries, TravelMode_entries_by_number,
          4, TravelMode_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      TravelMode_entries, TravelMode_entries_by_number, 4,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : TravelMode_strings[idx].get();
}

bool TravelMode_Parse(absl::string_view name, TravelMode* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      TravelMode_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TravelMode>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t VehicleType_internal_data_[] = {
    327680u, 0u, };
bool VehicleType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    VehicleType_strings[5] = {};

static const char VehicleType_names[] = {
    "kAutoBus"
    "kCar"
    "kMotorScooter"
    "kMotorcycle"
    "kTruck"
};

static const ::google::protobuf::internal::EnumEntry VehicleType_entries[] =
    {
        {{&VehicleType_names[0], 8}, 2},
        {{&VehicleType_names[8], 4}, 0},
        {{&VehicleType_names[12], 13}, 4},
        {{&VehicleType_names[25], 11}, 1},
        {{&VehicleType_names[36], 6}, 3},
};

static const int VehicleType_entries_by_number[] = {
    1,  // 0 -> kCar
    3,  // 1 -> kMotorcycle
    0,  // 2 -> kAutoBus
    4,  // 3 -> kTruck
    2,  // 4 -> kMotorScooter
};

const std::string& VehicleType_Name(VehicleType value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          VehicleType_entries, VehicleType_entries_by_number,
          5, VehicleType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      VehicleType_entries, VehicleType_entries_by_number, 5,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : VehicleType_strings[idx].get();
}

bool VehicleType_Parse(absl::string_view name, VehicleType* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      VehicleType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<VehicleType>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t PedestrianType_internal_data_[] = {
    196608u, 0u, };
bool PedestrianType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    PedestrianType_strings[3] = {};

static const char PedestrianType_names[] = {
    "kBlind"
    "kFoot"
    "kWheelchair"
};

static const ::google::protobuf::internal::EnumEntry PedestrianType_entries[] =
    {
        {{&PedestrianType_names[0], 6}, 2},
        {{&PedestrianType_names[6], 5}, 0},
        {{&PedestrianType_names[11], 11}, 1},
};

static const int PedestrianType_entries_by_number[] = {
    1,  // 0 -> kFoot
    2,  // 1 -> kWheelchair
    0,  // 2 -> kBlind
};

const std::string& PedestrianType_Name(PedestrianType value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          PedestrianType_entries, PedestrianType_entries_by_number,
          3, PedestrianType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      PedestrianType_entries, PedestrianType_entries_by_number, 3,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : PedestrianType_strings[idx].get();
}

bool PedestrianType_Parse(absl::string_view name, PedestrianType* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      PedestrianType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<PedestrianType>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t BicycleType_internal_data_[] = {
    262144u, 0u, };
bool BicycleType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    BicycleType_strings[4] = {};

static const char BicycleType_names[] = {
    "kCross"
    "kHybrid"
    "kMountain"
    "kRoad"
};

static const ::google::protobuf::internal::EnumEntry BicycleType_entries[] =
    {
        {{&BicycleType_names[0], 6}, 1},
        {{&BicycleType_names[6], 7}, 2},
        {{&BicycleType_names[13], 9}, 3},
        {{&BicycleType_names[22], 5}, 0},
};

static const int BicycleType_entries_by_number[] = {
    3,  // 0 -> kRoad
    0,  // 1 -> kCross
    1,  // 2 -> kHybrid
    2,  // 3 -> kMountain
};

const std::string& BicycleType_Name(BicycleType value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          BicycleType_entries, BicycleType_entries_by_number,
          4, BicycleType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      BicycleType_entries, BicycleType_entries_by_number, 4,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : BicycleType_strings[idx].get();
}

bool BicycleType_Parse(absl::string_view name, BicycleType* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      BicycleType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<BicycleType>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t TransitType_internal_data_[] = {
    524288u, 0u, };
bool TransitType_IsValid(int value) {
  return 0 <= value && value <= 7;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    TransitType_strings[8] = {};

static const char TransitType_names[] = {
    "kBus"
    "kCableCar"
    "kFerry"
    "kFunicular"
    "kGondola"
    "kMetro"
    "kRail"
    "kTram"
};

static const ::google::protobuf::internal::EnumEntry TransitType_entries[] =
    {
        {{&TransitType_names[0], 4}, 3},
        {{&TransitType_names[4], 9}, 5},
        {{&TransitType_names[13], 6}, 4},
        {{&TransitType_names[19], 10}, 7},
        {{&TransitType_names[29], 8}, 6},
        {{&TransitType_names[37], 6}, 1},
        {{&TransitType_names[43], 5}, 2},
        {{&TransitType_names[48], 5}, 0},
};

static const int TransitType_entries_by_number[] = {
    7,  // 0 -> kTram
    5,  // 1 -> kMetro
    6,  // 2 -> kRail
    0,  // 3 -> kBus
    2,  // 4 -> kFerry
    1,  // 5 -> kCableCar
    4,  // 6 -> kGondola
    3,  // 7 -> kFunicular
};

const std::string& TransitType_Name(TransitType value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          TransitType_entries, TransitType_entries_by_number,
          8, TransitType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      TransitType_entries, TransitType_entries_by_number, 8,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : TransitType_strings[idx].get();
}

bool TransitType_Parse(absl::string_view name, TransitType* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      TransitType_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<TransitType>(int_value);
  }
  return success;
}
// ===================================================================

class LatLng::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::valhalla::LatLng, _impl_._oneof_case_);
};

LatLng::LatLng(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.LatLng)
}
inline PROTOBUF_NDEBUG_INLINE LatLng::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::LatLng& from_msg)
      : has_lat_{},
        has_lng_{},
        _cached_size_{0},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

LatLng::LatLng(
    ::google::protobuf::Arena* arena,
    const LatLng& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LatLng* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  switch (has_lat_case()) {
    case HAS_LAT_NOT_SET:
      break;
      case kLat:
        _impl_.has_lat_.lat_ = from._impl_.has_lat_.lat_;
        break;
  }
  switch (has_lng_case()) {
    case HAS_LNG_NOT_SET:
      break;
      case kLng:
        _impl_.has_lng_.lng_ = from._impl_.has_lng_.lng_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:valhalla.LatLng)
}
inline PROTOBUF_NDEBUG_INLINE LatLng::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : has_lat_{},
        has_lng_{},
        _cached_size_{0},
        _oneof_case_{} {}

inline void LatLng::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
LatLng::~LatLng() {
  // @@protoc_insertion_point(destructor:valhalla.LatLng)
  SharedDtor(*this);
}
inline void LatLng::SharedDtor(MessageLite& self) {
  LatLng& this_ = static_cast<LatLng&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  if (this_.has_has_lat()) {
    this_.clear_has_lat();
  }
  if (this_.has_has_lng()) {
    this_.clear_has_lng();
  }
  this_._impl_.~Impl_();
}

void LatLng::clear_has_lat() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.LatLng)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_lat_case()) {
    case kLat: {
      // No need to clear
      break;
    }
    case HAS_LAT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_LAT_NOT_SET;
}

void LatLng::clear_has_lng() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.LatLng)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_lng_case()) {
    case kLng: {
      // No need to clear
      break;
    }
    case HAS_LNG_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_LNG_NOT_SET;
}


inline void* LatLng::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) LatLng(arena);
}
constexpr auto LatLng::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(LatLng),
                                            alignof(LatLng));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<16> LatLng::_class_data_ = {
    {
        &_LatLng_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &LatLng::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<LatLng>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &LatLng::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<LatLng>(), &LatLng::ByteSizeLong,
            &LatLng::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(LatLng, _impl_._cached_size_),
        true,
    },
    "valhalla.LatLng",
};
const ::google::protobuf::internal::ClassData* LatLng::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 2, 0, 0, 2> LatLng::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::LatLng>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // double lat = 1;
    {PROTOBUF_FIELD_OFFSET(LatLng, _impl_.has_lat_.lat_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kDouble)},
    // double lng = 2;
    {PROTOBUF_FIELD_OFFSET(LatLng, _impl_.has_lng_.lng_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void LatLng::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.LatLng)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_has_lat();
  clear_has_lng();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* LatLng::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const LatLng& this_ = static_cast<const LatLng&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* LatLng::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const LatLng& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.LatLng)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // double lat = 1;
          if (this_.has_lat_case() == kLat) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                1, this_._internal_lat(), target);
          }

          // double lng = 2;
          if (this_.has_lng_case() == kLng) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                2, this_._internal_lng(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.LatLng)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t LatLng::ByteSizeLong(const MessageLite& base) {
          const LatLng& this_ = static_cast<const LatLng&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t LatLng::ByteSizeLong() const {
          const LatLng& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.LatLng)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          switch (this_.has_lat_case()) {
            // double lat = 1;
            case kLat: {
              total_size += 9;
              break;
            }
            case HAS_LAT_NOT_SET: {
              break;
            }
          }
          switch (this_.has_lng_case()) {
            // double lng = 2;
            case kLng: {
              total_size += 9;
              break;
            }
            case HAS_LNG_NOT_SET: {
              break;
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void LatLng::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<LatLng*>(&to_msg);
  auto& from = static_cast<const LatLng&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.LatLng)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_lat();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kLat: {
        _this->_impl_.has_lat_.lat_ = from._impl_.has_lat_.lat_;
        break;
      }
      case HAS_LAT_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_lng();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kLng: {
        _this->_impl_.has_lng_.lng_ = from._impl_.has_lng_.lng_;
        break;
      }
      case HAS_LNG_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LatLng::CopyFrom(const LatLng& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.LatLng)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LatLng::InternalSwap(LatLng* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.has_lat_, other->_impl_.has_lat_);
  swap(_impl_.has_lng_, other->_impl_.has_lng_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

// ===================================================================

class RouteLandmark::_Internal {
 public:
  using HasBits =
      decltype(std::declval<RouteLandmark>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(RouteLandmark, _impl_._has_bits_);
};

RouteLandmark::RouteLandmark(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.RouteLandmark)
}
inline PROTOBUF_NDEBUG_INLINE RouteLandmark::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::RouteLandmark& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        name_(arena, from.name_) {}

RouteLandmark::RouteLandmark(
    ::google::protobuf::Arena* arena,
    const RouteLandmark& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  RouteLandmark* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.lat_lng_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::LatLng>(
                              arena, *from._impl_.lat_lng_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, type_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, type_),
           offsetof(Impl_, distance_) -
               offsetof(Impl_, type_) +
               sizeof(Impl_::distance_));

  // @@protoc_insertion_point(copy_constructor:valhalla.RouteLandmark)
}
inline PROTOBUF_NDEBUG_INLINE RouteLandmark::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        name_(arena) {}

inline void RouteLandmark::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, lat_lng_),
           0,
           offsetof(Impl_, distance_) -
               offsetof(Impl_, lat_lng_) +
               sizeof(Impl_::distance_));
}
RouteLandmark::~RouteLandmark() {
  // @@protoc_insertion_point(destructor:valhalla.RouteLandmark)
  SharedDtor(*this);
}
inline void RouteLandmark::SharedDtor(MessageLite& self) {
  RouteLandmark& this_ = static_cast<RouteLandmark&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.name_.Destroy();
  delete this_._impl_.lat_lng_;
  this_._impl_.~Impl_();
}

inline void* RouteLandmark::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) RouteLandmark(arena);
}
constexpr auto RouteLandmark::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(RouteLandmark),
                                            alignof(RouteLandmark));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<23> RouteLandmark::_class_data_ = {
    {
        &_RouteLandmark_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &RouteLandmark::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<RouteLandmark>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &RouteLandmark::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<RouteLandmark>(), &RouteLandmark::ByteSizeLong,
            &RouteLandmark::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(RouteLandmark, _impl_._cached_size_),
        true,
    },
    "valhalla.RouteLandmark",
};
const ::google::protobuf::internal::ClassData* RouteLandmark::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 1, 35, 2> RouteLandmark::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RouteLandmark, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::RouteLandmark>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string name = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(RouteLandmark, _impl_.name_)}},
    // .valhalla.RouteLandmark.Type type = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(RouteLandmark, _impl_.type_)}},
    // .valhalla.LatLng lat_lng = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(RouteLandmark, _impl_.lat_lng_)}},
    // double distance = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 63, 0, PROTOBUF_FIELD_OFFSET(RouteLandmark, _impl_.distance_)}},
    // bool right = 5;
    {::_pbi::TcParser::FastV8S1,
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(RouteLandmark, _impl_.right_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string name = 1;
    {PROTOBUF_FIELD_OFFSET(RouteLandmark, _impl_.name_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .valhalla.RouteLandmark.Type type = 2;
    {PROTOBUF_FIELD_OFFSET(RouteLandmark, _impl_.type_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.LatLng lat_lng = 3;
    {PROTOBUF_FIELD_OFFSET(RouteLandmark, _impl_.lat_lng_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // double distance = 4;
    {PROTOBUF_FIELD_OFFSET(RouteLandmark, _impl_.distance_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // bool right = 5;
    {PROTOBUF_FIELD_OFFSET(RouteLandmark, _impl_.right_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::LatLng>()},
  }}, {{
    "\26\4\0\0\0\0\0\0"
    "valhalla.RouteLandmark"
    "name"
  }},
};

PROTOBUF_NOINLINE void RouteLandmark::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.RouteLandmark)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.lat_lng_ != nullptr);
    _impl_.lat_lng_->Clear();
  }
  ::memset(&_impl_.type_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.distance_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.distance_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* RouteLandmark::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const RouteLandmark& this_ = static_cast<const RouteLandmark&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* RouteLandmark::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const RouteLandmark& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.RouteLandmark)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string name = 1;
          if (!this_._internal_name().empty()) {
            const std::string& _s = this_._internal_name();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.RouteLandmark.name");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // .valhalla.RouteLandmark.Type type = 2;
          if (this_._internal_type() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                2, this_._internal_type(), target);
          }

          cached_has_bits = this_._impl_._has_bits_[0];
          // .valhalla.LatLng lat_lng = 3;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                3, *this_._impl_.lat_lng_, this_._impl_.lat_lng_->GetCachedSize(), target,
                stream);
          }

          // double distance = 4;
          if (::absl::bit_cast<::uint64_t>(this_._internal_distance()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                4, this_._internal_distance(), target);
          }

          // bool right = 5;
          if (this_._internal_right() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                5, this_._internal_right(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.RouteLandmark)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t RouteLandmark::ByteSizeLong(const MessageLite& base) {
          const RouteLandmark& this_ = static_cast<const RouteLandmark&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t RouteLandmark::ByteSizeLong() const {
          const RouteLandmark& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.RouteLandmark)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // string name = 1;
            if (!this_._internal_name().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_name());
            }
          }
           {
            // .valhalla.LatLng lat_lng = 3;
            cached_has_bits = this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.lat_lng_);
            }
          }
           {
            // .valhalla.RouteLandmark.Type type = 2;
            if (this_._internal_type() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_type());
            }
            // bool right = 5;
            if (this_._internal_right() != 0) {
              total_size += 2;
            }
            // double distance = 4;
            if (::absl::bit_cast<::uint64_t>(this_._internal_distance()) != 0) {
              total_size += 9;
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void RouteLandmark::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<RouteLandmark*>(&to_msg);
  auto& from = static_cast<const RouteLandmark&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.RouteLandmark)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(from._impl_.lat_lng_ != nullptr);
    if (_this->_impl_.lat_lng_ == nullptr) {
      _this->_impl_.lat_lng_ =
          ::google::protobuf::MessageLite::CopyConstruct<::valhalla::LatLng>(arena, *from._impl_.lat_lng_);
    } else {
      _this->_impl_.lat_lng_->MergeFrom(*from._impl_.lat_lng_);
    }
  }
  if (from._internal_type() != 0) {
    _this->_impl_.type_ = from._impl_.type_;
  }
  if (from._internal_right() != 0) {
    _this->_impl_.right_ = from._impl_.right_;
  }
  if (::absl::bit_cast<::uint64_t>(from._internal_distance()) != 0) {
    _this->_impl_.distance_ = from._impl_.distance_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RouteLandmark::CopyFrom(const RouteLandmark& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.RouteLandmark)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void RouteLandmark::InternalSwap(RouteLandmark* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RouteLandmark, _impl_.distance_)
      + sizeof(RouteLandmark::_impl_.distance_)
      - PROTOBUF_FIELD_OFFSET(RouteLandmark, _impl_.lat_lng_)>(
          reinterpret_cast<char*>(&_impl_.lat_lng_),
          reinterpret_cast<char*>(&other->_impl_.lat_lng_));
}

// ===================================================================

class BoundingBox::_Internal {
 public:
  using HasBits =
      decltype(std::declval<BoundingBox>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BoundingBox, _impl_._has_bits_);
};

BoundingBox::BoundingBox(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.BoundingBox)
}
inline PROTOBUF_NDEBUG_INLINE BoundingBox::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::BoundingBox& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

BoundingBox::BoundingBox(
    ::google::protobuf::Arena* arena,
    const BoundingBox& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  BoundingBox* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.min_ll_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::LatLng>(
                              arena, *from._impl_.min_ll_)
                        : nullptr;
  _impl_.max_ll_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::LatLng>(
                              arena, *from._impl_.max_ll_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:valhalla.BoundingBox)
}
inline PROTOBUF_NDEBUG_INLINE BoundingBox::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void BoundingBox::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, min_ll_),
           0,
           offsetof(Impl_, max_ll_) -
               offsetof(Impl_, min_ll_) +
               sizeof(Impl_::max_ll_));
}
BoundingBox::~BoundingBox() {
  // @@protoc_insertion_point(destructor:valhalla.BoundingBox)
  SharedDtor(*this);
}
inline void BoundingBox::SharedDtor(MessageLite& self) {
  BoundingBox& this_ = static_cast<BoundingBox&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.min_ll_;
  delete this_._impl_.max_ll_;
  this_._impl_.~Impl_();
}

inline void* BoundingBox::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) BoundingBox(arena);
}
constexpr auto BoundingBox::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(BoundingBox),
                                            alignof(BoundingBox));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<21> BoundingBox::_class_data_ = {
    {
        &_BoundingBox_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &BoundingBox::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<BoundingBox>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &BoundingBox::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<BoundingBox>(), &BoundingBox::ByteSizeLong,
            &BoundingBox::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(BoundingBox, _impl_._cached_size_),
        true,
    },
    "valhalla.BoundingBox",
};
const ::google::protobuf::internal::ClassData* BoundingBox::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 2, 0, 2> BoundingBox::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BoundingBox, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::BoundingBox>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .valhalla.LatLng max_ll = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(BoundingBox, _impl_.max_ll_)}},
    // .valhalla.LatLng min_ll = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(BoundingBox, _impl_.min_ll_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .valhalla.LatLng min_ll = 1;
    {PROTOBUF_FIELD_OFFSET(BoundingBox, _impl_.min_ll_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .valhalla.LatLng max_ll = 2;
    {PROTOBUF_FIELD_OFFSET(BoundingBox, _impl_.max_ll_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::LatLng>()},
    {::_pbi::TcParser::GetTable<::valhalla::LatLng>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void BoundingBox::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.BoundingBox)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.min_ll_ != nullptr);
      _impl_.min_ll_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.max_ll_ != nullptr);
      _impl_.max_ll_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* BoundingBox::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const BoundingBox& this_ = static_cast<const BoundingBox&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* BoundingBox::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const BoundingBox& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.BoundingBox)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // .valhalla.LatLng min_ll = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.min_ll_, this_._impl_.min_ll_->GetCachedSize(), target,
                stream);
          }

          // .valhalla.LatLng max_ll = 2;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                2, *this_._impl_.max_ll_, this_._impl_.max_ll_->GetCachedSize(), target,
                stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.BoundingBox)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t BoundingBox::ByteSizeLong(const MessageLite& base) {
          const BoundingBox& this_ = static_cast<const BoundingBox&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t BoundingBox::ByteSizeLong() const {
          const BoundingBox& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.BoundingBox)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000003u) {
            // .valhalla.LatLng min_ll = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.min_ll_);
            }
            // .valhalla.LatLng max_ll = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.max_ll_);
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void BoundingBox::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<BoundingBox*>(&to_msg);
  auto& from = static_cast<const BoundingBox&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.BoundingBox)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.min_ll_ != nullptr);
      if (_this->_impl_.min_ll_ == nullptr) {
        _this->_impl_.min_ll_ =
            ::google::protobuf::MessageLite::CopyConstruct<::valhalla::LatLng>(arena, *from._impl_.min_ll_);
      } else {
        _this->_impl_.min_ll_->MergeFrom(*from._impl_.min_ll_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.max_ll_ != nullptr);
      if (_this->_impl_.max_ll_ == nullptr) {
        _this->_impl_.max_ll_ =
            ::google::protobuf::MessageLite::CopyConstruct<::valhalla::LatLng>(arena, *from._impl_.max_ll_);
      } else {
        _this->_impl_.max_ll_->MergeFrom(*from._impl_.max_ll_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BoundingBox::CopyFrom(const BoundingBox& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.BoundingBox)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void BoundingBox::InternalSwap(BoundingBox* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BoundingBox, _impl_.max_ll_)
      + sizeof(BoundingBox::_impl_.max_ll_)
      - PROTOBUF_FIELD_OFFSET(BoundingBox, _impl_.min_ll_)>(
          reinterpret_cast<char*>(&_impl_.min_ll_),
          reinterpret_cast<char*>(&other->_impl_.min_ll_));
}

// ===================================================================

class SearchFilter::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::valhalla::SearchFilter, _impl_._oneof_case_);
};

SearchFilter::SearchFilter(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.SearchFilter)
}
inline PROTOBUF_NDEBUG_INLINE SearchFilter::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::SearchFilter& from_msg)
      : has_min_road_class_{},
        has_max_road_class_{},
        has_exclude_closures_{},
        has_level_{},
        _cached_size_{0},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1], from._oneof_case_[2], from._oneof_case_[3]} {}

SearchFilter::SearchFilter(
    ::google::protobuf::Arena* arena,
    const SearchFilter& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SearchFilter* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, exclude_tunnel_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, exclude_tunnel_),
           offsetof(Impl_, exclude_ferry_) -
               offsetof(Impl_, exclude_tunnel_) +
               sizeof(Impl_::exclude_ferry_));
  switch (has_min_road_class_case()) {
    case HAS_MIN_ROAD_CLASS_NOT_SET:
      break;
      case kMinRoadClass:
        _impl_.has_min_road_class_.min_road_class_ = from._impl_.has_min_road_class_.min_road_class_;
        break;
  }
  switch (has_max_road_class_case()) {
    case HAS_MAX_ROAD_CLASS_NOT_SET:
      break;
      case kMaxRoadClass:
        _impl_.has_max_road_class_.max_road_class_ = from._impl_.has_max_road_class_.max_road_class_;
        break;
  }
  switch (has_exclude_closures_case()) {
    case HAS_EXCLUDE_CLOSURES_NOT_SET:
      break;
      case kExcludeClosures:
        _impl_.has_exclude_closures_.exclude_closures_ = from._impl_.has_exclude_closures_.exclude_closures_;
        break;
  }
  switch (has_level_case()) {
    case HAS_LEVEL_NOT_SET:
      break;
      case kLevel:
        _impl_.has_level_.level_ = from._impl_.has_level_.level_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:valhalla.SearchFilter)
}
inline PROTOBUF_NDEBUG_INLINE SearchFilter::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : has_min_road_class_{},
        has_max_road_class_{},
        has_exclude_closures_{},
        has_level_{},
        _cached_size_{0},
        _oneof_case_{} {}

inline void SearchFilter::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, exclude_tunnel_),
           0,
           offsetof(Impl_, exclude_ferry_) -
               offsetof(Impl_, exclude_tunnel_) +
               sizeof(Impl_::exclude_ferry_));
}
SearchFilter::~SearchFilter() {
  // @@protoc_insertion_point(destructor:valhalla.SearchFilter)
  SharedDtor(*this);
}
inline void SearchFilter::SharedDtor(MessageLite& self) {
  SearchFilter& this_ = static_cast<SearchFilter&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  if (this_.has_has_min_road_class()) {
    this_.clear_has_min_road_class();
  }
  if (this_.has_has_max_road_class()) {
    this_.clear_has_max_road_class();
  }
  if (this_.has_has_exclude_closures()) {
    this_.clear_has_exclude_closures();
  }
  if (this_.has_has_level()) {
    this_.clear_has_level();
  }
  this_._impl_.~Impl_();
}

void SearchFilter::clear_has_min_road_class() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.SearchFilter)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_min_road_class_case()) {
    case kMinRoadClass: {
      // No need to clear
      break;
    }
    case HAS_MIN_ROAD_CLASS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_MIN_ROAD_CLASS_NOT_SET;
}

void SearchFilter::clear_has_max_road_class() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.SearchFilter)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_max_road_class_case()) {
    case kMaxRoadClass: {
      // No need to clear
      break;
    }
    case HAS_MAX_ROAD_CLASS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_MAX_ROAD_CLASS_NOT_SET;
}

void SearchFilter::clear_has_exclude_closures() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.SearchFilter)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_exclude_closures_case()) {
    case kExcludeClosures: {
      // No need to clear
      break;
    }
    case HAS_EXCLUDE_CLOSURES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[2] = HAS_EXCLUDE_CLOSURES_NOT_SET;
}

void SearchFilter::clear_has_level() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.SearchFilter)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_level_case()) {
    case kLevel: {
      // No need to clear
      break;
    }
    case HAS_LEVEL_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[3] = HAS_LEVEL_NOT_SET;
}


inline void* SearchFilter::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) SearchFilter(arena);
}
constexpr auto SearchFilter::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(SearchFilter),
                                            alignof(SearchFilter));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<22> SearchFilter::_class_data_ = {
    {
        &_SearchFilter_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &SearchFilter::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<SearchFilter>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &SearchFilter::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<SearchFilter>(), &SearchFilter::ByteSizeLong,
            &SearchFilter::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(SearchFilter, _impl_._cached_size_),
        true,
    },
    "valhalla.SearchFilter",
};
const ::google::protobuf::internal::ClassData* SearchFilter::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 9, 0, 0, 2> SearchFilter::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    9, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966784,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::SearchFilter>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // bool exclude_ferry = 8;
    {::_pbi::TcParser::FastV8S1,
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(SearchFilter, _impl_.exclude_ferry_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // bool exclude_tunnel = 3;
    {::_pbi::TcParser::FastV8S1,
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(SearchFilter, _impl_.exclude_tunnel_)}},
    // bool exclude_bridge = 4;
    {::_pbi::TcParser::FastV8S1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(SearchFilter, _impl_.exclude_bridge_)}},
    // bool exclude_ramp = 5;
    {::_pbi::TcParser::FastV8S1,
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(SearchFilter, _impl_.exclude_ramp_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // bool exclude_toll = 7;
    {::_pbi::TcParser::FastV8S1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(SearchFilter, _impl_.exclude_toll_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .valhalla.RoadClass min_road_class = 1;
    {PROTOBUF_FIELD_OFFSET(SearchFilter, _impl_.has_min_road_class_.min_road_class_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kOpenEnum)},
    // .valhalla.RoadClass max_road_class = 2;
    {PROTOBUF_FIELD_OFFSET(SearchFilter, _impl_.has_max_road_class_.max_road_class_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kOpenEnum)},
    // bool exclude_tunnel = 3;
    {PROTOBUF_FIELD_OFFSET(SearchFilter, _impl_.exclude_tunnel_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool exclude_bridge = 4;
    {PROTOBUF_FIELD_OFFSET(SearchFilter, _impl_.exclude_bridge_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool exclude_ramp = 5;
    {PROTOBUF_FIELD_OFFSET(SearchFilter, _impl_.exclude_ramp_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool exclude_closures = 6;
    {PROTOBUF_FIELD_OFFSET(SearchFilter, _impl_.has_exclude_closures_.exclude_closures_), _Internal::kOneofCaseOffset + 8, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool exclude_toll = 7;
    {PROTOBUF_FIELD_OFFSET(SearchFilter, _impl_.exclude_toll_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool exclude_ferry = 8;
    {PROTOBUF_FIELD_OFFSET(SearchFilter, _impl_.exclude_ferry_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // float level = 9;
    {PROTOBUF_FIELD_OFFSET(SearchFilter, _impl_.has_level_.level_), _Internal::kOneofCaseOffset + 12, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void SearchFilter::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.SearchFilter)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.exclude_tunnel_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.exclude_ferry_) -
      reinterpret_cast<char*>(&_impl_.exclude_tunnel_)) + sizeof(_impl_.exclude_ferry_));
  clear_has_min_road_class();
  clear_has_max_road_class();
  clear_has_exclude_closures();
  clear_has_level();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* SearchFilter::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const SearchFilter& this_ = static_cast<const SearchFilter&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* SearchFilter::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const SearchFilter& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.SearchFilter)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // .valhalla.RoadClass min_road_class = 1;
          if (this_.has_min_road_class_case() == kMinRoadClass) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                1, this_._internal_min_road_class(), target);
          }

          // .valhalla.RoadClass max_road_class = 2;
          if (this_.has_max_road_class_case() == kMaxRoadClass) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                2, this_._internal_max_road_class(), target);
          }

          // bool exclude_tunnel = 3;
          if (this_._internal_exclude_tunnel() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                3, this_._internal_exclude_tunnel(), target);
          }

          // bool exclude_bridge = 4;
          if (this_._internal_exclude_bridge() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                4, this_._internal_exclude_bridge(), target);
          }

          // bool exclude_ramp = 5;
          if (this_._internal_exclude_ramp() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                5, this_._internal_exclude_ramp(), target);
          }

          // bool exclude_closures = 6;
          if (this_.has_exclude_closures_case() == kExcludeClosures) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                6, this_._internal_exclude_closures(), target);
          }

          // bool exclude_toll = 7;
          if (this_._internal_exclude_toll() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                7, this_._internal_exclude_toll(), target);
          }

          // bool exclude_ferry = 8;
          if (this_._internal_exclude_ferry() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                8, this_._internal_exclude_ferry(), target);
          }

          // float level = 9;
          if (this_.has_level_case() == kLevel) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                9, this_._internal_level(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.SearchFilter)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t SearchFilter::ByteSizeLong(const MessageLite& base) {
          const SearchFilter& this_ = static_cast<const SearchFilter&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t SearchFilter::ByteSizeLong() const {
          const SearchFilter& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.SearchFilter)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // bool exclude_tunnel = 3;
            if (this_._internal_exclude_tunnel() != 0) {
              total_size += 2;
            }
            // bool exclude_bridge = 4;
            if (this_._internal_exclude_bridge() != 0) {
              total_size += 2;
            }
            // bool exclude_ramp = 5;
            if (this_._internal_exclude_ramp() != 0) {
              total_size += 2;
            }
            // bool exclude_toll = 7;
            if (this_._internal_exclude_toll() != 0) {
              total_size += 2;
            }
            // bool exclude_ferry = 8;
            if (this_._internal_exclude_ferry() != 0) {
              total_size += 2;
            }
          }
          switch (this_.has_min_road_class_case()) {
            // .valhalla.RoadClass min_road_class = 1;
            case kMinRoadClass: {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_min_road_class());
              break;
            }
            case HAS_MIN_ROAD_CLASS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_max_road_class_case()) {
            // .valhalla.RoadClass max_road_class = 2;
            case kMaxRoadClass: {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_max_road_class());
              break;
            }
            case HAS_MAX_ROAD_CLASS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_exclude_closures_case()) {
            // bool exclude_closures = 6;
            case kExcludeClosures: {
              total_size += 2;
              break;
            }
            case HAS_EXCLUDE_CLOSURES_NOT_SET: {
              break;
            }
          }
          switch (this_.has_level_case()) {
            // float level = 9;
            case kLevel: {
              total_size += 5;
              break;
            }
            case HAS_LEVEL_NOT_SET: {
              break;
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void SearchFilter::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SearchFilter*>(&to_msg);
  auto& from = static_cast<const SearchFilter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.SearchFilter)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_exclude_tunnel() != 0) {
    _this->_impl_.exclude_tunnel_ = from._impl_.exclude_tunnel_;
  }
  if (from._internal_exclude_bridge() != 0) {
    _this->_impl_.exclude_bridge_ = from._impl_.exclude_bridge_;
  }
  if (from._internal_exclude_ramp() != 0) {
    _this->_impl_.exclude_ramp_ = from._impl_.exclude_ramp_;
  }
  if (from._internal_exclude_toll() != 0) {
    _this->_impl_.exclude_toll_ = from._impl_.exclude_toll_;
  }
  if (from._internal_exclude_ferry() != 0) {
    _this->_impl_.exclude_ferry_ = from._impl_.exclude_ferry_;
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_min_road_class();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kMinRoadClass: {
        _this->_impl_.has_min_road_class_.min_road_class_ = from._impl_.has_min_road_class_.min_road_class_;
        break;
      }
      case HAS_MIN_ROAD_CLASS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_max_road_class();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kMaxRoadClass: {
        _this->_impl_.has_max_road_class_.max_road_class_ = from._impl_.has_max_road_class_.max_road_class_;
        break;
      }
      case HAS_MAX_ROAD_CLASS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[2]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[2];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_exclude_closures();
      }
      _this->_impl_._oneof_case_[2] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kExcludeClosures: {
        _this->_impl_.has_exclude_closures_.exclude_closures_ = from._impl_.has_exclude_closures_.exclude_closures_;
        break;
      }
      case HAS_EXCLUDE_CLOSURES_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[3]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[3];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_level();
      }
      _this->_impl_._oneof_case_[3] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kLevel: {
        _this->_impl_.has_level_.level_ = from._impl_.has_level_.level_;
        break;
      }
      case HAS_LEVEL_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SearchFilter::CopyFrom(const SearchFilter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.SearchFilter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SearchFilter::InternalSwap(SearchFilter* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SearchFilter, _impl_.exclude_ferry_)
      + sizeof(SearchFilter::_impl_.exclude_ferry_)
      - PROTOBUF_FIELD_OFFSET(SearchFilter, _impl_.exclude_tunnel_)>(
          reinterpret_cast<char*>(&_impl_.exclude_tunnel_),
          reinterpret_cast<char*>(&other->_impl_.exclude_tunnel_));
  swap(_impl_.has_min_road_class_, other->_impl_.has_min_road_class_);
  swap(_impl_.has_max_road_class_, other->_impl_.has_max_road_class_);
  swap(_impl_.has_exclude_closures_, other->_impl_.has_exclude_closures_);
  swap(_impl_.has_level_, other->_impl_.has_level_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
  swap(_impl_._oneof_case_[2], other->_impl_._oneof_case_[2]);
  swap(_impl_._oneof_case_[3], other->_impl_._oneof_case_[3]);
}

// ===================================================================

class PathEdge::_Internal {
 public:
  using HasBits =
      decltype(std::declval<PathEdge>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PathEdge, _impl_._has_bits_);
};

PathEdge::PathEdge(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.PathEdge)
}
inline PROTOBUF_NDEBUG_INLINE PathEdge::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::PathEdge& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        names_{visibility, arena, from.names_} {}

PathEdge::PathEdge(
    ::google::protobuf::Arena* arena,
    const PathEdge& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PathEdge* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.ll_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::LatLng>(
                              arena, *from._impl_.ll_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, graph_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, graph_id_),
           offsetof(Impl_, heading_) -
               offsetof(Impl_, graph_id_) +
               sizeof(Impl_::heading_));

  // @@protoc_insertion_point(copy_constructor:valhalla.PathEdge)
}
inline PROTOBUF_NDEBUG_INLINE PathEdge::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        names_{visibility, arena} {}

inline void PathEdge::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, ll_),
           0,
           offsetof(Impl_, heading_) -
               offsetof(Impl_, ll_) +
               sizeof(Impl_::heading_));
}
PathEdge::~PathEdge() {
  // @@protoc_insertion_point(destructor:valhalla.PathEdge)
  SharedDtor(*this);
}
inline void PathEdge::SharedDtor(MessageLite& self) {
  PathEdge& this_ = static_cast<PathEdge&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.ll_;
  this_._impl_.~Impl_();
}

inline void* PathEdge::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) PathEdge(arena);
}
constexpr auto PathEdge::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.names_) +
          decltype(PathEdge::_impl_.names_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(PathEdge), alignof(PathEdge), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&PathEdge::PlacementNew_,
                                 sizeof(PathEdge),
                                 alignof(PathEdge));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<18> PathEdge::_class_data_ = {
    {
        &_PathEdge_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &PathEdge::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<PathEdge>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &PathEdge::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<PathEdge>(), &PathEdge::ByteSizeLong,
            &PathEdge::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(PathEdge, _impl_._cached_size_),
        true,
    },
    "valhalla.PathEdge",
};
const ::google::protobuf::internal::ClassData* PathEdge::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 11, 1, 39, 2> PathEdge::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PathEdge, _impl_._has_bits_),
    0, // no _extensions_
    13, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294959392,  // skipmap
    offsetof(decltype(_table_), field_entries),
    11,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::PathEdge>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // uint64 graph_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.graph_id_)}},
    // double percent_along = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.percent_along_)}},
    // .valhalla.LatLng ll = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.ll_)}},
    // .valhalla.Location.SideOfStreet side_of_street = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.side_of_street_)}},
    // double distance = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 63, 0, PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.distance_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // bool begin_node = 7;
    {::_pbi::TcParser::FastV8S1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.begin_node_)}},
    // bool end_node = 8;
    {::_pbi::TcParser::FastV8S1,
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.end_node_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated string names = 10;
    {::_pbi::TcParser::FastUR1,
     {82, 63, 0, PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.names_)}},
    // int32 outbound_reach = 11;
    {::_pbi::TcParser::FastV32S1,
     {88, 63, 0, PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.outbound_reach_)}},
    // int32 inbound_reach = 12;
    {::_pbi::TcParser::FastV32S1,
     {96, 63, 0, PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.inbound_reach_)}},
    // float heading = 13;
    {::_pbi::TcParser::FastF32S1,
     {109, 63, 0, PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.heading_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // uint64 graph_id = 1;
    {PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.graph_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
    // double percent_along = 2;
    {PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.percent_along_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // .valhalla.LatLng ll = 3;
    {PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.ll_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .valhalla.Location.SideOfStreet side_of_street = 4;
    {PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.side_of_street_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // double distance = 5;
    {PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.distance_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // bool begin_node = 7;
    {PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.begin_node_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool end_node = 8;
    {PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.end_node_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // repeated string names = 10;
    {PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.names_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
    // int32 outbound_reach = 11;
    {PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.outbound_reach_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // int32 inbound_reach = 12;
    {PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.inbound_reach_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // float heading = 13;
    {PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.heading_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::LatLng>()},
  }}, {{
    "\21\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0"
    "valhalla.PathEdge"
    "names"
  }},
};

PROTOBUF_NOINLINE void PathEdge::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.PathEdge)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.names_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.ll_ != nullptr);
    _impl_.ll_->Clear();
  }
  ::memset(&_impl_.graph_id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.heading_) -
      reinterpret_cast<char*>(&_impl_.graph_id_)) + sizeof(_impl_.heading_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* PathEdge::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const PathEdge& this_ = static_cast<const PathEdge&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* PathEdge::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const PathEdge& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.PathEdge)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // uint64 graph_id = 1;
          if (this_._internal_graph_id() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
                1, this_._internal_graph_id(), target);
          }

          // double percent_along = 2;
          if (::absl::bit_cast<::uint64_t>(this_._internal_percent_along()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                2, this_._internal_percent_along(), target);
          }

          cached_has_bits = this_._impl_._has_bits_[0];
          // .valhalla.LatLng ll = 3;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                3, *this_._impl_.ll_, this_._impl_.ll_->GetCachedSize(), target,
                stream);
          }

          // .valhalla.Location.SideOfStreet side_of_street = 4;
          if (this_._internal_side_of_street() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                4, this_._internal_side_of_street(), target);
          }

          // double distance = 5;
          if (::absl::bit_cast<::uint64_t>(this_._internal_distance()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                5, this_._internal_distance(), target);
          }

          // bool begin_node = 7;
          if (this_._internal_begin_node() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                7, this_._internal_begin_node(), target);
          }

          // bool end_node = 8;
          if (this_._internal_end_node() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                8, this_._internal_end_node(), target);
          }

          // repeated string names = 10;
          for (int i = 0, n = this_._internal_names_size(); i < n; ++i) {
            const auto& s = this_._internal_names().Get(i);
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.PathEdge.names");
            target = stream->WriteString(10, s, target);
          }

          // int32 outbound_reach = 11;
          if (this_._internal_outbound_reach() != 0) {
            target = ::google::protobuf::internal::WireFormatLite::
                WriteInt32ToArrayWithField<11>(
                    stream, this_._internal_outbound_reach(), target);
          }

          // int32 inbound_reach = 12;
          if (this_._internal_inbound_reach() != 0) {
            target = ::google::protobuf::internal::WireFormatLite::
                WriteInt32ToArrayWithField<12>(
                    stream, this_._internal_inbound_reach(), target);
          }

          // float heading = 13;
          if (::absl::bit_cast<::uint32_t>(this_._internal_heading()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                13, this_._internal_heading(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.PathEdge)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t PathEdge::ByteSizeLong(const MessageLite& base) {
          const PathEdge& this_ = static_cast<const PathEdge&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t PathEdge::ByteSizeLong() const {
          const PathEdge& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.PathEdge)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated string names = 10;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_names().size());
              for (int i = 0, n = this_._internal_names().size(); i < n; ++i) {
                total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
                    this_._internal_names().Get(i));
              }
            }
          }
           {
            // .valhalla.LatLng ll = 3;
            cached_has_bits = this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.ll_);
            }
          }
           {
            // uint64 graph_id = 1;
            if (this_._internal_graph_id() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
                  this_._internal_graph_id());
            }
            // double percent_along = 2;
            if (::absl::bit_cast<::uint64_t>(this_._internal_percent_along()) != 0) {
              total_size += 9;
            }
            // double distance = 5;
            if (::absl::bit_cast<::uint64_t>(this_._internal_distance()) != 0) {
              total_size += 9;
            }
            // .valhalla.Location.SideOfStreet side_of_street = 4;
            if (this_._internal_side_of_street() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_side_of_street());
            }
            // bool begin_node = 7;
            if (this_._internal_begin_node() != 0) {
              total_size += 2;
            }
            // bool end_node = 8;
            if (this_._internal_end_node() != 0) {
              total_size += 2;
            }
            // int32 outbound_reach = 11;
            if (this_._internal_outbound_reach() != 0) {
              total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
                  this_._internal_outbound_reach());
            }
            // int32 inbound_reach = 12;
            if (this_._internal_inbound_reach() != 0) {
              total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
                  this_._internal_inbound_reach());
            }
            // float heading = 13;
            if (::absl::bit_cast<::uint32_t>(this_._internal_heading()) != 0) {
              total_size += 5;
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void PathEdge::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<PathEdge*>(&to_msg);
  auto& from = static_cast<const PathEdge&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.PathEdge)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_names()->MergeFrom(from._internal_names());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(from._impl_.ll_ != nullptr);
    if (_this->_impl_.ll_ == nullptr) {
      _this->_impl_.ll_ =
          ::google::protobuf::MessageLite::CopyConstruct<::valhalla::LatLng>(arena, *from._impl_.ll_);
    } else {
      _this->_impl_.ll_->MergeFrom(*from._impl_.ll_);
    }
  }
  if (from._internal_graph_id() != 0) {
    _this->_impl_.graph_id_ = from._impl_.graph_id_;
  }
  if (::absl::bit_cast<::uint64_t>(from._internal_percent_along()) != 0) {
    _this->_impl_.percent_along_ = from._impl_.percent_along_;
  }
  if (::absl::bit_cast<::uint64_t>(from._internal_distance()) != 0) {
    _this->_impl_.distance_ = from._impl_.distance_;
  }
  if (from._internal_side_of_street() != 0) {
    _this->_impl_.side_of_street_ = from._impl_.side_of_street_;
  }
  if (from._internal_begin_node() != 0) {
    _this->_impl_.begin_node_ = from._impl_.begin_node_;
  }
  if (from._internal_end_node() != 0) {
    _this->_impl_.end_node_ = from._impl_.end_node_;
  }
  if (from._internal_outbound_reach() != 0) {
    _this->_impl_.outbound_reach_ = from._impl_.outbound_reach_;
  }
  if (from._internal_inbound_reach() != 0) {
    _this->_impl_.inbound_reach_ = from._impl_.inbound_reach_;
  }
  if (::absl::bit_cast<::uint32_t>(from._internal_heading()) != 0) {
    _this->_impl_.heading_ = from._impl_.heading_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PathEdge::CopyFrom(const PathEdge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.PathEdge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PathEdge::InternalSwap(PathEdge* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.names_.InternalSwap(&other->_impl_.names_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.heading_)
      + sizeof(PathEdge::_impl_.heading_)
      - PROTOBUF_FIELD_OFFSET(PathEdge, _impl_.ll_)>(
          reinterpret_cast<char*>(&_impl_.ll_),
          reinterpret_cast<char*>(&other->_impl_.ll_));
}

// ===================================================================

class Correlation::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Correlation>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Correlation, _impl_._has_bits_);
};

Correlation::Correlation(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.Correlation)
}
inline PROTOBUF_NDEBUG_INLINE Correlation::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::Correlation& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        edges_{visibility, arena, from.edges_},
        filtered_edges_{visibility, arena, from.filtered_edges_} {}

Correlation::Correlation(
    ::google::protobuf::Arena* arena,
    const Correlation& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Correlation* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.projected_ll_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::LatLng>(
                              arena, *from._impl_.projected_ll_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, original_index_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, original_index_),
           offsetof(Impl_, waypoint_index_) -
               offsetof(Impl_, original_index_) +
               sizeof(Impl_::waypoint_index_));

  // @@protoc_insertion_point(copy_constructor:valhalla.Correlation)
}
inline PROTOBUF_NDEBUG_INLINE Correlation::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        edges_{visibility, arena},
        filtered_edges_{visibility, arena} {}

inline void Correlation::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, projected_ll_),
           0,
           offsetof(Impl_, waypoint_index_) -
               offsetof(Impl_, projected_ll_) +
               sizeof(Impl_::waypoint_index_));
}
Correlation::~Correlation() {
  // @@protoc_insertion_point(destructor:valhalla.Correlation)
  SharedDtor(*this);
}
inline void Correlation::SharedDtor(MessageLite& self) {
  Correlation& this_ = static_cast<Correlation&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.projected_ll_;
  this_._impl_.~Impl_();
}

inline void* Correlation::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) Correlation(arena);
}
constexpr auto Correlation::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(Correlation, _impl_.edges_) +
          decltype(Correlation::_impl_.edges_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Correlation, _impl_.filtered_edges_) +
          decltype(Correlation::_impl_.filtered_edges_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(Correlation), alignof(Correlation), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&Correlation::PlacementNew_,
                                 sizeof(Correlation),
                                 alignof(Correlation));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<21> Correlation::_class_data_ = {
    {
        &_Correlation_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &Correlation::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<Correlation>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &Correlation::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<Correlation>(), &Correlation::ByteSizeLong,
            &Correlation::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(Correlation, _impl_._cached_size_),
        true,
    },
    "valhalla.Correlation",
};
const ::google::protobuf::internal::ClassData* Correlation::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 3, 0, 2> Correlation::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Correlation, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::Correlation>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // uint32 waypoint_index = 8;
    {::_pbi::TcParser::FastV32S1,
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(Correlation, _impl_.waypoint_index_)}},
    // repeated .valhalla.PathEdge edges = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(Correlation, _impl_.edges_)}},
    // repeated .valhalla.PathEdge filtered_edges = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 1, PROTOBUF_FIELD_OFFSET(Correlation, _impl_.filtered_edges_)}},
    // uint32 original_index = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(Correlation, _impl_.original_index_)}},
    // .valhalla.LatLng projected_ll = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 0, 2, PROTOBUF_FIELD_OFFSET(Correlation, _impl_.projected_ll_)}},
    // uint32 leg_shape_index = 5;
    {::_pbi::TcParser::FastV32S1,
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(Correlation, _impl_.leg_shape_index_)}},
    // double distance_from_leg_origin = 6;
    {::_pbi::TcParser::FastF64S1,
     {49, 63, 0, PROTOBUF_FIELD_OFFSET(Correlation, _impl_.distance_from_leg_origin_)}},
    // uint32 route_index = 7;
    {::_pbi::TcParser::FastV32S1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(Correlation, _impl_.route_index_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .valhalla.PathEdge edges = 1;
    {PROTOBUF_FIELD_OFFSET(Correlation, _impl_.edges_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .valhalla.PathEdge filtered_edges = 2;
    {PROTOBUF_FIELD_OFFSET(Correlation, _impl_.filtered_edges_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // uint32 original_index = 3;
    {PROTOBUF_FIELD_OFFSET(Correlation, _impl_.original_index_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // .valhalla.LatLng projected_ll = 4;
    {PROTOBUF_FIELD_OFFSET(Correlation, _impl_.projected_ll_), _Internal::kHasBitsOffset + 0, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // uint32 leg_shape_index = 5;
    {PROTOBUF_FIELD_OFFSET(Correlation, _impl_.leg_shape_index_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // double distance_from_leg_origin = 6;
    {PROTOBUF_FIELD_OFFSET(Correlation, _impl_.distance_from_leg_origin_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // uint32 route_index = 7;
    {PROTOBUF_FIELD_OFFSET(Correlation, _impl_.route_index_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 waypoint_index = 8;
    {PROTOBUF_FIELD_OFFSET(Correlation, _impl_.waypoint_index_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::PathEdge>()},
    {::_pbi::TcParser::GetTable<::valhalla::PathEdge>()},
    {::_pbi::TcParser::GetTable<::valhalla::LatLng>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void Correlation::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Correlation)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.edges_.Clear();
  _impl_.filtered_edges_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.projected_ll_ != nullptr);
    _impl_.projected_ll_->Clear();
  }
  ::memset(&_impl_.original_index_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.waypoint_index_) -
      reinterpret_cast<char*>(&_impl_.original_index_)) + sizeof(_impl_.waypoint_index_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Correlation::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Correlation& this_ = static_cast<const Correlation&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Correlation::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Correlation& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.Correlation)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // repeated .valhalla.PathEdge edges = 1;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_edges_size());
               i < n; i++) {
            const auto& repfield = this_._internal_edges().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    1, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .valhalla.PathEdge filtered_edges = 2;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_filtered_edges_size());
               i < n; i++) {
            const auto& repfield = this_._internal_filtered_edges().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    2, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // uint32 original_index = 3;
          if (this_._internal_original_index() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                3, this_._internal_original_index(), target);
          }

          cached_has_bits = this_._impl_._has_bits_[0];
          // .valhalla.LatLng projected_ll = 4;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                4, *this_._impl_.projected_ll_, this_._impl_.projected_ll_->GetCachedSize(), target,
                stream);
          }

          // uint32 leg_shape_index = 5;
          if (this_._internal_leg_shape_index() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                5, this_._internal_leg_shape_index(), target);
          }

          // double distance_from_leg_origin = 6;
          if (::absl::bit_cast<::uint64_t>(this_._internal_distance_from_leg_origin()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                6, this_._internal_distance_from_leg_origin(), target);
          }

          // uint32 route_index = 7;
          if (this_._internal_route_index() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                7, this_._internal_route_index(), target);
          }

          // uint32 waypoint_index = 8;
          if (this_._internal_waypoint_index() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                8, this_._internal_waypoint_index(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.Correlation)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Correlation::ByteSizeLong(const MessageLite& base) {
          const Correlation& this_ = static_cast<const Correlation&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Correlation::ByteSizeLong() const {
          const Correlation& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.Correlation)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .valhalla.PathEdge edges = 1;
            {
              total_size += 1UL * this_._internal_edges_size();
              for (const auto& msg : this_._internal_edges()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .valhalla.PathEdge filtered_edges = 2;
            {
              total_size += 1UL * this_._internal_filtered_edges_size();
              for (const auto& msg : this_._internal_filtered_edges()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
           {
            // .valhalla.LatLng projected_ll = 4;
            cached_has_bits = this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.projected_ll_);
            }
          }
           {
            // uint32 original_index = 3;
            if (this_._internal_original_index() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_original_index());
            }
            // uint32 leg_shape_index = 5;
            if (this_._internal_leg_shape_index() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_leg_shape_index());
            }
            // double distance_from_leg_origin = 6;
            if (::absl::bit_cast<::uint64_t>(this_._internal_distance_from_leg_origin()) != 0) {
              total_size += 9;
            }
            // uint32 route_index = 7;
            if (this_._internal_route_index() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_route_index());
            }
            // uint32 waypoint_index = 8;
            if (this_._internal_waypoint_index() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_waypoint_index());
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void Correlation::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Correlation*>(&to_msg);
  auto& from = static_cast<const Correlation&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Correlation)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_edges()->MergeFrom(
      from._internal_edges());
  _this->_internal_mutable_filtered_edges()->MergeFrom(
      from._internal_filtered_edges());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(from._impl_.projected_ll_ != nullptr);
    if (_this->_impl_.projected_ll_ == nullptr) {
      _this->_impl_.projected_ll_ =
          ::google::protobuf::MessageLite::CopyConstruct<::valhalla::LatLng>(arena, *from._impl_.projected_ll_);
    } else {
      _this->_impl_.projected_ll_->MergeFrom(*from._impl_.projected_ll_);
    }
  }
  if (from._internal_original_index() != 0) {
    _this->_impl_.original_index_ = from._impl_.original_index_;
  }
  if (from._internal_leg_shape_index() != 0) {
    _this->_impl_.leg_shape_index_ = from._impl_.leg_shape_index_;
  }
  if (::absl::bit_cast<::uint64_t>(from._internal_distance_from_leg_origin()) != 0) {
    _this->_impl_.distance_from_leg_origin_ = from._impl_.distance_from_leg_origin_;
  }
  if (from._internal_route_index() != 0) {
    _this->_impl_.route_index_ = from._impl_.route_index_;
  }
  if (from._internal_waypoint_index() != 0) {
    _this->_impl_.waypoint_index_ = from._impl_.waypoint_index_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Correlation::CopyFrom(const Correlation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Correlation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Correlation::InternalSwap(Correlation* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.edges_.InternalSwap(&other->_impl_.edges_);
  _impl_.filtered_edges_.InternalSwap(&other->_impl_.filtered_edges_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Correlation, _impl_.waypoint_index_)
      + sizeof(Correlation::_impl_.waypoint_index_)
      - PROTOBUF_FIELD_OFFSET(Correlation, _impl_.projected_ll_)>(
          reinterpret_cast<char*>(&_impl_.projected_ll_),
          reinterpret_cast<char*>(&other->_impl_.projected_ll_));
}

// ===================================================================

class Location::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Location>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Location, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::valhalla::Location, _impl_._oneof_case_);
};

Location::Location(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.Location)
}
inline PROTOBUF_NDEBUG_INLINE Location::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::Location& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        name_(arena, from.name_),
        street_(arena, from.street_),
        date_time_(arena, from.date_time_),
        time_zone_offset_(arena, from.time_zone_offset_),
        time_zone_name_(arena, from.time_zone_name_),
        has_heading_{},
        has_heading_tolerance_{},
        has_node_snap_tolerance_{},
        has_minimum_reachability_{},
        has_radius_{},
        has_accuracy_{},
        has_time_{},
        has_search_cutoff_{},
        has_street_side_tolerance_{},
        has_street_side_max_distance_{},
        has_preferred_layer_{},
        has_street_side_cutoff_{},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1], from._oneof_case_[2], from._oneof_case_[3], from._oneof_case_[4], from._oneof_case_[5], from._oneof_case_[6], from._oneof_case_[7], from._oneof_case_[8], from._oneof_case_[9], from._oneof_case_[10], from._oneof_case_[11]} {}

Location::Location(
    ::google::protobuf::Arena* arena,
    const Location& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Location* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.ll_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::LatLng>(
                              arena, *from._impl_.ll_)
                        : nullptr;
  _impl_.display_ll_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::LatLng>(
                              arena, *from._impl_.display_ll_)
                        : nullptr;
  _impl_.search_filter_ = (cached_has_bits & 0x00000004u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::SearchFilter>(
                              arena, *from._impl_.search_filter_)
                        : nullptr;
  _impl_.correlation_ = (cached_has_bits & 0x00000008u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::Correlation>(
                              arena, *from._impl_.correlation_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, type_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, type_),
           offsetof(Impl_, waiting_secs_) -
               offsetof(Impl_, type_) +
               sizeof(Impl_::waiting_secs_));
  switch (has_heading_case()) {
    case HAS_HEADING_NOT_SET:
      break;
      case kHeading:
        _impl_.has_heading_.heading_ = from._impl_.has_heading_.heading_;
        break;
  }
  switch (has_heading_tolerance_case()) {
    case HAS_HEADING_TOLERANCE_NOT_SET:
      break;
      case kHeadingTolerance:
        _impl_.has_heading_tolerance_.heading_tolerance_ = from._impl_.has_heading_tolerance_.heading_tolerance_;
        break;
  }
  switch (has_node_snap_tolerance_case()) {
    case HAS_NODE_SNAP_TOLERANCE_NOT_SET:
      break;
      case kNodeSnapTolerance:
        _impl_.has_node_snap_tolerance_.node_snap_tolerance_ = from._impl_.has_node_snap_tolerance_.node_snap_tolerance_;
        break;
  }
  switch (has_minimum_reachability_case()) {
    case HAS_MINIMUM_REACHABILITY_NOT_SET:
      break;
      case kMinimumReachability:
        _impl_.has_minimum_reachability_.minimum_reachability_ = from._impl_.has_minimum_reachability_.minimum_reachability_;
        break;
  }
  switch (has_radius_case()) {
    case HAS_RADIUS_NOT_SET:
      break;
      case kRadius:
        _impl_.has_radius_.radius_ = from._impl_.has_radius_.radius_;
        break;
  }
  switch (has_accuracy_case()) {
    case HAS_ACCURACY_NOT_SET:
      break;
      case kAccuracy:
        _impl_.has_accuracy_.accuracy_ = from._impl_.has_accuracy_.accuracy_;
        break;
  }
  switch (has_time_case()) {
    case HAS_TIME_NOT_SET:
      break;
      case kTime:
        _impl_.has_time_.time_ = from._impl_.has_time_.time_;
        break;
  }
  switch (has_search_cutoff_case()) {
    case HAS_SEARCH_CUTOFF_NOT_SET:
      break;
      case kSearchCutoff:
        _impl_.has_search_cutoff_.search_cutoff_ = from._impl_.has_search_cutoff_.search_cutoff_;
        break;
  }
  switch (has_street_side_tolerance_case()) {
    case HAS_STREET_SIDE_TOLERANCE_NOT_SET:
      break;
      case kStreetSideTolerance:
        _impl_.has_street_side_tolerance_.street_side_tolerance_ = from._impl_.has_street_side_tolerance_.street_side_tolerance_;
        break;
  }
  switch (has_street_side_max_distance_case()) {
    case HAS_STREET_SIDE_MAX_DISTANCE_NOT_SET:
      break;
      case kStreetSideMaxDistance:
        _impl_.has_street_side_max_distance_.street_side_max_distance_ = from._impl_.has_street_side_max_distance_.street_side_max_distance_;
        break;
  }
  switch (has_preferred_layer_case()) {
    case HAS_PREFERRED_LAYER_NOT_SET:
      break;
      case kPreferredLayer:
        _impl_.has_preferred_layer_.preferred_layer_ = from._impl_.has_preferred_layer_.preferred_layer_;
        break;
  }
  switch (has_street_side_cutoff_case()) {
    case HAS_STREET_SIDE_CUTOFF_NOT_SET:
      break;
      case kStreetSideCutoff:
        _impl_.has_street_side_cutoff_.street_side_cutoff_ = from._impl_.has_street_side_cutoff_.street_side_cutoff_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:valhalla.Location)
}
inline PROTOBUF_NDEBUG_INLINE Location::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        name_(arena),
        street_(arena),
        date_time_(arena),
        time_zone_offset_(arena),
        time_zone_name_(arena),
        has_heading_{},
        has_heading_tolerance_{},
        has_node_snap_tolerance_{},
        has_minimum_reachability_{},
        has_radius_{},
        has_accuracy_{},
        has_time_{},
        has_search_cutoff_{},
        has_street_side_tolerance_{},
        has_street_side_max_distance_{},
        has_preferred_layer_{},
        has_street_side_cutoff_{},
        _oneof_case_{} {}

inline void Location::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, ll_),
           0,
           offsetof(Impl_, waiting_secs_) -
               offsetof(Impl_, ll_) +
               sizeof(Impl_::waiting_secs_));
}
Location::~Location() {
  // @@protoc_insertion_point(destructor:valhalla.Location)
  SharedDtor(*this);
}
inline void Location::SharedDtor(MessageLite& self) {
  Location& this_ = static_cast<Location&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.name_.Destroy();
  this_._impl_.street_.Destroy();
  this_._impl_.date_time_.Destroy();
  this_._impl_.time_zone_offset_.Destroy();
  this_._impl_.time_zone_name_.Destroy();
  delete this_._impl_.ll_;
  delete this_._impl_.display_ll_;
  delete this_._impl_.search_filter_;
  delete this_._impl_.correlation_;
  if (this_.has_has_heading()) {
    this_.clear_has_heading();
  }
  if (this_.has_has_heading_tolerance()) {
    this_.clear_has_heading_tolerance();
  }
  if (this_.has_has_node_snap_tolerance()) {
    this_.clear_has_node_snap_tolerance();
  }
  if (this_.has_has_minimum_reachability()) {
    this_.clear_has_minimum_reachability();
  }
  if (this_.has_has_radius()) {
    this_.clear_has_radius();
  }
  if (this_.has_has_accuracy()) {
    this_.clear_has_accuracy();
  }
  if (this_.has_has_time()) {
    this_.clear_has_time();
  }
  if (this_.has_has_search_cutoff()) {
    this_.clear_has_search_cutoff();
  }
  if (this_.has_has_street_side_tolerance()) {
    this_.clear_has_street_side_tolerance();
  }
  if (this_.has_has_street_side_max_distance()) {
    this_.clear_has_street_side_max_distance();
  }
  if (this_.has_has_preferred_layer()) {
    this_.clear_has_preferred_layer();
  }
  if (this_.has_has_street_side_cutoff()) {
    this_.clear_has_street_side_cutoff();
  }
  this_._impl_.~Impl_();
}

void Location::clear_has_heading() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Location)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_heading_case()) {
    case kHeading: {
      // No need to clear
      break;
    }
    case HAS_HEADING_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = HAS_HEADING_NOT_SET;
}

void Location::clear_has_heading_tolerance() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Location)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_heading_tolerance_case()) {
    case kHeadingTolerance: {
      // No need to clear
      break;
    }
    case HAS_HEADING_TOLERANCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = HAS_HEADING_TOLERANCE_NOT_SET;
}

void Location::clear_has_node_snap_tolerance() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Location)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_node_snap_tolerance_case()) {
    case kNodeSnapTolerance: {
      // No need to clear
      break;
    }
    case HAS_NODE_SNAP_TOLERANCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[2] = HAS_NODE_SNAP_TOLERANCE_NOT_SET;
}

void Location::clear_has_minimum_reachability() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Location)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_minimum_reachability_case()) {
    case kMinimumReachability: {
      // No need to clear
      break;
    }
    case HAS_MINIMUM_REACHABILITY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[3] = HAS_MINIMUM_REACHABILITY_NOT_SET;
}

void Location::clear_has_radius() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Location)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_radius_case()) {
    case kRadius: {
      // No need to clear
      break;
    }
    case HAS_RADIUS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[4] = HAS_RADIUS_NOT_SET;
}

void Location::clear_has_accuracy() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Location)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_accuracy_case()) {
    case kAccuracy: {
      // No need to clear
      break;
    }
    case HAS_ACCURACY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[5] = HAS_ACCURACY_NOT_SET;
}

void Location::clear_has_time() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Location)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_time_case()) {
    case kTime: {
      // No need to clear
      break;
    }
    case HAS_TIME_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[6] = HAS_TIME_NOT_SET;
}

void Location::clear_has_search_cutoff() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Location)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_search_cutoff_case()) {
    case kSearchCutoff: {
      // No need to clear
      break;
    }
    case HAS_SEARCH_CUTOFF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[7] = HAS_SEARCH_CUTOFF_NOT_SET;
}

void Location::clear_has_street_side_tolerance() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Location)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_street_side_tolerance_case()) {
    case kStreetSideTolerance: {
      // No need to clear
      break;
    }
    case HAS_STREET_SIDE_TOLERANCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[8] = HAS_STREET_SIDE_TOLERANCE_NOT_SET;
}

void Location::clear_has_street_side_max_distance() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Location)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_street_side_max_distance_case()) {
    case kStreetSideMaxDistance: {
      // No need to clear
      break;
    }
    case HAS_STREET_SIDE_MAX_DISTANCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[9] = HAS_STREET_SIDE_MAX_DISTANCE_NOT_SET;
}

void Location::clear_has_preferred_layer() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Location)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_preferred_layer_case()) {
    case kPreferredLayer: {
      // No need to clear
      break;
    }
    case HAS_PREFERRED_LAYER_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[10] = HAS_PREFERRED_LAYER_NOT_SET;
}

void Location::clear_has_street_side_cutoff() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.Location)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (has_street_side_cutoff_case()) {
    case kStreetSideCutoff: {
      // No need to clear
      break;
    }
    case HAS_STREET_SIDE_CUTOFF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[11] = HAS_STREET_SIDE_CUTOFF_NOT_SET;
}


inline void* Location::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) Location(arena);
}
constexpr auto Location::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(Location),
                                            alignof(Location));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<18> Location::_class_data_ = {
    {
        &_Location_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &Location::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<Location>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &Location::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<Location>(), &Location::ByteSizeLong,
            &Location::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(Location, _impl_._cached_size_),
        true,
    },
    "valhalla.Location",
};
const ::google::protobuf::internal::ClassData* Location::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 26, 4, 99, 7> Location::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Location, _impl_._has_bits_),
    0, // no _extensions_
    92, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    3221260256,  // skipmap
    offsetof(decltype(_table_), field_entries),
    26,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::Location>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .valhalla.LatLng ll = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(Location, _impl_.ll_)}},
    // .valhalla.Location.Type type = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(Location, _impl_.type_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // string name = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(Location, _impl_.name_)}},
    // string street = 5;
    {::_pbi::TcParser::FastUS1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(Location, _impl_.street_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // string date_time = 12;
    {::_pbi::TcParser::FastUS1,
     {98, 63, 0, PROTOBUF_FIELD_OFFSET(Location, _impl_.date_time_)}},
    // .valhalla.Location.SideOfStreet side_of_street = 13;
    {::_pbi::TcParser::FastV32S1,
     {104, 63, 0, PROTOBUF_FIELD_OFFSET(Location, _impl_.side_of_street_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // bool skip_ranking_candidates = 21;
    {::_pbi::TcParser::FastV8S2,
     {424, 63, 0, PROTOBUF_FIELD_OFFSET(Location, _impl_.skip_ranking_candidates_)}},
    // .valhalla.Location.PreferredSide preferred_side = 22;
    {::_pbi::TcParser::FastV32S2,
     {432, 63, 0, PROTOBUF_FIELD_OFFSET(Location, _impl_.preferred_side_)}},
    // .valhalla.LatLng display_ll = 23;
    {::_pbi::TcParser::FastMtS2,
     {442, 1, 1, PROTOBUF_FIELD_OFFSET(Location, _impl_.display_ll_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // .valhalla.SearchFilter search_filter = 26;
    {::_pbi::TcParser::FastMtS2,
     {466, 2, 2, PROTOBUF_FIELD_OFFSET(Location, _impl_.search_filter_)}},
    // string time_zone_offset = 91;
    {::_pbi::TcParser::FastUS2,
     {1498, 63, 0, PROTOBUF_FIELD_OFFSET(Location, _impl_.time_zone_offset_)}},
    // string time_zone_name = 92;
    {::_pbi::TcParser::FastUS2,
     {1506, 63, 0, PROTOBUF_FIELD_OFFSET(Location, _impl_.time_zone_name_)}},
    // float waiting_secs = 29;
    {::_pbi::TcParser::FastF32S2,
     {493, 63, 0, PROTOBUF_FIELD_OFFSET(Location, _impl_.waiting_secs_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    90, 0, 1,
    65528, 23,
    65535, 65535
  }}, {{
    // .valhalla.LatLng ll = 1;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.ll_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .valhalla.Location.Type type = 2;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.type_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // uint32 heading = 3;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.has_heading_.heading_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // string name = 4;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.name_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string street = 5;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.street_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string date_time = 12;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.date_time_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .valhalla.Location.SideOfStreet side_of_street = 13;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.side_of_street_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // uint32 heading_tolerance = 14;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.has_heading_tolerance_.heading_tolerance_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // uint32 node_snap_tolerance = 15;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.has_node_snap_tolerance_.node_snap_tolerance_), _Internal::kOneofCaseOffset + 8, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // uint32 minimum_reachability = 17;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.has_minimum_reachability_.minimum_reachability_), _Internal::kOneofCaseOffset + 12, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // uint32 radius = 18;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.has_radius_.radius_), _Internal::kOneofCaseOffset + 16, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // uint32 accuracy = 19;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.has_accuracy_.accuracy_), _Internal::kOneofCaseOffset + 20, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // double time = 20;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.has_time_.time_), _Internal::kOneofCaseOffset + 24, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kDouble)},
    // bool skip_ranking_candidates = 21;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.skip_ranking_candidates_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // .valhalla.Location.PreferredSide preferred_side = 22;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.preferred_side_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .valhalla.LatLng display_ll = 23;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.display_ll_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // uint32 search_cutoff = 24;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.has_search_cutoff_.search_cutoff_), _Internal::kOneofCaseOffset + 28, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // uint32 street_side_tolerance = 25;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.has_street_side_tolerance_.street_side_tolerance_), _Internal::kOneofCaseOffset + 32, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // .valhalla.SearchFilter search_filter = 26;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.search_filter_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // uint32 street_side_max_distance = 27;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.has_street_side_max_distance_.street_side_max_distance_), _Internal::kOneofCaseOffset + 36, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // int32 preferred_layer = 28;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.has_preferred_layer_.preferred_layer_), _Internal::kOneofCaseOffset + 40, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kInt32)},
    // float waiting_secs = 29;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.waiting_secs_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // .valhalla.RoadClass street_side_cutoff = 30;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.has_street_side_cutoff_.street_side_cutoff_), _Internal::kOneofCaseOffset + 44, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kOpenEnum)},
    // .valhalla.Correlation correlation = 90;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.correlation_), _Internal::kHasBitsOffset + 3, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // string time_zone_offset = 91;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.time_zone_offset_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string time_zone_name = 92;
    {PROTOBUF_FIELD_OFFSET(Location, _impl_.time_zone_name_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::LatLng>()},
    {::_pbi::TcParser::GetTable<::valhalla::LatLng>()},
    {::_pbi::TcParser::GetTable<::valhalla::SearchFilter>()},
    {::_pbi::TcParser::GetTable<::valhalla::Correlation>()},
  }}, {{
    "\21\0\0\0\4\6\11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\20\16\0\0\0\0\0"
    "valhalla.Location"
    "name"
    "street"
    "date_time"
    "time_zone_offset"
    "time_zone_name"
  }},
};

PROTOBUF_NOINLINE void Location::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Location)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.street_.ClearToEmpty();
  _impl_.date_time_.ClearToEmpty();
  _impl_.time_zone_offset_.ClearToEmpty();
  _impl_.time_zone_name_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.ll_ != nullptr);
      _impl_.ll_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.display_ll_ != nullptr);
      _impl_.display_ll_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.search_filter_ != nullptr);
      _impl_.search_filter_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.correlation_ != nullptr);
      _impl_.correlation_->Clear();
    }
  }
  ::memset(&_impl_.type_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.waiting_secs_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.waiting_secs_));
  clear_has_heading();
  clear_has_heading_tolerance();
  clear_has_node_snap_tolerance();
  clear_has_minimum_reachability();
  clear_has_radius();
  clear_has_accuracy();
  clear_has_time();
  clear_has_search_cutoff();
  clear_has_street_side_tolerance();
  clear_has_street_side_max_distance();
  clear_has_preferred_layer();
  clear_has_street_side_cutoff();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Location::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Location& this_ = static_cast<const Location&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Location::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Location& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.Location)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // .valhalla.LatLng ll = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.ll_, this_._impl_.ll_->GetCachedSize(), target,
                stream);
          }

          // .valhalla.Location.Type type = 2;
          if (this_._internal_type() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                2, this_._internal_type(), target);
          }

          // uint32 heading = 3;
          if (this_.has_heading_case() == kHeading) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                3, this_._internal_heading(), target);
          }

          // string name = 4;
          if (!this_._internal_name().empty()) {
            const std::string& _s = this_._internal_name();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.Location.name");
            target = stream->WriteStringMaybeAliased(4, _s, target);
          }

          // string street = 5;
          if (!this_._internal_street().empty()) {
            const std::string& _s = this_._internal_street();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.Location.street");
            target = stream->WriteStringMaybeAliased(5, _s, target);
          }

          // string date_time = 12;
          if (!this_._internal_date_time().empty()) {
            const std::string& _s = this_._internal_date_time();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.Location.date_time");
            target = stream->WriteStringMaybeAliased(12, _s, target);
          }

          // .valhalla.Location.SideOfStreet side_of_street = 13;
          if (this_._internal_side_of_street() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                13, this_._internal_side_of_street(), target);
          }

          // uint32 heading_tolerance = 14;
          if (this_.has_heading_tolerance_case() == kHeadingTolerance) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                14, this_._internal_heading_tolerance(), target);
          }

          // uint32 node_snap_tolerance = 15;
          if (this_.has_node_snap_tolerance_case() == kNodeSnapTolerance) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                15, this_._internal_node_snap_tolerance(), target);
          }

          // uint32 minimum_reachability = 17;
          if (this_.has_minimum_reachability_case() == kMinimumReachability) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                17, this_._internal_minimum_reachability(), target);
          }

          // uint32 radius = 18;
          if (this_.has_radius_case() == kRadius) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                18, this_._internal_radius(), target);
          }

          // uint32 accuracy = 19;
          if (this_.has_accuracy_case() == kAccuracy) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                19, this_._internal_accuracy(), target);
          }

          // double time = 20;
          if (this_.has_time_case() == kTime) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                20, this_._internal_time(), target);
          }

          // bool skip_ranking_candidates = 21;
          if (this_._internal_skip_ranking_candidates() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                21, this_._internal_skip_ranking_candidates(), target);
          }

          // .valhalla.Location.PreferredSide preferred_side = 22;
          if (this_._internal_preferred_side() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                22, this_._internal_preferred_side(), target);
          }

          // .valhalla.LatLng display_ll = 23;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                23, *this_._impl_.display_ll_, this_._impl_.display_ll_->GetCachedSize(), target,
                stream);
          }

          // uint32 search_cutoff = 24;
          if (this_.has_search_cutoff_case() == kSearchCutoff) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                24, this_._internal_search_cutoff(), target);
          }

          // uint32 street_side_tolerance = 25;
          if (this_.has_street_side_tolerance_case() == kStreetSideTolerance) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                25, this_._internal_street_side_tolerance(), target);
          }

          // .valhalla.SearchFilter search_filter = 26;
          if (cached_has_bits & 0x00000004u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                26, *this_._impl_.search_filter_, this_._impl_.search_filter_->GetCachedSize(), target,
                stream);
          }

          // uint32 street_side_max_distance = 27;
          if (this_.has_street_side_max_distance_case() == kStreetSideMaxDistance) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                27, this_._internal_street_side_max_distance(), target);
          }

          // int32 preferred_layer = 28;
          if (this_.has_preferred_layer_case() == kPreferredLayer) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteInt32ToArray(
                28, this_._internal_preferred_layer(), target);
          }

          // float waiting_secs = 29;
          if (::absl::bit_cast<::uint32_t>(this_._internal_waiting_secs()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                29, this_._internal_waiting_secs(), target);
          }

          // .valhalla.RoadClass street_side_cutoff = 30;
          if (this_.has_street_side_cutoff_case() == kStreetSideCutoff) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                30, this_._internal_street_side_cutoff(), target);
          }

          // .valhalla.Correlation correlation = 90;
          if (cached_has_bits & 0x00000008u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                90, *this_._impl_.correlation_, this_._impl_.correlation_->GetCachedSize(), target,
                stream);
          }

          // string time_zone_offset = 91;
          if (!this_._internal_time_zone_offset().empty()) {
            const std::string& _s = this_._internal_time_zone_offset();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.Location.time_zone_offset");
            target = stream->WriteStringMaybeAliased(91, _s, target);
          }

          // string time_zone_name = 92;
          if (!this_._internal_time_zone_name().empty()) {
            const std::string& _s = this_._internal_time_zone_name();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.Location.time_zone_name");
            target = stream->WriteStringMaybeAliased(92, _s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.Location)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Location::ByteSizeLong(const MessageLite& base) {
          const Location& this_ = static_cast<const Location&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Location::ByteSizeLong() const {
          const Location& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.Location)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // string name = 4;
            if (!this_._internal_name().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_name());
            }
            // string street = 5;
            if (!this_._internal_street().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_street());
            }
            // string date_time = 12;
            if (!this_._internal_date_time().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_date_time());
            }
            // string time_zone_offset = 91;
            if (!this_._internal_time_zone_offset().empty()) {
              total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_time_zone_offset());
            }
            // string time_zone_name = 92;
            if (!this_._internal_time_zone_name().empty()) {
              total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_time_zone_name());
            }
          }
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x0000000fu) {
            // .valhalla.LatLng ll = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.ll_);
            }
            // .valhalla.LatLng display_ll = 23;
            if (cached_has_bits & 0x00000002u) {
              total_size += 2 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.display_ll_);
            }
            // .valhalla.SearchFilter search_filter = 26;
            if (cached_has_bits & 0x00000004u) {
              total_size += 2 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.search_filter_);
            }
            // .valhalla.Correlation correlation = 90;
            if (cached_has_bits & 0x00000008u) {
              total_size += 2 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.correlation_);
            }
          }
           {
            // .valhalla.Location.Type type = 2;
            if (this_._internal_type() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_type());
            }
            // .valhalla.Location.SideOfStreet side_of_street = 13;
            if (this_._internal_side_of_street() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_side_of_street());
            }
            // bool skip_ranking_candidates = 21;
            if (this_._internal_skip_ranking_candidates() != 0) {
              total_size += 3;
            }
            // .valhalla.Location.PreferredSide preferred_side = 22;
            if (this_._internal_preferred_side() != 0) {
              total_size += 2 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_preferred_side());
            }
            // float waiting_secs = 29;
            if (::absl::bit_cast<::uint32_t>(this_._internal_waiting_secs()) != 0) {
              total_size += 6;
            }
          }
          switch (this_.has_heading_case()) {
            // uint32 heading = 3;
            case kHeading: {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_heading());
              break;
            }
            case HAS_HEADING_NOT_SET: {
              break;
            }
          }
          switch (this_.has_heading_tolerance_case()) {
            // uint32 heading_tolerance = 14;
            case kHeadingTolerance: {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_heading_tolerance());
              break;
            }
            case HAS_HEADING_TOLERANCE_NOT_SET: {
              break;
            }
          }
          switch (this_.has_node_snap_tolerance_case()) {
            // uint32 node_snap_tolerance = 15;
            case kNodeSnapTolerance: {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_node_snap_tolerance());
              break;
            }
            case HAS_NODE_SNAP_TOLERANCE_NOT_SET: {
              break;
            }
          }
          switch (this_.has_minimum_reachability_case()) {
            // uint32 minimum_reachability = 17;
            case kMinimumReachability: {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_minimum_reachability());
              break;
            }
            case HAS_MINIMUM_REACHABILITY_NOT_SET: {
              break;
            }
          }
          switch (this_.has_radius_case()) {
            // uint32 radius = 18;
            case kRadius: {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_radius());
              break;
            }
            case HAS_RADIUS_NOT_SET: {
              break;
            }
          }
          switch (this_.has_accuracy_case()) {
            // uint32 accuracy = 19;
            case kAccuracy: {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_accuracy());
              break;
            }
            case HAS_ACCURACY_NOT_SET: {
              break;
            }
          }
          switch (this_.has_time_case()) {
            // double time = 20;
            case kTime: {
              total_size += 10;
              break;
            }
            case HAS_TIME_NOT_SET: {
              break;
            }
          }
          switch (this_.has_search_cutoff_case()) {
            // uint32 search_cutoff = 24;
            case kSearchCutoff: {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_search_cutoff());
              break;
            }
            case HAS_SEARCH_CUTOFF_NOT_SET: {
              break;
            }
          }
          switch (this_.has_street_side_tolerance_case()) {
            // uint32 street_side_tolerance = 25;
            case kStreetSideTolerance: {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_street_side_tolerance());
              break;
            }
            case HAS_STREET_SIDE_TOLERANCE_NOT_SET: {
              break;
            }
          }
          switch (this_.has_street_side_max_distance_case()) {
            // uint32 street_side_max_distance = 27;
            case kStreetSideMaxDistance: {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_street_side_max_distance());
              break;
            }
            case HAS_STREET_SIDE_MAX_DISTANCE_NOT_SET: {
              break;
            }
          }
          switch (this_.has_preferred_layer_case()) {
            // int32 preferred_layer = 28;
            case kPreferredLayer: {
              total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                              this_._internal_preferred_layer());
              break;
            }
            case HAS_PREFERRED_LAYER_NOT_SET: {
              break;
            }
          }
          switch (this_.has_street_side_cutoff_case()) {
            // .valhalla.RoadClass street_side_cutoff = 30;
            case kStreetSideCutoff: {
              total_size += 2 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_street_side_cutoff());
              break;
            }
            case HAS_STREET_SIDE_CUTOFF_NOT_SET: {
              break;
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void Location::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Location*>(&to_msg);
  auto& from = static_cast<const Location&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Location)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_street().empty()) {
    _this->_internal_set_street(from._internal_street());
  }
  if (!from._internal_date_time().empty()) {
    _this->_internal_set_date_time(from._internal_date_time());
  }
  if (!from._internal_time_zone_offset().empty()) {
    _this->_internal_set_time_zone_offset(from._internal_time_zone_offset());
  }
  if (!from._internal_time_zone_name().empty()) {
    _this->_internal_set_time_zone_name(from._internal_time_zone_name());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.ll_ != nullptr);
      if (_this->_impl_.ll_ == nullptr) {
        _this->_impl_.ll_ =
            ::google::protobuf::MessageLite::CopyConstruct<::valhalla::LatLng>(arena, *from._impl_.ll_);
      } else {
        _this->_impl_.ll_->MergeFrom(*from._impl_.ll_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.display_ll_ != nullptr);
      if (_this->_impl_.display_ll_ == nullptr) {
        _this->_impl_.display_ll_ =
            ::google::protobuf::MessageLite::CopyConstruct<::valhalla::LatLng>(arena, *from._impl_.display_ll_);
      } else {
        _this->_impl_.display_ll_->MergeFrom(*from._impl_.display_ll_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(from._impl_.search_filter_ != nullptr);
      if (_this->_impl_.search_filter_ == nullptr) {
        _this->_impl_.search_filter_ =
            ::google::protobuf::MessageLite::CopyConstruct<::valhalla::SearchFilter>(arena, *from._impl_.search_filter_);
      } else {
        _this->_impl_.search_filter_->MergeFrom(*from._impl_.search_filter_);
      }
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(from._impl_.correlation_ != nullptr);
      if (_this->_impl_.correlation_ == nullptr) {
        _this->_impl_.correlation_ =
            ::google::protobuf::MessageLite::CopyConstruct<::valhalla::Correlation>(arena, *from._impl_.correlation_);
      } else {
        _this->_impl_.correlation_->MergeFrom(*from._impl_.correlation_);
      }
    }
  }
  if (from._internal_type() != 0) {
    _this->_impl_.type_ = from._impl_.type_;
  }
  if (from._internal_side_of_street() != 0) {
    _this->_impl_.side_of_street_ = from._impl_.side_of_street_;
  }
  if (from._internal_skip_ranking_candidates() != 0) {
    _this->_impl_.skip_ranking_candidates_ = from._impl_.skip_ranking_candidates_;
  }
  if (from._internal_preferred_side() != 0) {
    _this->_impl_.preferred_side_ = from._impl_.preferred_side_;
  }
  if (::absl::bit_cast<::uint32_t>(from._internal_waiting_secs()) != 0) {
    _this->_impl_.waiting_secs_ = from._impl_.waiting_secs_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_heading();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kHeading: {
        _this->_impl_.has_heading_.heading_ = from._impl_.has_heading_.heading_;
        break;
      }
      case HAS_HEADING_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_heading_tolerance();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kHeadingTolerance: {
        _this->_impl_.has_heading_tolerance_.heading_tolerance_ = from._impl_.has_heading_tolerance_.heading_tolerance_;
        break;
      }
      case HAS_HEADING_TOLERANCE_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[2]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[2];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_node_snap_tolerance();
      }
      _this->_impl_._oneof_case_[2] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kNodeSnapTolerance: {
        _this->_impl_.has_node_snap_tolerance_.node_snap_tolerance_ = from._impl_.has_node_snap_tolerance_.node_snap_tolerance_;
        break;
      }
      case HAS_NODE_SNAP_TOLERANCE_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[3]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[3];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_minimum_reachability();
      }
      _this->_impl_._oneof_case_[3] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kMinimumReachability: {
        _this->_impl_.has_minimum_reachability_.minimum_reachability_ = from._impl_.has_minimum_reachability_.minimum_reachability_;
        break;
      }
      case HAS_MINIMUM_REACHABILITY_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[4]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[4];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_radius();
      }
      _this->_impl_._oneof_case_[4] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kRadius: {
        _this->_impl_.has_radius_.radius_ = from._impl_.has_radius_.radius_;
        break;
      }
      case HAS_RADIUS_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[5]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[5];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_accuracy();
      }
      _this->_impl_._oneof_case_[5] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kAccuracy: {
        _this->_impl_.has_accuracy_.accuracy_ = from._impl_.has_accuracy_.accuracy_;
        break;
      }
      case HAS_ACCURACY_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[6]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[6];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_time();
      }
      _this->_impl_._oneof_case_[6] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kTime: {
        _this->_impl_.has_time_.time_ = from._impl_.has_time_.time_;
        break;
      }
      case HAS_TIME_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[7]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[7];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_search_cutoff();
      }
      _this->_impl_._oneof_case_[7] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kSearchCutoff: {
        _this->_impl_.has_search_cutoff_.search_cutoff_ = from._impl_.has_search_cutoff_.search_cutoff_;
        break;
      }
      case HAS_SEARCH_CUTOFF_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[8]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[8];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_street_side_tolerance();
      }
      _this->_impl_._oneof_case_[8] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kStreetSideTolerance: {
        _this->_impl_.has_street_side_tolerance_.street_side_tolerance_ = from._impl_.has_street_side_tolerance_.street_side_tolerance_;
        break;
      }
      case HAS_STREET_SIDE_TOLERANCE_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[9]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[9];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_street_side_max_distance();
      }
      _this->_impl_._oneof_case_[9] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kStreetSideMaxDistance: {
        _this->_impl_.has_street_side_max_distance_.street_side_max_distance_ = from._impl_.has_street_side_max_distance_.street_side_max_distance_;
        break;
      }
      case HAS_STREET_SIDE_MAX_DISTANCE_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[10]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[10];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_preferred_layer();
      }
      _this->_impl_._oneof_case_[10] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kPreferredLayer: {
        _this->_impl_.has_preferred_layer_.preferred_layer_ = from._impl_.has_preferred_layer_.preferred_layer_;
        break;
      }
      case HAS_PREFERRED_LAYER_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[11]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[11];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_has_street_side_cutoff();
      }
      _this->_impl_._oneof_case_[11] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kStreetSideCutoff: {
        _this->_impl_.has_street_side_cutoff_.street_side_cutoff_ = from._impl_.has_street_side_cutoff_.street_side_cutoff_;
        break;
      }
      case HAS_STREET_SIDE_CUTOFF_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Location::CopyFrom(const Location& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Location)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Location::InternalSwap(Location* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.street_, &other->_impl_.street_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.date_time_, &other->_impl_.date_time_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.time_zone_offset_, &other->_impl_.time_zone_offset_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.time_zone_name_, &other->_impl_.time_zone_name_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Location, _impl_.waiting_secs_)
      + sizeof(Location::_impl_.waiting_secs_)
      - PROTOBUF_FIELD_OFFSET(Location, _impl_.ll_)>(
          reinterpret_cast<char*>(&_impl_.ll_),
          reinterpret_cast<char*>(&other->_impl_.ll_));
  swap(_impl_.has_heading_, other->_impl_.has_heading_);
  swap(_impl_.has_heading_tolerance_, other->_impl_.has_heading_tolerance_);
  swap(_impl_.has_node_snap_tolerance_, other->_impl_.has_node_snap_tolerance_);
  swap(_impl_.has_minimum_reachability_, other->_impl_.has_minimum_reachability_);
  swap(_impl_.has_radius_, other->_impl_.has_radius_);
  swap(_impl_.has_accuracy_, other->_impl_.has_accuracy_);
  swap(_impl_.has_time_, other->_impl_.has_time_);
  swap(_impl_.has_search_cutoff_, other->_impl_.has_search_cutoff_);
  swap(_impl_.has_street_side_tolerance_, other->_impl_.has_street_side_tolerance_);
  swap(_impl_.has_street_side_max_distance_, other->_impl_.has_street_side_max_distance_);
  swap(_impl_.has_preferred_layer_, other->_impl_.has_preferred_layer_);
  swap(_impl_.has_street_side_cutoff_, other->_impl_.has_street_side_cutoff_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
  swap(_impl_._oneof_case_[2], other->_impl_._oneof_case_[2]);
  swap(_impl_._oneof_case_[3], other->_impl_._oneof_case_[3]);
  swap(_impl_._oneof_case_[4], other->_impl_._oneof_case_[4]);
  swap(_impl_._oneof_case_[5], other->_impl_._oneof_case_[5]);
  swap(_impl_._oneof_case_[6], other->_impl_._oneof_case_[6]);
  swap(_impl_._oneof_case_[7], other->_impl_._oneof_case_[7]);
  swap(_impl_._oneof_case_[8], other->_impl_._oneof_case_[8]);
  swap(_impl_._oneof_case_[9], other->_impl_._oneof_case_[9]);
  swap(_impl_._oneof_case_[10], other->_impl_._oneof_case_[10]);
  swap(_impl_._oneof_case_[11], other->_impl_._oneof_case_[11]);
}

// ===================================================================

class TransitEgressInfo::_Internal {
 public:
  using HasBits =
      decltype(std::declval<TransitEgressInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(TransitEgressInfo, _impl_._has_bits_);
};

TransitEgressInfo::TransitEgressInfo(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TransitEgressInfo)
}
inline PROTOBUF_NDEBUG_INLINE TransitEgressInfo::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::TransitEgressInfo& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        onestop_id_(arena, from.onestop_id_),
        name_(arena, from.name_) {}

TransitEgressInfo::TransitEgressInfo(
    ::google::protobuf::Arena* arena,
    const TransitEgressInfo& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TransitEgressInfo* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.ll_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::LatLng>(
                              arena, *from._impl_.ll_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:valhalla.TransitEgressInfo)
}
inline PROTOBUF_NDEBUG_INLINE TransitEgressInfo::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        onestop_id_(arena),
        name_(arena) {}

inline void TransitEgressInfo::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.ll_ = {};
}
TransitEgressInfo::~TransitEgressInfo() {
  // @@protoc_insertion_point(destructor:valhalla.TransitEgressInfo)
  SharedDtor(*this);
}
inline void TransitEgressInfo::SharedDtor(MessageLite& self) {
  TransitEgressInfo& this_ = static_cast<TransitEgressInfo&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.onestop_id_.Destroy();
  this_._impl_.name_.Destroy();
  delete this_._impl_.ll_;
  this_._impl_.~Impl_();
}

inline void* TransitEgressInfo::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TransitEgressInfo(arena);
}
constexpr auto TransitEgressInfo::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(TransitEgressInfo),
                                            alignof(TransitEgressInfo));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<27> TransitEgressInfo::_class_data_ = {
    {
        &_TransitEgressInfo_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TransitEgressInfo::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TransitEgressInfo>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TransitEgressInfo::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TransitEgressInfo>(), &TransitEgressInfo::ByteSizeLong,
            &TransitEgressInfo::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TransitEgressInfo, _impl_._cached_size_),
        true,
    },
    "valhalla.TransitEgressInfo",
};
const ::google::protobuf::internal::ClassData* TransitEgressInfo::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 49, 2> TransitEgressInfo::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TransitEgressInfo, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TransitEgressInfo>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string onestop_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(TransitEgressInfo, _impl_.onestop_id_)}},
    // string name = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(TransitEgressInfo, _impl_.name_)}},
    // .valhalla.LatLng ll = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(TransitEgressInfo, _impl_.ll_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string onestop_id = 1;
    {PROTOBUF_FIELD_OFFSET(TransitEgressInfo, _impl_.onestop_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string name = 2;
    {PROTOBUF_FIELD_OFFSET(TransitEgressInfo, _impl_.name_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .valhalla.LatLng ll = 3;
    {PROTOBUF_FIELD_OFFSET(TransitEgressInfo, _impl_.ll_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::LatLng>()},
  }}, {{
    "\32\12\4\0\0\0\0\0"
    "valhalla.TransitEgressInfo"
    "onestop_id"
    "name"
  }},
};

PROTOBUF_NOINLINE void TransitEgressInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TransitEgressInfo)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.onestop_id_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.ll_ != nullptr);
    _impl_.ll_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TransitEgressInfo::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TransitEgressInfo& this_ = static_cast<const TransitEgressInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TransitEgressInfo::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TransitEgressInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TransitEgressInfo)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string onestop_id = 1;
          if (!this_._internal_onestop_id().empty()) {
            const std::string& _s = this_._internal_onestop_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TransitEgressInfo.onestop_id");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // string name = 2;
          if (!this_._internal_name().empty()) {
            const std::string& _s = this_._internal_name();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TransitEgressInfo.name");
            target = stream->WriteStringMaybeAliased(2, _s, target);
          }

          cached_has_bits = this_._impl_._has_bits_[0];
          // .valhalla.LatLng ll = 3;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                3, *this_._impl_.ll_, this_._impl_.ll_->GetCachedSize(), target,
                stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TransitEgressInfo)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TransitEgressInfo::ByteSizeLong(const MessageLite& base) {
          const TransitEgressInfo& this_ = static_cast<const TransitEgressInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TransitEgressInfo::ByteSizeLong() const {
          const TransitEgressInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TransitEgressInfo)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // string onestop_id = 1;
            if (!this_._internal_onestop_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_onestop_id());
            }
            // string name = 2;
            if (!this_._internal_name().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_name());
            }
          }
           {
            // .valhalla.LatLng ll = 3;
            cached_has_bits = this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.ll_);
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TransitEgressInfo::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TransitEgressInfo*>(&to_msg);
  auto& from = static_cast<const TransitEgressInfo&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TransitEgressInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_onestop_id().empty()) {
    _this->_internal_set_onestop_id(from._internal_onestop_id());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(from._impl_.ll_ != nullptr);
    if (_this->_impl_.ll_ == nullptr) {
      _this->_impl_.ll_ =
          ::google::protobuf::MessageLite::CopyConstruct<::valhalla::LatLng>(arena, *from._impl_.ll_);
    } else {
      _this->_impl_.ll_->MergeFrom(*from._impl_.ll_);
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TransitEgressInfo::CopyFrom(const TransitEgressInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TransitEgressInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TransitEgressInfo::InternalSwap(TransitEgressInfo* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.onestop_id_, &other->_impl_.onestop_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  swap(_impl_.ll_, other->_impl_.ll_);
}

// ===================================================================

class TransitStationInfo::_Internal {
 public:
  using HasBits =
      decltype(std::declval<TransitStationInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(TransitStationInfo, _impl_._has_bits_);
};

TransitStationInfo::TransitStationInfo(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TransitStationInfo)
}
inline PROTOBUF_NDEBUG_INLINE TransitStationInfo::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::TransitStationInfo& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        onestop_id_(arena, from.onestop_id_),
        name_(arena, from.name_) {}

TransitStationInfo::TransitStationInfo(
    ::google::protobuf::Arena* arena,
    const TransitStationInfo& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TransitStationInfo* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.ll_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::LatLng>(
                              arena, *from._impl_.ll_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:valhalla.TransitStationInfo)
}
inline PROTOBUF_NDEBUG_INLINE TransitStationInfo::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        onestop_id_(arena),
        name_(arena) {}

inline void TransitStationInfo::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.ll_ = {};
}
TransitStationInfo::~TransitStationInfo() {
  // @@protoc_insertion_point(destructor:valhalla.TransitStationInfo)
  SharedDtor(*this);
}
inline void TransitStationInfo::SharedDtor(MessageLite& self) {
  TransitStationInfo& this_ = static_cast<TransitStationInfo&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.onestop_id_.Destroy();
  this_._impl_.name_.Destroy();
  delete this_._impl_.ll_;
  this_._impl_.~Impl_();
}

inline void* TransitStationInfo::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TransitStationInfo(arena);
}
constexpr auto TransitStationInfo::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(TransitStationInfo),
                                            alignof(TransitStationInfo));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<28> TransitStationInfo::_class_data_ = {
    {
        &_TransitStationInfo_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TransitStationInfo::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TransitStationInfo>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TransitStationInfo::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TransitStationInfo>(), &TransitStationInfo::ByteSizeLong,
            &TransitStationInfo::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TransitStationInfo, _impl_._cached_size_),
        true,
    },
    "valhalla.TransitStationInfo",
};
const ::google::protobuf::internal::ClassData* TransitStationInfo::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 50, 2> TransitStationInfo::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TransitStationInfo, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TransitStationInfo>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string onestop_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(TransitStationInfo, _impl_.onestop_id_)}},
    // string name = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(TransitStationInfo, _impl_.name_)}},
    // .valhalla.LatLng ll = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(TransitStationInfo, _impl_.ll_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string onestop_id = 1;
    {PROTOBUF_FIELD_OFFSET(TransitStationInfo, _impl_.onestop_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string name = 2;
    {PROTOBUF_FIELD_OFFSET(TransitStationInfo, _impl_.name_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .valhalla.LatLng ll = 3;
    {PROTOBUF_FIELD_OFFSET(TransitStationInfo, _impl_.ll_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::LatLng>()},
  }}, {{
    "\33\12\4\0\0\0\0\0"
    "valhalla.TransitStationInfo"
    "onestop_id"
    "name"
  }},
};

PROTOBUF_NOINLINE void TransitStationInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TransitStationInfo)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.onestop_id_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.ll_ != nullptr);
    _impl_.ll_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TransitStationInfo::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TransitStationInfo& this_ = static_cast<const TransitStationInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TransitStationInfo::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TransitStationInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TransitStationInfo)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string onestop_id = 1;
          if (!this_._internal_onestop_id().empty()) {
            const std::string& _s = this_._internal_onestop_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TransitStationInfo.onestop_id");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // string name = 2;
          if (!this_._internal_name().empty()) {
            const std::string& _s = this_._internal_name();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TransitStationInfo.name");
            target = stream->WriteStringMaybeAliased(2, _s, target);
          }

          cached_has_bits = this_._impl_._has_bits_[0];
          // .valhalla.LatLng ll = 3;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                3, *this_._impl_.ll_, this_._impl_.ll_->GetCachedSize(), target,
                stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TransitStationInfo)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TransitStationInfo::ByteSizeLong(const MessageLite& base) {
          const TransitStationInfo& this_ = static_cast<const TransitStationInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TransitStationInfo::ByteSizeLong() const {
          const TransitStationInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TransitStationInfo)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // string onestop_id = 1;
            if (!this_._internal_onestop_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_onestop_id());
            }
            // string name = 2;
            if (!this_._internal_name().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_name());
            }
          }
           {
            // .valhalla.LatLng ll = 3;
            cached_has_bits = this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.ll_);
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TransitStationInfo::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TransitStationInfo*>(&to_msg);
  auto& from = static_cast<const TransitStationInfo&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TransitStationInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_onestop_id().empty()) {
    _this->_internal_set_onestop_id(from._internal_onestop_id());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(from._impl_.ll_ != nullptr);
    if (_this->_impl_.ll_ == nullptr) {
      _this->_impl_.ll_ =
          ::google::protobuf::MessageLite::CopyConstruct<::valhalla::LatLng>(arena, *from._impl_.ll_);
    } else {
      _this->_impl_.ll_->MergeFrom(*from._impl_.ll_);
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TransitStationInfo::CopyFrom(const TransitStationInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TransitStationInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TransitStationInfo::InternalSwap(TransitStationInfo* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.onestop_id_, &other->_impl_.onestop_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  swap(_impl_.ll_, other->_impl_.ll_);
}

// ===================================================================

class BikeShareStationInfo::_Internal {
 public:
};

BikeShareStationInfo::BikeShareStationInfo(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.BikeShareStationInfo)
}
inline PROTOBUF_NDEBUG_INLINE BikeShareStationInfo::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::BikeShareStationInfo& from_msg)
      : name_(arena, from.name_),
        ref_(arena, from.ref_),
        network_(arena, from.network_),
        operator__(arena, from.operator__),
        _cached_size_{0} {}

BikeShareStationInfo::BikeShareStationInfo(
    ::google::protobuf::Arena* arena,
    const BikeShareStationInfo& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  BikeShareStationInfo* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, capacity_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, capacity_),
           offsetof(Impl_, return_cost_) -
               offsetof(Impl_, capacity_) +
               sizeof(Impl_::return_cost_));

  // @@protoc_insertion_point(copy_constructor:valhalla.BikeShareStationInfo)
}
inline PROTOBUF_NDEBUG_INLINE BikeShareStationInfo::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : name_(arena),
        ref_(arena),
        network_(arena),
        operator__(arena),
        _cached_size_{0} {}

inline void BikeShareStationInfo::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, capacity_),
           0,
           offsetof(Impl_, return_cost_) -
               offsetof(Impl_, capacity_) +
               sizeof(Impl_::return_cost_));
}
BikeShareStationInfo::~BikeShareStationInfo() {
  // @@protoc_insertion_point(destructor:valhalla.BikeShareStationInfo)
  SharedDtor(*this);
}
inline void BikeShareStationInfo::SharedDtor(MessageLite& self) {
  BikeShareStationInfo& this_ = static_cast<BikeShareStationInfo&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.name_.Destroy();
  this_._impl_.ref_.Destroy();
  this_._impl_.network_.Destroy();
  this_._impl_.operator__.Destroy();
  this_._impl_.~Impl_();
}

inline void* BikeShareStationInfo::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) BikeShareStationInfo(arena);
}
constexpr auto BikeShareStationInfo::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(BikeShareStationInfo),
                                            alignof(BikeShareStationInfo));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<30> BikeShareStationInfo::_class_data_ = {
    {
        &_BikeShareStationInfo_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &BikeShareStationInfo::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<BikeShareStationInfo>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &BikeShareStationInfo::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<BikeShareStationInfo>(), &BikeShareStationInfo::ByteSizeLong,
            &BikeShareStationInfo::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(BikeShareStationInfo, _impl_._cached_size_),
        true,
    },
    "valhalla.BikeShareStationInfo",
};
const ::google::protobuf::internal::ClassData* BikeShareStationInfo::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 0, 60, 2> BikeShareStationInfo::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::BikeShareStationInfo>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string name = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(BikeShareStationInfo, _impl_.name_)}},
    // string ref = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(BikeShareStationInfo, _impl_.ref_)}},
    // uint32 capacity = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(BikeShareStationInfo, _impl_.capacity_)}},
    // string network = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(BikeShareStationInfo, _impl_.network_)}},
    // string operator = 5;
    {::_pbi::TcParser::FastUS1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(BikeShareStationInfo, _impl_.operator__)}},
    // float rent_cost = 6;
    {::_pbi::TcParser::FastF32S1,
     {53, 63, 0, PROTOBUF_FIELD_OFFSET(BikeShareStationInfo, _impl_.rent_cost_)}},
    // float return_cost = 7;
    {::_pbi::TcParser::FastF32S1,
     {61, 63, 0, PROTOBUF_FIELD_OFFSET(BikeShareStationInfo, _impl_.return_cost_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string name = 1;
    {PROTOBUF_FIELD_OFFSET(BikeShareStationInfo, _impl_.name_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string ref = 2;
    {PROTOBUF_FIELD_OFFSET(BikeShareStationInfo, _impl_.ref_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // uint32 capacity = 3;
    {PROTOBUF_FIELD_OFFSET(BikeShareStationInfo, _impl_.capacity_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // string network = 4;
    {PROTOBUF_FIELD_OFFSET(BikeShareStationInfo, _impl_.network_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string operator = 5;
    {PROTOBUF_FIELD_OFFSET(BikeShareStationInfo, _impl_.operator__), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // float rent_cost = 6;
    {PROTOBUF_FIELD_OFFSET(BikeShareStationInfo, _impl_.rent_cost_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float return_cost = 7;
    {PROTOBUF_FIELD_OFFSET(BikeShareStationInfo, _impl_.return_cost_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
    "\35\4\3\0\7\10\0\0"
    "valhalla.BikeShareStationInfo"
    "name"
    "ref"
    "network"
    "operator"
  }},
};

PROTOBUF_NOINLINE void BikeShareStationInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.BikeShareStationInfo)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.ref_.ClearToEmpty();
  _impl_.network_.ClearToEmpty();
  _impl_.operator__.ClearToEmpty();
  ::memset(&_impl_.capacity_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.return_cost_) -
      reinterpret_cast<char*>(&_impl_.capacity_)) + sizeof(_impl_.return_cost_));
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* BikeShareStationInfo::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const BikeShareStationInfo& this_ = static_cast<const BikeShareStationInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* BikeShareStationInfo::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const BikeShareStationInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.BikeShareStationInfo)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string name = 1;
          if (!this_._internal_name().empty()) {
            const std::string& _s = this_._internal_name();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.BikeShareStationInfo.name");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // string ref = 2;
          if (!this_._internal_ref().empty()) {
            const std::string& _s = this_._internal_ref();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.BikeShareStationInfo.ref");
            target = stream->WriteStringMaybeAliased(2, _s, target);
          }

          // uint32 capacity = 3;
          if (this_._internal_capacity() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                3, this_._internal_capacity(), target);
          }

          // string network = 4;
          if (!this_._internal_network().empty()) {
            const std::string& _s = this_._internal_network();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.BikeShareStationInfo.network");
            target = stream->WriteStringMaybeAliased(4, _s, target);
          }

          // string operator = 5;
          if (!this_._internal_operator_().empty()) {
            const std::string& _s = this_._internal_operator_();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.BikeShareStationInfo.operator");
            target = stream->WriteStringMaybeAliased(5, _s, target);
          }

          // float rent_cost = 6;
          if (::absl::bit_cast<::uint32_t>(this_._internal_rent_cost()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                6, this_._internal_rent_cost(), target);
          }

          // float return_cost = 7;
          if (::absl::bit_cast<::uint32_t>(this_._internal_return_cost()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                7, this_._internal_return_cost(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.BikeShareStationInfo)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t BikeShareStationInfo::ByteSizeLong(const MessageLite& base) {
          const BikeShareStationInfo& this_ = static_cast<const BikeShareStationInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t BikeShareStationInfo::ByteSizeLong() const {
          const BikeShareStationInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.BikeShareStationInfo)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // string name = 1;
            if (!this_._internal_name().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_name());
            }
            // string ref = 2;
            if (!this_._internal_ref().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_ref());
            }
            // string network = 4;
            if (!this_._internal_network().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_network());
            }
            // string operator = 5;
            if (!this_._internal_operator_().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_operator_());
            }
            // uint32 capacity = 3;
            if (this_._internal_capacity() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_capacity());
            }
            // float rent_cost = 6;
            if (::absl::bit_cast<::uint32_t>(this_._internal_rent_cost()) != 0) {
              total_size += 5;
            }
            // float return_cost = 7;
            if (::absl::bit_cast<::uint32_t>(this_._internal_return_cost()) != 0) {
              total_size += 5;
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void BikeShareStationInfo::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<BikeShareStationInfo*>(&to_msg);
  auto& from = static_cast<const BikeShareStationInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.BikeShareStationInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_ref().empty()) {
    _this->_internal_set_ref(from._internal_ref());
  }
  if (!from._internal_network().empty()) {
    _this->_internal_set_network(from._internal_network());
  }
  if (!from._internal_operator_().empty()) {
    _this->_internal_set_operator_(from._internal_operator_());
  }
  if (from._internal_capacity() != 0) {
    _this->_impl_.capacity_ = from._impl_.capacity_;
  }
  if (::absl::bit_cast<::uint32_t>(from._internal_rent_cost()) != 0) {
    _this->_impl_.rent_cost_ = from._impl_.rent_cost_;
  }
  if (::absl::bit_cast<::uint32_t>(from._internal_return_cost()) != 0) {
    _this->_impl_.return_cost_ = from._impl_.return_cost_;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BikeShareStationInfo::CopyFrom(const BikeShareStationInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.BikeShareStationInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void BikeShareStationInfo::InternalSwap(BikeShareStationInfo* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ref_, &other->_impl_.ref_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.network_, &other->_impl_.network_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.operator__, &other->_impl_.operator__, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BikeShareStationInfo, _impl_.return_cost_)
      + sizeof(BikeShareStationInfo::_impl_.return_cost_)
      - PROTOBUF_FIELD_OFFSET(BikeShareStationInfo, _impl_.capacity_)>(
          reinterpret_cast<char*>(&_impl_.capacity_),
          reinterpret_cast<char*>(&other->_impl_.capacity_));
}

// ===================================================================

class TransitPlatformInfo::_Internal {
 public:
  using HasBits =
      decltype(std::declval<TransitPlatformInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_._has_bits_);
};

TransitPlatformInfo::TransitPlatformInfo(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TransitPlatformInfo)
}
inline PROTOBUF_NDEBUG_INLINE TransitPlatformInfo::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::TransitPlatformInfo& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        onestop_id_(arena, from.onestop_id_),
        name_(arena, from.name_),
        arrival_date_time_(arena, from.arrival_date_time_),
        departure_date_time_(arena, from.departure_date_time_),
        station_onestop_id_(arena, from.station_onestop_id_),
        station_name_(arena, from.station_name_) {}

TransitPlatformInfo::TransitPlatformInfo(
    ::google::protobuf::Arena* arena,
    const TransitPlatformInfo& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TransitPlatformInfo* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.ll_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::LatLng>(
                              arena, *from._impl_.ll_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, type_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, type_),
           offsetof(Impl_, assumed_schedule_) -
               offsetof(Impl_, type_) +
               sizeof(Impl_::assumed_schedule_));

  // @@protoc_insertion_point(copy_constructor:valhalla.TransitPlatformInfo)
}
inline PROTOBUF_NDEBUG_INLINE TransitPlatformInfo::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        onestop_id_(arena),
        name_(arena),
        arrival_date_time_(arena),
        departure_date_time_(arena),
        station_onestop_id_(arena),
        station_name_(arena) {}

inline void TransitPlatformInfo::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, ll_),
           0,
           offsetof(Impl_, assumed_schedule_) -
               offsetof(Impl_, ll_) +
               sizeof(Impl_::assumed_schedule_));
}
TransitPlatformInfo::~TransitPlatformInfo() {
  // @@protoc_insertion_point(destructor:valhalla.TransitPlatformInfo)
  SharedDtor(*this);
}
inline void TransitPlatformInfo::SharedDtor(MessageLite& self) {
  TransitPlatformInfo& this_ = static_cast<TransitPlatformInfo&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.onestop_id_.Destroy();
  this_._impl_.name_.Destroy();
  this_._impl_.arrival_date_time_.Destroy();
  this_._impl_.departure_date_time_.Destroy();
  this_._impl_.station_onestop_id_.Destroy();
  this_._impl_.station_name_.Destroy();
  delete this_._impl_.ll_;
  this_._impl_.~Impl_();
}

inline void* TransitPlatformInfo::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TransitPlatformInfo(arena);
}
constexpr auto TransitPlatformInfo::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(TransitPlatformInfo),
                                            alignof(TransitPlatformInfo));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<29> TransitPlatformInfo::_class_data_ = {
    {
        &_TransitPlatformInfo_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TransitPlatformInfo::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TransitPlatformInfo>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TransitPlatformInfo::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TransitPlatformInfo>(), &TransitPlatformInfo::ByteSizeLong,
            &TransitPlatformInfo::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_._cached_size_),
        true,
    },
    "valhalla.TransitPlatformInfo",
};
const ::google::protobuf::internal::ClassData* TransitPlatformInfo::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 9, 1, 125, 2> TransitPlatformInfo::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_._has_bits_),
    0, // no _extensions_
    9, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966784,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TransitPlatformInfo>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .valhalla.TransitPlatformInfo.Type type = 1;
    {::_pbi::TcParser::FastV32S1,
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_.type_)}},
    // string onestop_id = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_.onestop_id_)}},
    // string name = 3;
    {::_pbi::TcParser::FastUS1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_.name_)}},
    // string arrival_date_time = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_.arrival_date_time_)}},
    // string departure_date_time = 5;
    {::_pbi::TcParser::FastUS1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_.departure_date_time_)}},
    // bool assumed_schedule = 6;
    {::_pbi::TcParser::FastV8S1,
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_.assumed_schedule_)}},
    // .valhalla.LatLng ll = 7;
    {::_pbi::TcParser::FastMtS1,
     {58, 0, 0, PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_.ll_)}},
    // string station_onestop_id = 8;
    {::_pbi::TcParser::FastUS1,
     {66, 63, 0, PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_.station_onestop_id_)}},
    // string station_name = 9;
    {::_pbi::TcParser::FastUS1,
     {74, 63, 0, PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_.station_name_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .valhalla.TransitPlatformInfo.Type type = 1;
    {PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_.type_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // string onestop_id = 2;
    {PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_.onestop_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string name = 3;
    {PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_.name_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string arrival_date_time = 4;
    {PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_.arrival_date_time_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string departure_date_time = 5;
    {PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_.departure_date_time_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bool assumed_schedule = 6;
    {PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_.assumed_schedule_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // .valhalla.LatLng ll = 7;
    {PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_.ll_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // string station_onestop_id = 8;
    {PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_.station_onestop_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string station_name = 9;
    {PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_.station_name_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::LatLng>()},
  }}, {{
    "\34\0\12\4\21\23\0\0\22\14\0\0\0\0\0\0"
    "valhalla.TransitPlatformInfo"
    "onestop_id"
    "name"
    "arrival_date_time"
    "departure_date_time"
    "station_onestop_id"
    "station_name"
  }},
};

PROTOBUF_NOINLINE void TransitPlatformInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TransitPlatformInfo)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.onestop_id_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  _impl_.arrival_date_time_.ClearToEmpty();
  _impl_.departure_date_time_.ClearToEmpty();
  _impl_.station_onestop_id_.ClearToEmpty();
  _impl_.station_name_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.ll_ != nullptr);
    _impl_.ll_->Clear();
  }
  ::memset(&_impl_.type_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.assumed_schedule_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.assumed_schedule_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TransitPlatformInfo::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TransitPlatformInfo& this_ = static_cast<const TransitPlatformInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TransitPlatformInfo::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TransitPlatformInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TransitPlatformInfo)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // .valhalla.TransitPlatformInfo.Type type = 1;
          if (this_._internal_type() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                1, this_._internal_type(), target);
          }

          // string onestop_id = 2;
          if (!this_._internal_onestop_id().empty()) {
            const std::string& _s = this_._internal_onestop_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TransitPlatformInfo.onestop_id");
            target = stream->WriteStringMaybeAliased(2, _s, target);
          }

          // string name = 3;
          if (!this_._internal_name().empty()) {
            const std::string& _s = this_._internal_name();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TransitPlatformInfo.name");
            target = stream->WriteStringMaybeAliased(3, _s, target);
          }

          // string arrival_date_time = 4;
          if (!this_._internal_arrival_date_time().empty()) {
            const std::string& _s = this_._internal_arrival_date_time();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TransitPlatformInfo.arrival_date_time");
            target = stream->WriteStringMaybeAliased(4, _s, target);
          }

          // string departure_date_time = 5;
          if (!this_._internal_departure_date_time().empty()) {
            const std::string& _s = this_._internal_departure_date_time();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TransitPlatformInfo.departure_date_time");
            target = stream->WriteStringMaybeAliased(5, _s, target);
          }

          // bool assumed_schedule = 6;
          if (this_._internal_assumed_schedule() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                6, this_._internal_assumed_schedule(), target);
          }

          cached_has_bits = this_._impl_._has_bits_[0];
          // .valhalla.LatLng ll = 7;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                7, *this_._impl_.ll_, this_._impl_.ll_->GetCachedSize(), target,
                stream);
          }

          // string station_onestop_id = 8;
          if (!this_._internal_station_onestop_id().empty()) {
            const std::string& _s = this_._internal_station_onestop_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TransitPlatformInfo.station_onestop_id");
            target = stream->WriteStringMaybeAliased(8, _s, target);
          }

          // string station_name = 9;
          if (!this_._internal_station_name().empty()) {
            const std::string& _s = this_._internal_station_name();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TransitPlatformInfo.station_name");
            target = stream->WriteStringMaybeAliased(9, _s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TransitPlatformInfo)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TransitPlatformInfo::ByteSizeLong(const MessageLite& base) {
          const TransitPlatformInfo& this_ = static_cast<const TransitPlatformInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TransitPlatformInfo::ByteSizeLong() const {
          const TransitPlatformInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TransitPlatformInfo)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // string onestop_id = 2;
            if (!this_._internal_onestop_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_onestop_id());
            }
            // string name = 3;
            if (!this_._internal_name().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_name());
            }
            // string arrival_date_time = 4;
            if (!this_._internal_arrival_date_time().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_arrival_date_time());
            }
            // string departure_date_time = 5;
            if (!this_._internal_departure_date_time().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_departure_date_time());
            }
            // string station_onestop_id = 8;
            if (!this_._internal_station_onestop_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_station_onestop_id());
            }
            // string station_name = 9;
            if (!this_._internal_station_name().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_station_name());
            }
          }
           {
            // .valhalla.LatLng ll = 7;
            cached_has_bits = this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.ll_);
            }
          }
           {
            // .valhalla.TransitPlatformInfo.Type type = 1;
            if (this_._internal_type() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_type());
            }
            // bool assumed_schedule = 6;
            if (this_._internal_assumed_schedule() != 0) {
              total_size += 2;
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TransitPlatformInfo::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TransitPlatformInfo*>(&to_msg);
  auto& from = static_cast<const TransitPlatformInfo&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TransitPlatformInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_onestop_id().empty()) {
    _this->_internal_set_onestop_id(from._internal_onestop_id());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_arrival_date_time().empty()) {
    _this->_internal_set_arrival_date_time(from._internal_arrival_date_time());
  }
  if (!from._internal_departure_date_time().empty()) {
    _this->_internal_set_departure_date_time(from._internal_departure_date_time());
  }
  if (!from._internal_station_onestop_id().empty()) {
    _this->_internal_set_station_onestop_id(from._internal_station_onestop_id());
  }
  if (!from._internal_station_name().empty()) {
    _this->_internal_set_station_name(from._internal_station_name());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(from._impl_.ll_ != nullptr);
    if (_this->_impl_.ll_ == nullptr) {
      _this->_impl_.ll_ =
          ::google::protobuf::MessageLite::CopyConstruct<::valhalla::LatLng>(arena, *from._impl_.ll_);
    } else {
      _this->_impl_.ll_->MergeFrom(*from._impl_.ll_);
    }
  }
  if (from._internal_type() != 0) {
    _this->_impl_.type_ = from._impl_.type_;
  }
  if (from._internal_assumed_schedule() != 0) {
    _this->_impl_.assumed_schedule_ = from._impl_.assumed_schedule_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TransitPlatformInfo::CopyFrom(const TransitPlatformInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TransitPlatformInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TransitPlatformInfo::InternalSwap(TransitPlatformInfo* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.onestop_id_, &other->_impl_.onestop_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.arrival_date_time_, &other->_impl_.arrival_date_time_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.departure_date_time_, &other->_impl_.departure_date_time_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.station_onestop_id_, &other->_impl_.station_onestop_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.station_name_, &other->_impl_.station_name_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_.assumed_schedule_)
      + sizeof(TransitPlatformInfo::_impl_.assumed_schedule_)
      - PROTOBUF_FIELD_OFFSET(TransitPlatformInfo, _impl_.ll_)>(
          reinterpret_cast<char*>(&_impl_.ll_),
          reinterpret_cast<char*>(&other->_impl_.ll_));
}

// ===================================================================

class TransitRouteInfo::_Internal {
 public:
};

TransitRouteInfo::TransitRouteInfo(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TransitRouteInfo)
}
inline PROTOBUF_NDEBUG_INLINE TransitRouteInfo::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::TransitRouteInfo& from_msg)
      : transit_stops_{visibility, arena, from.transit_stops_},
        onestop_id_(arena, from.onestop_id_),
        short_name_(arena, from.short_name_),
        long_name_(arena, from.long_name_),
        headsign_(arena, from.headsign_),
        description_(arena, from.description_),
        operator_onestop_id_(arena, from.operator_onestop_id_),
        operator_name_(arena, from.operator_name_),
        operator_url_(arena, from.operator_url_),
        _cached_size_{0} {}

TransitRouteInfo::TransitRouteInfo(
    ::google::protobuf::Arena* arena,
    const TransitRouteInfo& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TransitRouteInfo* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, block_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, block_id_),
           offsetof(Impl_, text_color_) -
               offsetof(Impl_, block_id_) +
               sizeof(Impl_::text_color_));

  // @@protoc_insertion_point(copy_constructor:valhalla.TransitRouteInfo)
}
inline PROTOBUF_NDEBUG_INLINE TransitRouteInfo::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : transit_stops_{visibility, arena},
        onestop_id_(arena),
        short_name_(arena),
        long_name_(arena),
        headsign_(arena),
        description_(arena),
        operator_onestop_id_(arena),
        operator_name_(arena),
        operator_url_(arena),
        _cached_size_{0} {}

inline void TransitRouteInfo::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, block_id_),
           0,
           offsetof(Impl_, text_color_) -
               offsetof(Impl_, block_id_) +
               sizeof(Impl_::text_color_));
}
TransitRouteInfo::~TransitRouteInfo() {
  // @@protoc_insertion_point(destructor:valhalla.TransitRouteInfo)
  SharedDtor(*this);
}
inline void TransitRouteInfo::SharedDtor(MessageLite& self) {
  TransitRouteInfo& this_ = static_cast<TransitRouteInfo&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.onestop_id_.Destroy();
  this_._impl_.short_name_.Destroy();
  this_._impl_.long_name_.Destroy();
  this_._impl_.headsign_.Destroy();
  this_._impl_.description_.Destroy();
  this_._impl_.operator_onestop_id_.Destroy();
  this_._impl_.operator_name_.Destroy();
  this_._impl_.operator_url_.Destroy();
  this_._impl_.~Impl_();
}

inline void* TransitRouteInfo::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TransitRouteInfo(arena);
}
constexpr auto TransitRouteInfo::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.transit_stops_) +
          decltype(TransitRouteInfo::_impl_.transit_stops_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(TransitRouteInfo), alignof(TransitRouteInfo), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&TransitRouteInfo::PlacementNew_,
                                 sizeof(TransitRouteInfo),
                                 alignof(TransitRouteInfo));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<26> TransitRouteInfo::_class_data_ = {
    {
        &_TransitRouteInfo_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TransitRouteInfo::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TransitRouteInfo>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TransitRouteInfo::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TransitRouteInfo>(), &TransitRouteInfo::ByteSizeLong,
            &TransitRouteInfo::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_._cached_size_),
        true,
    },
    "valhalla.TransitRouteInfo",
};
const ::google::protobuf::internal::ClassData* TransitRouteInfo::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 13, 1, 134, 2> TransitRouteInfo::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    13, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294959104,  // skipmap
    offsetof(decltype(_table_), field_entries),
    13,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TransitRouteInfo>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string onestop_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.onestop_id_)}},
    // uint32 block_id = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.block_id_)}},
    // uint32 trip_id = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.trip_id_)}},
    // string short_name = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.short_name_)}},
    // string long_name = 5;
    {::_pbi::TcParser::FastUS1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.long_name_)}},
    // string headsign = 6;
    {::_pbi::TcParser::FastUS1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.headsign_)}},
    // uint32 color = 7;
    {::_pbi::TcParser::FastV32S1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.color_)}},
    // uint32 text_color = 8;
    {::_pbi::TcParser::FastV32S1,
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.text_color_)}},
    // string description = 9;
    {::_pbi::TcParser::FastUS1,
     {74, 63, 0, PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.description_)}},
    // string operator_onestop_id = 10;
    {::_pbi::TcParser::FastUS1,
     {82, 63, 0, PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.operator_onestop_id_)}},
    // string operator_name = 11;
    {::_pbi::TcParser::FastUS1,
     {90, 63, 0, PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.operator_name_)}},
    // string operator_url = 12;
    {::_pbi::TcParser::FastUS1,
     {98, 63, 0, PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.operator_url_)}},
    // repeated .valhalla.TransitPlatformInfo transit_stops = 13;
    {::_pbi::TcParser::FastMtR1,
     {106, 63, 0, PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.transit_stops_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string onestop_id = 1;
    {PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.onestop_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // uint32 block_id = 2;
    {PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.block_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 trip_id = 3;
    {PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.trip_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // string short_name = 4;
    {PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.short_name_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string long_name = 5;
    {PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.long_name_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string headsign = 6;
    {PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.headsign_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // uint32 color = 7;
    {PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.color_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 text_color = 8;
    {PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.text_color_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // string description = 9;
    {PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.description_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string operator_onestop_id = 10;
    {PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.operator_onestop_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string operator_name = 11;
    {PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.operator_name_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string operator_url = 12;
    {PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.operator_url_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated .valhalla.TransitPlatformInfo transit_stops = 13;
    {PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.transit_stops_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::TransitPlatformInfo>()},
  }}, {{
    "\31\12\0\0\12\11\10\0\0\13\23\15\14\0\0\0"
    "valhalla.TransitRouteInfo"
    "onestop_id"
    "short_name"
    "long_name"
    "headsign"
    "description"
    "operator_onestop_id"
    "operator_name"
    "operator_url"
  }},
};

PROTOBUF_NOINLINE void TransitRouteInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TransitRouteInfo)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.transit_stops_.Clear();
  _impl_.onestop_id_.ClearToEmpty();
  _impl_.short_name_.ClearToEmpty();
  _impl_.long_name_.ClearToEmpty();
  _impl_.headsign_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _impl_.operator_onestop_id_.ClearToEmpty();
  _impl_.operator_name_.ClearToEmpty();
  _impl_.operator_url_.ClearToEmpty();
  ::memset(&_impl_.block_id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.text_color_) -
      reinterpret_cast<char*>(&_impl_.block_id_)) + sizeof(_impl_.text_color_));
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TransitRouteInfo::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TransitRouteInfo& this_ = static_cast<const TransitRouteInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TransitRouteInfo::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TransitRouteInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TransitRouteInfo)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string onestop_id = 1;
          if (!this_._internal_onestop_id().empty()) {
            const std::string& _s = this_._internal_onestop_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TransitRouteInfo.onestop_id");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // uint32 block_id = 2;
          if (this_._internal_block_id() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                2, this_._internal_block_id(), target);
          }

          // uint32 trip_id = 3;
          if (this_._internal_trip_id() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                3, this_._internal_trip_id(), target);
          }

          // string short_name = 4;
          if (!this_._internal_short_name().empty()) {
            const std::string& _s = this_._internal_short_name();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TransitRouteInfo.short_name");
            target = stream->WriteStringMaybeAliased(4, _s, target);
          }

          // string long_name = 5;
          if (!this_._internal_long_name().empty()) {
            const std::string& _s = this_._internal_long_name();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TransitRouteInfo.long_name");
            target = stream->WriteStringMaybeAliased(5, _s, target);
          }

          // string headsign = 6;
          if (!this_._internal_headsign().empty()) {
            const std::string& _s = this_._internal_headsign();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TransitRouteInfo.headsign");
            target = stream->WriteStringMaybeAliased(6, _s, target);
          }

          // uint32 color = 7;
          if (this_._internal_color() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                7, this_._internal_color(), target);
          }

          // uint32 text_color = 8;
          if (this_._internal_text_color() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                8, this_._internal_text_color(), target);
          }

          // string description = 9;
          if (!this_._internal_description().empty()) {
            const std::string& _s = this_._internal_description();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TransitRouteInfo.description");
            target = stream->WriteStringMaybeAliased(9, _s, target);
          }

          // string operator_onestop_id = 10;
          if (!this_._internal_operator_onestop_id().empty()) {
            const std::string& _s = this_._internal_operator_onestop_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TransitRouteInfo.operator_onestop_id");
            target = stream->WriteStringMaybeAliased(10, _s, target);
          }

          // string operator_name = 11;
          if (!this_._internal_operator_name().empty()) {
            const std::string& _s = this_._internal_operator_name();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TransitRouteInfo.operator_name");
            target = stream->WriteStringMaybeAliased(11, _s, target);
          }

          // string operator_url = 12;
          if (!this_._internal_operator_url().empty()) {
            const std::string& _s = this_._internal_operator_url();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.TransitRouteInfo.operator_url");
            target = stream->WriteStringMaybeAliased(12, _s, target);
          }

          // repeated .valhalla.TransitPlatformInfo transit_stops = 13;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_transit_stops_size());
               i < n; i++) {
            const auto& repfield = this_._internal_transit_stops().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    13, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TransitRouteInfo)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TransitRouteInfo::ByteSizeLong(const MessageLite& base) {
          const TransitRouteInfo& this_ = static_cast<const TransitRouteInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TransitRouteInfo::ByteSizeLong() const {
          const TransitRouteInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TransitRouteInfo)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .valhalla.TransitPlatformInfo transit_stops = 13;
            {
              total_size += 1UL * this_._internal_transit_stops_size();
              for (const auto& msg : this_._internal_transit_stops()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
           {
            // string onestop_id = 1;
            if (!this_._internal_onestop_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_onestop_id());
            }
            // string short_name = 4;
            if (!this_._internal_short_name().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_short_name());
            }
            // string long_name = 5;
            if (!this_._internal_long_name().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_long_name());
            }
            // string headsign = 6;
            if (!this_._internal_headsign().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_headsign());
            }
            // string description = 9;
            if (!this_._internal_description().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_description());
            }
            // string operator_onestop_id = 10;
            if (!this_._internal_operator_onestop_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_operator_onestop_id());
            }
            // string operator_name = 11;
            if (!this_._internal_operator_name().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_operator_name());
            }
            // string operator_url = 12;
            if (!this_._internal_operator_url().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_operator_url());
            }
            // uint32 block_id = 2;
            if (this_._internal_block_id() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_block_id());
            }
            // uint32 trip_id = 3;
            if (this_._internal_trip_id() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_trip_id());
            }
            // uint32 color = 7;
            if (this_._internal_color() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_color());
            }
            // uint32 text_color = 8;
            if (this_._internal_text_color() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_text_color());
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TransitRouteInfo::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TransitRouteInfo*>(&to_msg);
  auto& from = static_cast<const TransitRouteInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TransitRouteInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_transit_stops()->MergeFrom(
      from._internal_transit_stops());
  if (!from._internal_onestop_id().empty()) {
    _this->_internal_set_onestop_id(from._internal_onestop_id());
  }
  if (!from._internal_short_name().empty()) {
    _this->_internal_set_short_name(from._internal_short_name());
  }
  if (!from._internal_long_name().empty()) {
    _this->_internal_set_long_name(from._internal_long_name());
  }
  if (!from._internal_headsign().empty()) {
    _this->_internal_set_headsign(from._internal_headsign());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_operator_onestop_id().empty()) {
    _this->_internal_set_operator_onestop_id(from._internal_operator_onestop_id());
  }
  if (!from._internal_operator_name().empty()) {
    _this->_internal_set_operator_name(from._internal_operator_name());
  }
  if (!from._internal_operator_url().empty()) {
    _this->_internal_set_operator_url(from._internal_operator_url());
  }
  if (from._internal_block_id() != 0) {
    _this->_impl_.block_id_ = from._impl_.block_id_;
  }
  if (from._internal_trip_id() != 0) {
    _this->_impl_.trip_id_ = from._impl_.trip_id_;
  }
  if (from._internal_color() != 0) {
    _this->_impl_.color_ = from._impl_.color_;
  }
  if (from._internal_text_color() != 0) {
    _this->_impl_.text_color_ = from._impl_.text_color_;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TransitRouteInfo::CopyFrom(const TransitRouteInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TransitRouteInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TransitRouteInfo::InternalSwap(TransitRouteInfo* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.transit_stops_.InternalSwap(&other->_impl_.transit_stops_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.onestop_id_, &other->_impl_.onestop_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.short_name_, &other->_impl_.short_name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.long_name_, &other->_impl_.long_name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.headsign_, &other->_impl_.headsign_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.description_, &other->_impl_.description_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.operator_onestop_id_, &other->_impl_.operator_onestop_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.operator_name_, &other->_impl_.operator_name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.operator_url_, &other->_impl_.operator_url_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.text_color_)
      + sizeof(TransitRouteInfo::_impl_.text_color_)
      - PROTOBUF_FIELD_OFFSET(TransitRouteInfo, _impl_.block_id_)>(
          reinterpret_cast<char*>(&_impl_.block_id_),
          reinterpret_cast<char*>(&other->_impl_.block_id_));
}

// ===================================================================

class Pronunciation::_Internal {
 public:
};

Pronunciation::Pronunciation(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.Pronunciation)
}
inline PROTOBUF_NDEBUG_INLINE Pronunciation::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::Pronunciation& from_msg)
      : value_(arena, from.value_),
        _cached_size_{0} {}

Pronunciation::Pronunciation(
    ::google::protobuf::Arena* arena,
    const Pronunciation& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Pronunciation* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.alphabet_ = from._impl_.alphabet_;

  // @@protoc_insertion_point(copy_constructor:valhalla.Pronunciation)
}
inline PROTOBUF_NDEBUG_INLINE Pronunciation::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : value_(arena),
        _cached_size_{0} {}

inline void Pronunciation::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.alphabet_ = {};
}
Pronunciation::~Pronunciation() {
  // @@protoc_insertion_point(destructor:valhalla.Pronunciation)
  SharedDtor(*this);
}
inline void Pronunciation::SharedDtor(MessageLite& self) {
  Pronunciation& this_ = static_cast<Pronunciation&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.value_.Destroy();
  this_._impl_.~Impl_();
}

inline void* Pronunciation::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) Pronunciation(arena);
}
constexpr auto Pronunciation::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(Pronunciation),
                                            alignof(Pronunciation));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<23> Pronunciation::_class_data_ = {
    {
        &_Pronunciation_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &Pronunciation::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<Pronunciation>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &Pronunciation::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<Pronunciation>(), &Pronunciation::ByteSizeLong,
            &Pronunciation::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(Pronunciation, _impl_._cached_size_),
        true,
    },
    "valhalla.Pronunciation",
};
const ::google::protobuf::internal::ClassData* Pronunciation::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 36, 2> Pronunciation::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::Pronunciation>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string value = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(Pronunciation, _impl_.value_)}},
    // .valhalla.Pronunciation.Alphabet alphabet = 1;
    {::_pbi::TcParser::FastV32S1,
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(Pronunciation, _impl_.alphabet_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .valhalla.Pronunciation.Alphabet alphabet = 1;
    {PROTOBUF_FIELD_OFFSET(Pronunciation, _impl_.alphabet_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // string value = 2;
    {PROTOBUF_FIELD_OFFSET(Pronunciation, _impl_.value_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\26\0\5\0\0\0\0\0"
    "valhalla.Pronunciation"
    "value"
  }},
};

PROTOBUF_NOINLINE void Pronunciation::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Pronunciation)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_.ClearToEmpty();
  _impl_.alphabet_ = 0;
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Pronunciation::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Pronunciation& this_ = static_cast<const Pronunciation&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Pronunciation::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Pronunciation& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.Pronunciation)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // .valhalla.Pronunciation.Alphabet alphabet = 1;
          if (this_._internal_alphabet() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                1, this_._internal_alphabet(), target);
          }

          // string value = 2;
          if (!this_._internal_value().empty()) {
            const std::string& _s = this_._internal_value();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.Pronunciation.value");
            target = stream->WriteStringMaybeAliased(2, _s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.Pronunciation)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Pronunciation::ByteSizeLong(const MessageLite& base) {
          const Pronunciation& this_ = static_cast<const Pronunciation&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Pronunciation::ByteSizeLong() const {
          const Pronunciation& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.Pronunciation)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // string value = 2;
            if (!this_._internal_value().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_value());
            }
            // .valhalla.Pronunciation.Alphabet alphabet = 1;
            if (this_._internal_alphabet() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_alphabet());
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void Pronunciation::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Pronunciation*>(&to_msg);
  auto& from = static_cast<const Pronunciation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Pronunciation)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  if (from._internal_alphabet() != 0) {
    _this->_impl_.alphabet_ = from._impl_.alphabet_;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Pronunciation::CopyFrom(const Pronunciation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Pronunciation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Pronunciation::InternalSwap(Pronunciation* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.value_, &other->_impl_.value_, arena);
  swap(_impl_.alphabet_, other->_impl_.alphabet_);
}

// ===================================================================

class StreetName::_Internal {
 public:
  using HasBits =
      decltype(std::declval<StreetName>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(StreetName, _impl_._has_bits_);
};

StreetName::StreetName(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.StreetName)
}
inline PROTOBUF_NDEBUG_INLINE StreetName::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::StreetName& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        value_(arena, from.value_) {}

StreetName::StreetName(
    ::google::protobuf::Arena* arena,
    const StreetName& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  StreetName* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.pronunciation_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::Pronunciation>(
                              arena, *from._impl_.pronunciation_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, is_route_number_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, is_route_number_),
           offsetof(Impl_, language_tag_) -
               offsetof(Impl_, is_route_number_) +
               sizeof(Impl_::language_tag_));

  // @@protoc_insertion_point(copy_constructor:valhalla.StreetName)
}
inline PROTOBUF_NDEBUG_INLINE StreetName::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        value_(arena) {}

inline void StreetName::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, pronunciation_),
           0,
           offsetof(Impl_, language_tag_) -
               offsetof(Impl_, pronunciation_) +
               sizeof(Impl_::language_tag_));
}
StreetName::~StreetName() {
  // @@protoc_insertion_point(destructor:valhalla.StreetName)
  SharedDtor(*this);
}
inline void StreetName::SharedDtor(MessageLite& self) {
  StreetName& this_ = static_cast<StreetName&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.value_.Destroy();
  delete this_._impl_.pronunciation_;
  this_._impl_.~Impl_();
}

inline void* StreetName::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) StreetName(arena);
}
constexpr auto StreetName::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(StreetName),
                                            alignof(StreetName));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<20> StreetName::_class_data_ = {
    {
        &_StreetName_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &StreetName::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<StreetName>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &StreetName::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<StreetName>(), &StreetName::ByteSizeLong,
            &StreetName::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(StreetName, _impl_._cached_size_),
        true,
    },
    "valhalla.StreetName",
};
const ::google::protobuf::internal::ClassData* StreetName::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 33, 2> StreetName::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(StreetName, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::StreetName>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .valhalla.LanguageTag language_tag = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(StreetName, _impl_.language_tag_)}},
    // string value = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(StreetName, _impl_.value_)}},
    // bool is_route_number = 2;
    {::_pbi::TcParser::FastV8S1,
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(StreetName, _impl_.is_route_number_)}},
    // .valhalla.Pronunciation pronunciation = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(StreetName, _impl_.pronunciation_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string value = 1;
    {PROTOBUF_FIELD_OFFSET(StreetName, _impl_.value_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bool is_route_number = 2;
    {PROTOBUF_FIELD_OFFSET(StreetName, _impl_.is_route_number_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // .valhalla.Pronunciation pronunciation = 3;
    {PROTOBUF_FIELD_OFFSET(StreetName, _impl_.pronunciation_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .valhalla.LanguageTag language_tag = 4;
    {PROTOBUF_FIELD_OFFSET(StreetName, _impl_.language_tag_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::Pronunciation>()},
  }}, {{
    "\23\5\0\0\0\0\0\0"
    "valhalla.StreetName"
    "value"
  }},
};

PROTOBUF_NOINLINE void StreetName::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.StreetName)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.pronunciation_ != nullptr);
    _impl_.pronunciation_->Clear();
  }
  ::memset(&_impl_.is_route_number_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.language_tag_) -
      reinterpret_cast<char*>(&_impl_.is_route_number_)) + sizeof(_impl_.language_tag_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* StreetName::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const StreetName& this_ = static_cast<const StreetName&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* StreetName::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const StreetName& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.StreetName)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string value = 1;
          if (!this_._internal_value().empty()) {
            const std::string& _s = this_._internal_value();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "valhalla.StreetName.value");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // bool is_route_number = 2;
          if (this_._internal_is_route_number() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                2, this_._internal_is_route_number(), target);
          }

          cached_has_bits = this_._impl_._has_bits_[0];
          // .valhalla.Pronunciation pronunciation = 3;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                3, *this_._impl_.pronunciation_, this_._impl_.pronunciation_->GetCachedSize(), target,
                stream);
          }

          // .valhalla.LanguageTag language_tag = 4;
          if (this_._internal_language_tag() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                4, this_._internal_language_tag(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.StreetName)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t StreetName::ByteSizeLong(const MessageLite& base) {
          const StreetName& this_ = static_cast<const StreetName&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t StreetName::ByteSizeLong() const {
          const StreetName& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.StreetName)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // string value = 1;
            if (!this_._internal_value().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_value());
            }
          }
           {
            // .valhalla.Pronunciation pronunciation = 3;
            cached_has_bits = this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.pronunciation_);
            }
          }
           {
            // bool is_route_number = 2;
            if (this_._internal_is_route_number() != 0) {
              total_size += 2;
            }
            // .valhalla.LanguageTag language_tag = 4;
            if (this_._internal_language_tag() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_language_tag());
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void StreetName::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<StreetName*>(&to_msg);
  auto& from = static_cast<const StreetName&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.StreetName)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(from._impl_.pronunciation_ != nullptr);
    if (_this->_impl_.pronunciation_ == nullptr) {
      _this->_impl_.pronunciation_ =
          ::google::protobuf::MessageLite::CopyConstruct<::valhalla::Pronunciation>(arena, *from._impl_.pronunciation_);
    } else {
      _this->_impl_.pronunciation_->MergeFrom(*from._impl_.pronunciation_);
    }
  }
  if (from._internal_is_route_number() != 0) {
    _this->_impl_.is_route_number_ = from._impl_.is_route_number_;
  }
  if (from._internal_language_tag() != 0) {
    _this->_impl_.language_tag_ = from._impl_.language_tag_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StreetName::CopyFrom(const StreetName& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.StreetName)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void StreetName::InternalSwap(StreetName* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.value_, &other->_impl_.value_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreetName, _impl_.language_tag_)
      + sizeof(StreetName::_impl_.language_tag_)
      - PROTOBUF_FIELD_OFFSET(StreetName, _impl_.pronunciation_)>(
          reinterpret_cast<char*>(&_impl_.pronunciation_),
          reinterpret_cast<char*>(&other->_impl_.pronunciation_));
}

// ===================================================================

class TurnLane::_Internal {
 public:
};

TurnLane::TurnLane(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TurnLane)
}
TurnLane::TurnLane(
    ::google::protobuf::Arena* arena, const TurnLane& from)
    : TurnLane(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE TurnLane::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void TurnLane::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, directions_mask_),
           0,
           offsetof(Impl_, active_direction_) -
               offsetof(Impl_, directions_mask_) +
               sizeof(Impl_::active_direction_));
}
TurnLane::~TurnLane() {
  // @@protoc_insertion_point(destructor:valhalla.TurnLane)
  SharedDtor(*this);
}
inline void TurnLane::SharedDtor(MessageLite& self) {
  TurnLane& this_ = static_cast<TurnLane&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* TurnLane::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TurnLane(arena);
}
constexpr auto TurnLane::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(TurnLane),
                                            alignof(TurnLane));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<18> TurnLane::_class_data_ = {
    {
        &_TurnLane_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TurnLane::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TurnLane>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TurnLane::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TurnLane>(), &TurnLane::ByteSizeLong,
            &TurnLane::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TurnLane, _impl_._cached_size_),
        true,
    },
    "valhalla.TurnLane",
};
const ::google::protobuf::internal::ClassData* TurnLane::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> TurnLane::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TurnLane>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // uint32 directions_mask = 1;
    {::_pbi::TcParser::FastV32S1,
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(TurnLane, _impl_.directions_mask_)}},
    // .valhalla.TurnLane.State state = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(TurnLane, _impl_.state_)}},
    // uint32 active_direction = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(TurnLane, _impl_.active_direction_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 directions_mask = 1;
    {PROTOBUF_FIELD_OFFSET(TurnLane, _impl_.directions_mask_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // .valhalla.TurnLane.State state = 2;
    {PROTOBUF_FIELD_OFFSET(TurnLane, _impl_.state_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // uint32 active_direction = 3;
    {PROTOBUF_FIELD_OFFSET(TurnLane, _impl_.active_direction_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void TurnLane::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TurnLane)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.directions_mask_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.active_direction_) -
      reinterpret_cast<char*>(&_impl_.directions_mask_)) + sizeof(_impl_.active_direction_));
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TurnLane::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TurnLane& this_ = static_cast<const TurnLane&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TurnLane::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TurnLane& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TurnLane)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // uint32 directions_mask = 1;
          if (this_._internal_directions_mask() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                1, this_._internal_directions_mask(), target);
          }

          // .valhalla.TurnLane.State state = 2;
          if (this_._internal_state() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                2, this_._internal_state(), target);
          }

          // uint32 active_direction = 3;
          if (this_._internal_active_direction() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                3, this_._internal_active_direction(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TurnLane)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TurnLane::ByteSizeLong(const MessageLite& base) {
          const TurnLane& this_ = static_cast<const TurnLane&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TurnLane::ByteSizeLong() const {
          const TurnLane& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TurnLane)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // uint32 directions_mask = 1;
            if (this_._internal_directions_mask() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_directions_mask());
            }
            // .valhalla.TurnLane.State state = 2;
            if (this_._internal_state() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_state());
            }
            // uint32 active_direction = 3;
            if (this_._internal_active_direction() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_active_direction());
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TurnLane::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TurnLane*>(&to_msg);
  auto& from = static_cast<const TurnLane&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TurnLane)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_directions_mask() != 0) {
    _this->_impl_.directions_mask_ = from._impl_.directions_mask_;
  }
  if (from._internal_state() != 0) {
    _this->_impl_.state_ = from._impl_.state_;
  }
  if (from._internal_active_direction() != 0) {
    _this->_impl_.active_direction_ = from._impl_.active_direction_;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TurnLane::CopyFrom(const TurnLane& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TurnLane)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TurnLane::InternalSwap(TurnLane* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TurnLane, _impl_.active_direction_)
      + sizeof(TurnLane::_impl_.active_direction_)
      - PROTOBUF_FIELD_OFFSET(TurnLane, _impl_.directions_mask_)>(
          reinterpret_cast<char*>(&_impl_.directions_mask_),
          reinterpret_cast<char*>(&other->_impl_.directions_mask_));
}

// ===================================================================

class TaggedValue::_Internal {
 public:
};

TaggedValue::TaggedValue(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.TaggedValue)
}
inline PROTOBUF_NDEBUG_INLINE TaggedValue::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::TaggedValue& from_msg)
      : value_(arena, from.value_),
        _cached_size_{0} {}

TaggedValue::TaggedValue(
    ::google::protobuf::Arena* arena,
    const TaggedValue& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TaggedValue* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.type_ = from._impl_.type_;

  // @@protoc_insertion_point(copy_constructor:valhalla.TaggedValue)
}
inline PROTOBUF_NDEBUG_INLINE TaggedValue::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : value_(arena),
        _cached_size_{0} {}

inline void TaggedValue::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.type_ = {};
}
TaggedValue::~TaggedValue() {
  // @@protoc_insertion_point(destructor:valhalla.TaggedValue)
  SharedDtor(*this);
}
inline void TaggedValue::SharedDtor(MessageLite& self) {
  TaggedValue& this_ = static_cast<TaggedValue&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.value_.Destroy();
  this_._impl_.~Impl_();
}

inline void* TaggedValue::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) TaggedValue(arena);
}
constexpr auto TaggedValue::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(TaggedValue),
                                            alignof(TaggedValue));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<21> TaggedValue::_class_data_ = {
    {
        &_TaggedValue_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &TaggedValue::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<TaggedValue>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &TaggedValue::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<TaggedValue>(), &TaggedValue::ByteSizeLong,
            &TaggedValue::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(TaggedValue, _impl_._cached_size_),
        true,
    },
    "valhalla.TaggedValue",
};
const ::google::protobuf::internal::ClassData* TaggedValue::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> TaggedValue::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::TaggedValue>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .valhalla.TaggedValue.Type type = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(TaggedValue, _impl_.type_)}},
    // bytes value = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(TaggedValue, _impl_.value_)}},
  }}, {{
    65535, 65535
  }}, {{
    // bytes value = 1;
    {PROTOBUF_FIELD_OFFSET(TaggedValue, _impl_.value_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBytes | ::_fl::kRepAString)},
    // .valhalla.TaggedValue.Type type = 2;
    {PROTOBUF_FIELD_OFFSET(TaggedValue, _impl_.type_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void TaggedValue::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TaggedValue)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_.ClearToEmpty();
  _impl_.type_ = 0;
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* TaggedValue::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const TaggedValue& this_ = static_cast<const TaggedValue&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* TaggedValue::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const TaggedValue& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.TaggedValue)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // bytes value = 1;
          if (!this_._internal_value().empty()) {
            const std::string& _s = this_._internal_value();
            target = stream->WriteBytesMaybeAliased(1, _s, target);
          }

          // .valhalla.TaggedValue.Type type = 2;
          if (this_._internal_type() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                2, this_._internal_type(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.TaggedValue)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t TaggedValue::ByteSizeLong(const MessageLite& base) {
          const TaggedValue& this_ = static_cast<const TaggedValue&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t TaggedValue::ByteSizeLong() const {
          const TaggedValue& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.TaggedValue)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // bytes value = 1;
            if (!this_._internal_value().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                              this_._internal_value());
            }
            // .valhalla.TaggedValue.Type type = 2;
            if (this_._internal_type() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_type());
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void TaggedValue::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TaggedValue*>(&to_msg);
  auto& from = static_cast<const TaggedValue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TaggedValue)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  if (from._internal_type() != 0) {
    _this->_impl_.type_ = from._impl_.type_;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TaggedValue::CopyFrom(const TaggedValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TaggedValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TaggedValue::InternalSwap(TaggedValue* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.value_, &other->_impl_.value_, arena);
  swap(_impl_.type_, other->_impl_.type_);
}

// ===================================================================

class Summary::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Summary>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Summary, _impl_._has_bits_);
};

Summary::Summary(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.Summary)
}
inline PROTOBUF_NDEBUG_INLINE Summary::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::valhalla::Summary& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

Summary::Summary(
    ::google::protobuf::Arena* arena,
    const Summary& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Summary* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.bbox_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::MessageLite::CopyConstruct<::valhalla::BoundingBox>(
                              arena, *from._impl_.bbox_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, time_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, time_),
           offsetof(Impl_, has_highway_) -
               offsetof(Impl_, time_) +
               sizeof(Impl_::has_highway_));

  // @@protoc_insertion_point(copy_constructor:valhalla.Summary)
}
inline PROTOBUF_NDEBUG_INLINE Summary::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void Summary::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, bbox_),
           0,
           offsetof(Impl_, has_highway_) -
               offsetof(Impl_, bbox_) +
               sizeof(Impl_::has_highway_));
}
Summary::~Summary() {
  // @@protoc_insertion_point(destructor:valhalla.Summary)
  SharedDtor(*this);
}
inline void Summary::SharedDtor(MessageLite& self) {
  Summary& this_ = static_cast<Summary&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.bbox_;
  this_._impl_.~Impl_();
}

inline void* Summary::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) Summary(arena);
}
constexpr auto Summary::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(Summary),
                                            alignof(Summary));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<17> Summary::_class_data_ = {
    {
        &_Summary_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &Summary::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<Summary>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &Summary::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<Summary>(), &Summary::ByteSizeLong,
            &Summary::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(Summary, _impl_._cached_size_),
        true,
    },
    "valhalla.Summary",
};
const ::google::protobuf::internal::ClassData* Summary::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 1, 0, 2> Summary::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Summary, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::Summary>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // float length = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 63, 0, PROTOBUF_FIELD_OFFSET(Summary, _impl_.length_)}},
    // double time = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(Summary, _impl_.time_)}},
    // .valhalla.BoundingBox bbox = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(Summary, _impl_.bbox_)}},
    // bool has_time_restrictions = 4;
    {::_pbi::TcParser::FastV8S1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(Summary, _impl_.has_time_restrictions_)}},
    // bool has_toll = 5;
    {::_pbi::TcParser::FastV8S1,
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(Summary, _impl_.has_toll_)}},
    // bool has_ferry = 6;
    {::_pbi::TcParser::FastV8S1,
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(Summary, _impl_.has_ferry_)}},
    // bool has_highway = 7;
    {::_pbi::TcParser::FastV8S1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(Summary, _impl_.has_highway_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float length = 1;
    {PROTOBUF_FIELD_OFFSET(Summary, _impl_.length_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // double time = 2;
    {PROTOBUF_FIELD_OFFSET(Summary, _impl_.time_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // .valhalla.BoundingBox bbox = 3;
    {PROTOBUF_FIELD_OFFSET(Summary, _impl_.bbox_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // bool has_time_restrictions = 4;
    {PROTOBUF_FIELD_OFFSET(Summary, _impl_.has_time_restrictions_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool has_toll = 5;
    {PROTOBUF_FIELD_OFFSET(Summary, _impl_.has_toll_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool has_ferry = 6;
    {PROTOBUF_FIELD_OFFSET(Summary, _impl_.has_ferry_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool has_highway = 7;
    {PROTOBUF_FIELD_OFFSET(Summary, _impl_.has_highway_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
  }}, {{
    {::_pbi::TcParser::GetTable<::valhalla::BoundingBox>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void Summary::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Summary)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.bbox_ != nullptr);
    _impl_.bbox_->Clear();
  }
  ::memset(&_impl_.time_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.has_highway_) -
      reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.has_highway_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Summary::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Summary& this_ = static_cast<const Summary&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Summary::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Summary& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.Summary)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // float length = 1;
          if (::absl::bit_cast<::uint32_t>(this_._internal_length()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                1, this_._internal_length(), target);
          }

          // double time = 2;
          if (::absl::bit_cast<::uint64_t>(this_._internal_time()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                2, this_._internal_time(), target);
          }

          cached_has_bits = this_._impl_._has_bits_[0];
          // .valhalla.BoundingBox bbox = 3;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                3, *this_._impl_.bbox_, this_._impl_.bbox_->GetCachedSize(), target,
                stream);
          }

          // bool has_time_restrictions = 4;
          if (this_._internal_has_time_restrictions() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                4, this_._internal_has_time_restrictions(), target);
          }

          // bool has_toll = 5;
          if (this_._internal_has_toll() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                5, this_._internal_has_toll(), target);
          }

          // bool has_ferry = 6;
          if (this_._internal_has_ferry() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                6, this_._internal_has_ferry(), target);
          }

          // bool has_highway = 7;
          if (this_._internal_has_highway() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                7, this_._internal_has_highway(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.Summary)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Summary::ByteSizeLong(const MessageLite& base) {
          const Summary& this_ = static_cast<const Summary&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Summary::ByteSizeLong() const {
          const Summary& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.Summary)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // .valhalla.BoundingBox bbox = 3;
            cached_has_bits = this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.bbox_);
            }
          }
           {
            // double time = 2;
            if (::absl::bit_cast<::uint64_t>(this_._internal_time()) != 0) {
              total_size += 9;
            }
            // float length = 1;
            if (::absl::bit_cast<::uint32_t>(this_._internal_length()) != 0) {
              total_size += 5;
            }
            // bool has_time_restrictions = 4;
            if (this_._internal_has_time_restrictions() != 0) {
              total_size += 2;
            }
            // bool has_toll = 5;
            if (this_._internal_has_toll() != 0) {
              total_size += 2;
            }
            // bool has_ferry = 6;
            if (this_._internal_has_ferry() != 0) {
              total_size += 2;
            }
            // bool has_highway = 7;
            if (this_._internal_has_highway() != 0) {
              total_size += 2;
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void Summary::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Summary*>(&to_msg);
  auto& from = static_cast<const Summary&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Summary)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(from._impl_.bbox_ != nullptr);
    if (_this->_impl_.bbox_ == nullptr) {
      _this->_impl_.bbox_ =
          ::google::protobuf::MessageLite::CopyConstruct<::valhalla::BoundingBox>(arena, *from._impl_.bbox_);
    } else {
      _this->_impl_.bbox_->MergeFrom(*from._impl_.bbox_);
    }
  }
  if (::absl::bit_cast<::uint64_t>(from._internal_time()) != 0) {
    _this->_impl_.time_ = from._impl_.time_;
  }
  if (::absl::bit_cast<::uint32_t>(from._internal_length()) != 0) {
    _this->_impl_.length_ = from._impl_.length_;
  }
  if (from._internal_has_time_restrictions() != 0) {
    _this->_impl_.has_time_restrictions_ = from._impl_.has_time_restrictions_;
  }
  if (from._internal_has_toll() != 0) {
    _this->_impl_.has_toll_ = from._impl_.has_toll_;
  }
  if (from._internal_has_ferry() != 0) {
    _this->_impl_.has_ferry_ = from._impl_.has_ferry_;
  }
  if (from._internal_has_highway() != 0) {
    _this->_impl_.has_highway_ = from._impl_.has_highway_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Summary::CopyFrom(const Summary& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Summary)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Summary::InternalSwap(Summary* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Summary, _impl_.has_highway_)
      + sizeof(Summary::_impl_.has_highway_)
      - PROTOBUF_FIELD_OFFSET(Summary, _impl_.bbox_)>(
          reinterpret_cast<char*>(&_impl_.bbox_),
          reinterpret_cast<char*>(&other->_impl_.bbox_));
}

// ===================================================================

class LevelChange::_Internal {
 public:
};

LevelChange::LevelChange(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:valhalla.LevelChange)
}
LevelChange::LevelChange(
    ::google::protobuf::Arena* arena, const LevelChange& from)
    : LevelChange(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE LevelChange::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void LevelChange::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, shape_index_),
           0,
           offsetof(Impl_, precision_) -
               offsetof(Impl_, shape_index_) +
               sizeof(Impl_::precision_));
}
LevelChange::~LevelChange() {
  // @@protoc_insertion_point(destructor:valhalla.LevelChange)
  SharedDtor(*this);
}
inline void LevelChange::SharedDtor(MessageLite& self) {
  LevelChange& this_ = static_cast<LevelChange&>(self);
  this_._internal_metadata_.Delete<std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* LevelChange::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) LevelChange(arena);
}
constexpr auto LevelChange::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(LevelChange),
                                            alignof(LevelChange));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<21> LevelChange::_class_data_ = {
    {
        &_LevelChange_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &LevelChange::MergeImpl,
        ::google::protobuf::MessageLite::GetNewImpl<LevelChange>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &LevelChange::SharedDtor,
        ::google::protobuf::MessageLite::GetClearImpl<LevelChange>(), &LevelChange::ByteSizeLong,
            &LevelChange::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(LevelChange, _impl_._cached_size_),
        true,
    },
    "valhalla.LevelChange",
};
const ::google::protobuf::internal::ClassData* LevelChange::GetClassData() const {
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> LevelChange::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::valhalla::LevelChange>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // uint32 shape_index = 1;
    {::_pbi::TcParser::FastV32S1,
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(LevelChange, _impl_.shape_index_)}},
    // float level = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(LevelChange, _impl_.level_)}},
    // uint32 precision = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(LevelChange, _impl_.precision_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 shape_index = 1;
    {PROTOBUF_FIELD_OFFSET(LevelChange, _impl_.shape_index_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // float level = 2;
    {PROTOBUF_FIELD_OFFSET(LevelChange, _impl_.level_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // uint32 precision = 3;
    {PROTOBUF_FIELD_OFFSET(LevelChange, _impl_.precision_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void LevelChange::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.LevelChange)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.shape_index_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.precision_) -
      reinterpret_cast<char*>(&_impl_.shape_index_)) + sizeof(_impl_.precision_));
  _internal_metadata_.Clear<std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* LevelChange::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const LevelChange& this_ = static_cast<const LevelChange&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* LevelChange::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const LevelChange& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:valhalla.LevelChange)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // uint32 shape_index = 1;
          if (this_._internal_shape_index() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                1, this_._internal_shape_index(), target);
          }

          // float level = 2;
          if (::absl::bit_cast<::uint32_t>(this_._internal_level()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                2, this_._internal_level(), target);
          }

          // uint32 precision = 3;
          if (this_._internal_precision() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                3, this_._internal_precision(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target = stream->WriteRaw(
                this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
                static_cast<int>(this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
          }
          // @@protoc_insertion_point(serialize_to_array_end:valhalla.LevelChange)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t LevelChange::ByteSizeLong(const MessageLite& base) {
          const LevelChange& this_ = static_cast<const LevelChange&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t LevelChange::ByteSizeLong() const {
          const LevelChange& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:valhalla.LevelChange)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // uint32 shape_index = 1;
            if (this_._internal_shape_index() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_shape_index());
            }
            // float level = 2;
            if (::absl::bit_cast<::uint32_t>(this_._internal_level()) != 0) {
              total_size += 5;
            }
            // uint32 precision = 3;
            if (this_._internal_precision() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_precision());
            }
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            total_size += this_._internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
          }
          this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
          return total_size;
        }

void LevelChange::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<LevelChange*>(&to_msg);
  auto& from = static_cast<const LevelChange&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:valhalla.LevelChange)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_shape_index() != 0) {
    _this->_impl_.shape_index_ = from._impl_.shape_index_;
  }
  if (::absl::bit_cast<::uint32_t>(from._internal_level()) != 0) {
    _this->_impl_.level_ = from._impl_.level_;
  }
  if (from._internal_precision() != 0) {
    _this->_impl_.precision_ = from._impl_.precision_;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LevelChange::CopyFrom(const LevelChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.LevelChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LevelChange::InternalSwap(LevelChange* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LevelChange, _impl_.precision_)
      + sizeof(LevelChange::_impl_.precision_)
      - PROTOBUF_FIELD_OFFSET(LevelChange, _impl_.shape_index_)>(
          reinterpret_cast<char*>(&_impl_.shape_index_),
          reinterpret_cast<char*>(&other->_impl_.shape_index_));
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace valhalla
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
